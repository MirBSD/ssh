--- src/usr.bin/ssh/Makefile.inc:1.1.1.3	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/Makefile.inc	Thu Jan 14 20:23:00 2016
@@ -1,31 +1,40 @@
-#	$OpenBSD: Makefile.inc,v 1.33 2008/11/04 08:22:12 djm Exp $
+# $MirOS: src/usr.bin/ssh/Makefile.inc,v 1.16 2016/01/14 19:23:00 tg Exp $
+# $OpenBSD: Makefile.inc,v 1.33 2008/11/04 08:22:12 djm Exp $
 
-CFLAGS+=	-I${.CURDIR}/..
+.ifndef _MODSRC_USR_BIN_SSH_MAKEFILE_INC
+_MODSRC_USR_BIN_SSH_MAKEFILE_INC=1
 
-CDIAGFLAGS=	-Wall
-#CDIAGFLAGS+=	-Werror
-CDIAGFLAGS+=	-Wpointer-arith
-CDIAGFLAGS+=	-Wno-uninitialized
-CDIAGFLAGS+=	-Wstrict-prototypes
-CDIAGFLAGS+=	-Wmissing-prototypes
-CDIAGFLAGS+=	-Wunused
-CDIAGFLAGS+=	-Wsign-compare
-CDIAGFLAGS+=	-Wbounded
-CDIAGFLAGS+=	-Wshadow
+CPPFLAGS+=	-I${.CURDIR}/..
 
-#DEBUG=-g
+CFLAGS+=	-Wall
+CFLAGS+=	-Wpointer-arith
+CFLAGS+=	-Wno-uninitialized
+CFLAGS+=	-Wstrict-prototypes
+CFLAGS+=	-Wmissing-prototypes
+CFLAGS+=	-Wunused
+CFLAGS+=	-Wsign-compare
+CFLAGS+=	-Wbounded
+CFLAGS+=	-Wshadow
+
+CDIAGFLAGS+=	-Wno-cast-qual
 
-#CFLAGS+=	-DJPAKE
+#DEBUG=-g
 
-#CFLAGS+=	-DSMARTCARD
+#CPPFLAGS+=	-DSMARTCARD
 #LDADD+=	-lsectok
 
 .include <bsd.obj.mk>
 
 .if exists(${.CURDIR}/../lib/${__objdir})
-LDADD+=         -L${.CURDIR}/../lib/${__objdir} -lssh
-DPADD+=         ${.CURDIR}/../lib/${__objdir}/libssh.a
+LDADD+=		-L${.CURDIR}/../lib/${__objdir} -lssh
+DPADD+=		${.CURDIR}/../lib/${__objdir}/libssh.a
 .else
-LDADD+=         -L${.CURDIR}/../lib -lssh
-DPADD+=         ${.CURDIR}/../lib/libssh.a
+LDADD+=		-L${.CURDIR}/../lib -lssh
+DPADD+=		${.CURDIR}/../lib/libssh.a
+.endif
+
+.if exists(../Makefile.inc)
+.  include "../Makefile.inc"
+.endif
+
 .endif
Index: src/usr.bin/ssh/PROTOCOL
diff -up src/usr.bin/ssh/PROTOCOL:1.1.1.2 src/usr.bin/ssh/PROTOCOL:1.2
--- src/usr.bin/ssh/PROTOCOL:1.1.1.2	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/PROTOCOL	Mon Aug  7 22:18:54 2017
@@ -231,15 +231,15 @@ These requests return a SSH_FXP_STATUS r
 return the following SSH_FXP_EXTENDED_REPLY reply:
 
 	uint32		id
-	uint64		f_bsize		/* file system block size */
+	uint64		f_bsize		/* filesystem block size */
 	uint64		f_frsize	/* fundamental fs block size */
 	uint64		f_blocks	/* number of blocks (unit f_frsize) */
-	uint64		f_bfree		/* free blocks in file system */
+	uint64		f_bfree		/* free blocks in filesystem */
 	uint64		f_bavail	/* free blocks for non-root */
 	uint64		f_files		/* total file inodes */
 	uint64		f_ffree		/* free file inodes */
 	uint64		f_favail	/* free file inodes for to non-root */
-	uint64		f_fsid		/* file system id */
+	uint64		f_fsid		/* filesystem id */
 	uint64		f_flag		/* bit mask of f_flag values */
 	uint64		f_namemax	/* maximum filename length */
 
Index: src/usr.bin/ssh/README
diff -up src/usr.bin/ssh/README:1.1.1.2 src/usr.bin/ssh/README:1.4
--- src/usr.bin/ssh/README:1.1.1.2	Wed Apr 19 12:15:02 2006
+++ src/usr.bin/ssh/README	Tue Dec 16 21:55:18 2008
@@ -1,4 +1,4 @@
-This release of OpenSSH is for OpenBSD systems only.
+This release of OpenSSH is for MirOS BSD systems only.
 
 Please read
 	http://www.openssh.com/portable.html
@@ -24,4 +24,5 @@ for SSH protocol versions 1.5 and 2.0.
 
 See http://www.openssh.com/ for more information.
 
+$MirOS: src/usr.bin/ssh/README,v 1.4 2008/12/16 20:55:18 tg Exp $
 $OpenBSD: README,v 1.7 2006/04/01 05:37:46 djm Exp $
Index: src/usr.bin/ssh/addrmatch.c
diff -up src/usr.bin/ssh/addrmatch.c:1.1.1.1 src/usr.bin/ssh/addrmatch.c:1.2
--- src/usr.bin/ssh/addrmatch.c:1.1.1.1	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/addrmatch.c	Sun Oct  4 18:35:24 2009
@@ -23,6 +23,7 @@
 
 #include <netdb.h>
 #include <string.h>
+#include <stddef.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
@@ -79,24 +80,24 @@ masklen_valid(int af, u_int masklen)
 static int
 addr_sa_to_xaddr(struct sockaddr *sa, socklen_t slen, struct xaddr *xa)
 {
-	struct sockaddr_in *in4 = (struct sockaddr_in *)sa;
-	struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;
-
 	memset(xa, '\0', sizeof(*xa));
 
 	switch (sa->sa_family) {
 	case AF_INET:
-		if (slen < sizeof(*in4))
+		if (slen < sizeof(struct sockaddr_in))
 			return -1;
 		xa->af = AF_INET;
-		memcpy(&xa->v4, &in4->sin_addr, sizeof(xa->v4));
+		memcpy(&xa->v4, (char *)sa + offsetof(struct sockaddr_in,
+		    sin_addr), sizeof(xa->v4));
 		break;
 	case AF_INET6:
-		if (slen < sizeof(*in6))
+		if (slen < sizeof(struct sockaddr_in6))
 			return -1;
 		xa->af = AF_INET6;
-		memcpy(&xa->v6, &in6->sin6_addr, sizeof(xa->v6));
-		xa->scope_id = in6->sin6_scope_id;
+		memcpy(&xa->v6, (char *)sa + offsetof(struct sockaddr_in6,
+		    sin6_addr), sizeof(xa->v6));
+		memcpy(&xa->scope_id, (char *)sa + offsetof(struct sockaddr_in6,
+		    sin6_scope_id), sizeof(xa->scope_id));
 		break;
 	default:
 		return -1;
Index: src/usr.bin/ssh/auth-bsdauth.c
diff -up src/usr.bin/ssh/auth-bsdauth.c:1.1.1.4 src/usr.bin/ssh/auth-bsdauth.c:1.5
--- src/usr.bin/ssh/auth-bsdauth.c:1.1.1.4	Sun Mar  2 21:40:41 2008
+++ src/usr.bin/ssh/auth-bsdauth.c	Sun Mar  2 22:14:18 2008
@@ -25,17 +25,17 @@
 
 #include <sys/types.h>
 
+#ifdef BSD_AUTH
 #include "xmalloc.h"
 #include "key.h"
 #include "hostfile.h"
 #include "auth.h"
 #include "log.h"
 #include "buffer.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth-bsdauth.c,v 1.5 2008/03/02 21:14:18 tg Exp $");
+
 static void *
 bsdauth_init_ctx(Authctxt *authctxt)
 {
@@ -130,3 +130,4 @@ KbdintDevice mm_bsdauth_device = {
 	mm_bsdauth_respond,
 	bsdauth_free_ctx
 };
+#endif
Index: src/usr.bin/ssh/auth-options.c
diff -up src/usr.bin/ssh/auth-options.c:1.1.1.8 src/usr.bin/ssh/auth-options.c:1.6
--- src/usr.bin/ssh/auth-options.c:1.1.1.8	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/auth-options.c	Sun Mar 22 16:01:11 2009
@@ -31,12 +31,11 @@
 #include "key.h"
 #include "hostfile.h"
 #include "auth.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
-/* Flags set authorized_keys flags */
+__RCSID("$MirOS: src/usr.bin/ssh/auth-options.c,v 1.6 2009/03/22 15:01:11 tg Exp $");
+
+/* Flags set authorised_keys flags */
 int no_port_forwarding_flag = 0;
 int no_agent_forwarding_flag = 0;
 int no_x11_forwarding_flag = 0;
Index: src/usr.bin/ssh/auth-options.h
diff -up src/usr.bin/ssh/auth-options.h:1.1.1.5 src/usr.bin/ssh/auth-options.h:1.5
--- src/usr.bin/ssh/auth-options.h:1.1.1.5	Thu Apr  3 20:34:30 2008
+++ src/usr.bin/ssh/auth-options.h	Tue Dec 16 21:55:18 2008
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/auth-options.h,v 1.5 2008/12/16 20:55:18 tg Exp $ */
 /* $OpenBSD: auth-options.h,v 1.17 2008/03/26 21:28:14 djm Exp $ */
 
 /*
@@ -21,7 +22,7 @@ struct envstring {
 	char   *s;
 };
 
-/* Flags that may be set in authorized_keys options. */
+/* Flags that may be set in authorised_keys options. */
 extern int no_port_forwarding_flag;
 extern int no_agent_forwarding_flag;
 extern int no_x11_forwarding_flag;
Index: src/usr.bin/ssh/auth-passwd.c
diff -up src/usr.bin/ssh/auth-passwd.c:1.1.1.6 src/usr.bin/ssh/auth-passwd.c:1.9
--- src/usr.bin/ssh/auth-passwd.c:1.1.1.6	Sun Mar  2 21:40:41 2008
+++ src/usr.bin/ssh/auth-passwd.c	Sun Mar  2 22:14:18 2008
@@ -43,6 +43,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
+#include <unistd.h>
 
 #include "packet.h"
 #include "buffer.h"
@@ -53,6 +54,8 @@
 #include "auth.h"
 #include "auth-options.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth-passwd.c,v 1.9 2008/03/02 21:14:18 tg Exp $");
+
 extern Buffer loginmsg;
 extern ServerOptions options;
 int sys_auth_passwd(Authctxt *, const char *);
@@ -62,6 +65,7 @@ extern login_cap_t *lc;
 #define DAY		(24L * 60 * 60) /* 1 day in seconds */
 #define TWO_WEEKS	(2L * 7 * DAY)	/* 2 weeks in seconds */
 
+#ifdef BSD_AUTH
 static void
 disable_forwarding(void)
 {
@@ -69,6 +73,7 @@ disable_forwarding(void)
 	no_agent_forwarding_flag = 1;
 	no_x11_forwarding_flag = 1;
 }
+#endif
 
 /*
  * Tries to authenticate the user using password.  Returns true if
@@ -84,17 +89,10 @@ auth_password(Authctxt *authctxt, const 
 		ok = 0;
 	if (*password == '\0' && options.permit_empty_passwd == 0)
 		return 0;
-#ifdef KRB5
-	if (options.kerberos_authentication == 1) {
-		int ret = auth_krb5_password(authctxt, password);
-		if (ret == 1 || ret == 0)
-			return ret && ok;
-		/* Fall back to ordinary passwd authentication. */
-	}
-#endif
 	return (sys_auth_passwd(authctxt, password) && ok);
 }
 
+#ifdef BSD_AUTH
 static void
 warn_expiry(Authctxt *authctxt, auth_session_t *as)
 {
@@ -151,3 +149,26 @@ sys_auth_passwd(Authctxt *authctxt, cons
 		return (auth_close(as));
 	}
 }
+#else
+int
+sys_auth_passwd(Authctxt *authctxt, const char *password)
+{
+	struct passwd *pw = authctxt->pw;
+	char *encrypted_password;
+
+	/* Check for users with no password. */
+	if (strcmp(password, "") == 0 && strcmp(pw->pw_passwd, "") == 0)
+		return (1);
+
+	/* Encrypt the candidate password using the proper salt. */
+	encrypted_password = crypt(password,
+	    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
+	    pw->pw_passwd : "xx");
+
+	/*
+	 * Authentication is accepted if the encrypted passwords
+	 * are identical.
+	 */
+	return (strcmp(encrypted_password, pw->pw_passwd) == 0);
+}
+#endif
Index: src/usr.bin/ssh/auth-rh-rsa.c
diff -up src/usr.bin/ssh/auth-rh-rsa.c:1.1.1.4 src/usr.bin/ssh/auth-rh-rsa.c:1.4
--- src/usr.bin/ssh/auth-rh-rsa.c:1.1.1.4	Wed Sep 20 21:06:47 2006
+++ src/usr.bin/ssh/auth-rh-rsa.c	Sat Jan 15 22:52:39 2011
@@ -28,11 +28,10 @@
 #include "pathnames.h"
 #include "auth.h"
 #include "canohost.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth-rh-rsa.c,v 1.4 2011/01/15 21:52:39 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 
@@ -48,7 +47,12 @@ auth_rhosts_rsa_key_allowed(struct passw
 
 	host_status = check_key_in_hostfiles(pw, client_host_key,
 	    chost, _PATH_SSH_SYSTEM_HOSTFILE,
-	    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);
+	    options.ignore_user_known_hosts ? NULL :
+#ifdef _PATH_SSH_ROOT_HOSTFILE
+	    (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
+	    !pw->pw_dir[1])) ? _PATH_SSH_ROOT_HOSTFILE :
+#endif
+	    _PATH_SSH_USER_HOSTFILE);
 
 	return (host_status == HOST_OK);
 }
Index: src/usr.bin/ssh/auth-rsa.c
diff -up src/usr.bin/ssh/auth-rsa.c:1.1.1.7 src/usr.bin/ssh/auth-rsa.c:1.10
--- src/usr.bin/ssh/auth-rsa.c:1.1.1.7	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth-rsa.c	Tue Dec 16 21:55:18 2008
@@ -18,7 +18,7 @@
 #include <sys/stat.h>
 
 #include <openssl/rsa.h>
-#include <openssl/md5.h>
+#include <md5.h>
 
 #include <pwd.h>
 #include <stdio.h>
@@ -38,13 +38,12 @@
 #include "key.h"
 #include "hostfile.h"
 #include "auth.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "ssh.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.10 2008/12/16 20:55:18 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 
@@ -55,7 +54,7 @@ extern ServerOptions options;
 extern u_char session_id[16];
 
 /*
- * The .ssh/authorized_keys file contains public keys, one per line, in the
+ * The .etc/ssh/authorised_keys file contains public keys, one per line, in the
  * following format:
  *   options bits e n comment
  * where bits, e and n are decimal numbers,
@@ -104,10 +103,10 @@ auth_rsa_verify_response(Key *key, BIGNU
 		fatal("auth_rsa_verify_response: bad challenge length %d", len);
 	memset(buf, 0, 32);
 	BN_bn2bin(challenge, buf + 32 - len);
-	MD5_Init(&md);
-	MD5_Update(&md, buf, 32);
-	MD5_Update(&md, session_id, 16);
-	MD5_Final(mdbuf, &md);
+	MD5Init(&md);
+	MD5Update(&md, buf, 32);
+	MD5Update(&md, session_id, 16);
+	MD5Final(mdbuf, &md);
 
 	/* Verify that the response is the original challenge. */
 	if (memcmp(response, mdbuf, 16) != 0) {
@@ -175,8 +174,8 @@ auth_rsa_key_allowed(struct passwd *pw, 
 	/* Temporarily use the user's uid. */
 	temporarily_use_uid(pw);
 
-	/* The authorized keys. */
-	file = authorized_keys_file(pw);
+	/* The authorised keys. */
+	file = authorised_keys_file(pw);
 	debug("trying public RSA key file %s", file);
 	f = auth_openkeyfile(file, pw, options.strict_modes);
 	if (!f) {
Index: src/usr.bin/ssh/auth.c
diff -up src/usr.bin/ssh/auth.c:1.1.1.9 src/usr.bin/ssh/auth.c:1.14
--- src/usr.bin/ssh/auth.c:1.1.1.9	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth.c	Thu May  3 03:32:44 2018
@@ -1,5 +1,7 @@
 /* $OpenBSD: auth.c,v 1.80 2008/11/04 07:58:09 djm Exp $ */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2000 Markus Friedl.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -23,9 +25,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <sys/param.h>
+#include <sys/stat.h>
 
 #include <errno.h>
 #include <fcntl.h>
@@ -52,14 +53,14 @@
 #include "uidswap.h"
 #include "misc.h"
 #include "packet.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
+#include "pathnames.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/auth.c,v 1.14 2018/05/03 01:32:44 tg Exp $");
 
 /* import */
 extern ServerOptions options;
-extern int use_privsep;
 
 /* Debugging messages */
 Buffer auth_debug;
@@ -79,7 +80,7 @@ allowed_user(struct passwd * pw)
 {
 	struct stat st;
 	const char *hostname = NULL, *ipaddr = NULL;
-	char *shell;
+	const char *shell;
 	u_int i;
 
 	/* Shouldn't be called if pw is NULL, but better safe than sorry... */
@@ -207,7 +214,7 @@ auth_log(Authctxt *authctxt, int authent
  * Check whether root logins are disallowed.
  */
 int
-auth_root_allowed(char *method)
+auth_root_allowed(const char *method)
 {
 	switch (options.permit_root_login) {
 	case PERMIT_YES:
@@ -236,7 +243,7 @@ auth_root_allowed(char *method)
  * This returns a buffer allocated by xmalloc.
  */
 static char *
-expand_authorized_keys(const char *filename, struct passwd *pw)
+expand_authorised_keys(const char *filename, struct passwd *pw)
 {
 	char *file, ret[MAXPATHLEN];
 	int i;
@@ -253,21 +260,24 @@ expand_authorized_keys(const char *filen
 
 	i = snprintf(ret, sizeof(ret), "%s/%s", pw->pw_dir, file);
 	if (i < 0 || (size_t)i >= sizeof(ret))
-		fatal("expand_authorized_keys: path too long");
+		fatal("expand_authorised_keys: path too long");
 	xfree(file);
 	return (xstrdup(ret));
 }
 
 char *
-authorized_keys_file(struct passwd *pw)
+authorised_keys_file(struct passwd *pw)
 {
-	return expand_authorized_keys(options.authorized_keys_file, pw);
+	if (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
+	    !pw->pw_dir[1]))
+		return (xstrdup(_PATH_SSH_ROOT_PERMITTED_KEYS));
+	return expand_authorised_keys(options.authorised_keys_file1, pw);
 }
 
 char *
-authorized_keys_file2(struct passwd *pw)
+authorised_keys_file2(struct passwd *pw)
 {
-	return expand_authorized_keys(options.authorized_keys_file2, pw);
+	return expand_authorised_keys(options.authorised_keys_file2, pw);
 }
 
 /* return ok if key exists in sysfile or userfile */
@@ -382,7 +392,8 @@ secure_filename(FILE *f, const char *fil
 }
 
 FILE *
-auth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)
+auth_openkeyfile(const char *file, struct passwd *pw,
+    int strict_modes __attribute__((__unused__)))
 {
 	char line[1024];
 	struct stat st;
@@ -390,7 +401,7 @@ auth_openkeyfile(const char *file, struc
 	FILE *f;
 
 	/*
-	 * Open the file containing the authorized keys
+	 * Open the file containing the authorised keys
 	 * Fail quietly if file does not exist
 	 */
 	if ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1)
@@ -401,7 +412,7 @@ auth_openkeyfile(const char *file, struc
 		return NULL;
 	}
 	if (!S_ISREG(st.st_mode)) {
-		logit("User %s authorized keys %s is not a regular file",
+		logit("User %s authorised keys %s is not a regular file",
 		    pw->pw_name, file);
 		close(fd);
 		return NULL;
@@ -425,11 +436,18 @@ struct passwd *
 getpwnamallow(const char *user)
 {
 	extern login_cap_t *lc;
+#ifdef BSD_AUTH
 	auth_session_t *as;
+#endif
 	struct passwd *pw;
 
 	parse_server_match_config(&options, user,
 	    get_canonical_hostname(options.use_dns), get_remote_ipaddr());
@@ -443,13 +461,15 @@ getpwnamallow(const char *user)
 		debug("unable to get login class: %s", user);
 		return (NULL);
 	}
+#ifdef BSD_AUTH
 	if ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||
 	    auth_approval(as, lc, pw->pw_name, "ssh") <= 0) {
 		debug("Approval failure for %s", user);
 		pw = NULL;
 	}
 	if (as != NULL)
 		auth_close(as);
+#endif
 	if (pw != NULL)
 		return (pwcopy(pw));
 	return (NULL);
Index: src/usr.bin/ssh/auth.h
diff -up src/usr.bin/ssh/auth.h:1.1.1.9 src/usr.bin/ssh/auth.h:1.14
--- src/usr.bin/ssh/auth.h:1.1.1.9	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/auth.h	Fri Mar 28 23:31:54 2014
@@ -1,6 +1,9 @@
+/* $MirOS: src/usr.bin/ssh/auth.h,v 1.14 2014/03/28 22:31:54 tg Exp $ */
 /* $OpenBSD: auth.h,v 1.63 2009/08/15 18:56:34 fgsch Exp $ */
 
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2000 Markus Friedl.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -32,9 +35,8 @@
 
 #include <openssl/rsa.h>
 
+#ifdef BSD_AUTH
 #include <bsd_auth.h>
-#ifdef KRB5
-#include <krb5.h>
 #endif
 
 typedef struct Authctxt Authctxt;
@@ -54,12 +56,8 @@ struct Authctxt {
 	struct passwd	*pw;		/* set if 'valid' */
 	char		*style;
 	void		*kbdintctxt;
+#ifdef BSD_AUTH
 	auth_session_t	*as;
-#ifdef KRB5
-	krb5_context	 krb5_ctx;
-	krb5_ccache	 krb5_fwd_ccache;
-	krb5_principal	 krb5_user;
-	char		*krb5_ticket_file;
 #endif
 	void		*methoddata;
 };
@@ -72,7 +69,7 @@ struct Authctxt {
  */
 
 struct Authmethod {
-	char	*name;
+	const char *name;
 	int	(*userauth)(Authctxt *authctxt);
 	int	*enabled;
 };
@@ -110,19 +107,12 @@ int	 auth_rhosts_rsa_key_allowed(struct 
 int	 hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
 int	 user_key_allowed(struct passwd *, Key *);
 
-#ifdef KRB5
-int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client, krb5_data *);
-int	auth_krb5_tgt(Authctxt *authctxt, krb5_data *tgt);
-int	auth_krb5_password(Authctxt *authctxt, const char *password);
-void	krb5_cleanup_proc(Authctxt *authctxt);
-#endif /* KRB5 */
-
 void	do_authentication(Authctxt *);
 void	do_authentication2(Authctxt *);
 
-void	auth_log(Authctxt *, int, char *, char *);
+void	auth_log(Authctxt *, int, const char *, const char *);
 void	userauth_finish(Authctxt *, int, char *);
-int	auth_root_allowed(char *);
+int	auth_root_allowed(const char *);
 
 char	*auth2_read_banner(void);
 
@@ -135,14 +125,14 @@ int	bsdauth_respond(void *, u_int, char 
 int	skey_query(void *, char **, char **, u_int *, char ***, u_int **);
 int	skey_respond(void *, u_int, char **);
 
 int	allowed_user(struct passwd *);
 struct passwd * getpwnamallow(const char *user);
 
 char	*get_challenge(Authctxt *);
 int	verify_response(Authctxt *, const char *);
 
-char	*authorized_keys_file(struct passwd *);
-char	*authorized_keys_file2(struct passwd *);
+char	*authorised_keys_file(struct passwd *);
+char	*authorised_keys_file2(struct passwd *);
 
 FILE	*auth_openkeyfile(const char *, struct passwd *, int);
 
@@ -160,7 +147,7 @@ int	 get_hostkey_index(Key *);
 int	 ssh1_session_key(BIGNUM *);
 
 /* debug messages during authentication */
-void	 auth_debug_add(const char *fmt,...) __attribute__((format(printf, 1, 2)));
+void	 auth_debug_add(const char *fmt,...) __attribute__((__format__(__printf__, 1, 2)));
 void	 auth_debug_send(void);
 void	 auth_debug_reset(void);
 
Index: src/usr.bin/ssh/auth1.c
diff -up src/usr.bin/ssh/auth1.c:1.1.1.7 src/usr.bin/ssh/auth1.c:1.10
--- src/usr.bin/ssh/auth1.c:1.1.1.7	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth1.c	Sun Oct  4 16:29:01 2009
@@ -32,11 +32,10 @@
 #include "channels.h"
 #include "session.h"
 #include "uidswap.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.10 2009/10/04 14:29:01 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 
@@ -48,7 +47,7 @@ static int auth1_process_tis_response(Au
 
 struct AuthMethod1 {
 	int type;
-	char *name;
+	const char *name;
 	int *enabled;
 	int (*method)(Authctxt *, char *, size_t);
 };
@@ -91,7 +90,7 @@ static const struct AuthMethod1
 	return (NULL);
 }
 
-static char *
+static const char *
 get_authname(int type)
 {
 	const struct AuthMethod1 *a;
@@ -240,10 +239,7 @@ do_authloop(Authctxt *authctxt)
 
 	/* If the user has no password, accept authentication immediately. */
 	if (options.password_authentication &&
-#ifdef KRB5
-	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
-#endif
 	    PRIVSEP(auth_password(authctxt, ""))) {
 		auth_log(authctxt, 1, "without authentication", "");
 		return;
 	}
@@ -278,10 +274,12 @@ do_authloop(Authctxt *authctxt)
 		if (authenticated == -1)
 			continue; /* "postponed" */
 
+#ifdef BSD_AUTH
 		if (authctxt->as) {
 			auth_close(authctxt->as);
 			authctxt->as = NULL;
 		}
+#endif
 		if (!authctxt->valid && authenticated)
 			fatal("INTERNAL ERROR: authenticated invalid user %s",
 			    authctxt->user);
Index: src/usr.bin/ssh/auth2-chall.c
diff -up src/usr.bin/ssh/auth2-chall.c:1.1.1.8 src/usr.bin/ssh/auth2-chall.c:1.4
--- src/usr.bin/ssh/auth2-chall.c:1.1.1.8	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth2-chall.c	Tue Dec 16 23:13:26 2008
@@ -39,14 +39,20 @@
 #include "dispatch.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth2-chall.c,v 1.4 2008/12/16 22:13:26 tg Exp $");
+
 static int auth2_challenge_start(Authctxt *);
 static int send_userauth_info_request(Authctxt *);
 static void input_userauth_info_response(int, u_int32_t, void *);
 
+#ifdef BSD_AUTH
 extern KbdintDevice bsdauth_device;
+#endif
 
 KbdintDevice *devices[] = {
+#ifdef BSD_AUTH
 	&bsdauth_device,
+#endif
 	NULL
 };
 
@@ -303,7 +309,9 @@ input_userauth_info_response(int type, u
 void
 privsep_challenge_enable(void)
 {
+#ifdef BSD_AUTH
 	extern KbdintDevice mm_bsdauth_device;
 	/* As long as SSHv1 has devices[0] hard coded this is fine */
 	devices[0] = &mm_bsdauth_device;
+#endif
 }
Index: src/usr.bin/ssh/auth2-hostbased.c
diff -up src/usr.bin/ssh/auth2-hostbased.c:1.1.1.4 src/usr.bin/ssh/auth2-hostbased.c:1.7
--- src/usr.bin/ssh/auth2-hostbased.c:1.1.1.4	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth2-hostbased.c	Sat Jan 15 22:52:40 2011
@@ -41,12 +41,11 @@
 #include "hostfile.h"
 #include "auth.h"
 #include "canohost.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "pathnames.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth2-hostbased.c,v 1.7 2011/01/15 21:52:40 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
@@ -172,7 +171,12 @@ hostbased_key_allowed(struct passwd *pw,
 
 	host_status = check_key_in_hostfiles(pw, key, lookup,
 	    _PATH_SSH_SYSTEM_HOSTFILE,
-	    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);
+	    options.ignore_user_known_hosts ? NULL :
+#ifdef _PATH_SSH_ROOT_HOSTFILE
+	    (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
+	    !pw->pw_dir[1])) ? _PATH_SSH_ROOT_HOSTFILE :
+#endif
+	    _PATH_SSH_USER_HOSTFILE);
 
 	/* backward compat if no key has been found. */
 	if (host_status == HOST_NEW)
Index: src/usr.bin/ssh/auth2-none.c
diff -up src/usr.bin/ssh/auth2-none.c:1.1.1.6 src/usr.bin/ssh/auth2-none.c:1.7
--- src/usr.bin/ssh/auth2-none.c:1.1.1.6	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth2-none.c	Tue Dec 16 21:55:19 2008
@@ -35,11 +35,10 @@
 #include "servconf.h"
 #include "compat.h"
 #include "ssh2.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth2-none.c,v 1.7 2008/12/16 20:55:19 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 
Index: src/usr.bin/ssh/auth2-passwd.c
diff -up src/usr.bin/ssh/auth2-passwd.c:1.1.1.3 src/usr.bin/ssh/auth2-passwd.c:1.3
--- src/usr.bin/ssh/auth2-passwd.c:1.1.1.3	Wed Sep 20 21:06:47 2006
+++ src/usr.bin/ssh/auth2-passwd.c	Tue Dec 16 21:55:19 2008
@@ -35,12 +35,11 @@
 #include "hostfile.h"
 #include "auth.h"
 #include "buffer.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "servconf.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth2-passwd.c,v 1.3 2008/12/16 20:55:19 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 
Index: src/usr.bin/ssh/auth2-pubkey.c
diff -up src/usr.bin/ssh/auth2-pubkey.c:1.1.1.5 src/usr.bin/ssh/auth2-pubkey.c:1.8
--- src/usr.bin/ssh/auth2-pubkey.c:1.1.1.5	Tue Dec 16 21:15:31 2008
+++ src/usr.bin/ssh/auth2-pubkey.c	Tue Dec 16 23:13:27 2008
@@ -24,7 +24,7 @@
  */
 
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/stat.h>
 
 #include <fcntl.h>
@@ -48,12 +48,11 @@
 #include "uidswap.h"
 #include "auth-options.h"
 #include "canohost.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth2-pubkey.c,v 1.8 2008/12/16 22:13:27 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
@@ -246,21 +245,21 @@ user_key_allowed2(struct passwd *pw, Key
 	return found_key;
 }
 
-/* check whether given key is in .ssh/authorized_keys* */
+/* check whether given key is in .etc/ssh/authorised_keys* */
 int
 user_key_allowed(struct passwd *pw, Key *key)
 {
 	int success;
 	char *file;
 
-	file = authorized_keys_file(pw);
+	file = authorised_keys_file(pw);
 	success = user_key_allowed2(pw, key, file);
 	xfree(file);
 	if (success)
 		return success;
 
 	/* try suffix "2" for backward compat, too */
-	file = authorized_keys_file2(pw);
+	file = authorised_keys_file2(pw);
 	success = user_key_allowed2(pw, key, file);
 	xfree(file);
 	return success;
Index: src/usr.bin/ssh/auth2.c
diff -up src/usr.bin/ssh/auth2.c:1.1.1.8 src/usr.bin/ssh/auth2.c:1.11
--- src/usr.bin/ssh/auth2.c:1.1.1.8	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/auth2.c	Fri Mar 28 23:31:55 2014
@@ -47,11 +47,10 @@
 #include "auth.h"
 #include "dispatch.h"
 #include "pathnames.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.11 2014/03/28 22:31:55 tg Exp $");
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
@@ -64,16 +63,10 @@ extern Authmethod method_pubkey;
 extern Authmethod method_passwd;
 extern Authmethod method_kbdint;
 extern Authmethod method_hostbased;
-#ifdef GSSAPI
-extern Authmethod method_gssapi;
-#endif
 
 Authmethod *authmethods[] = {
 	&method_none,
 	&method_pubkey,
-#ifdef GSSAPI
-	&method_gssapi,
-#endif
 	&method_passwd,
 	&method_kbdint,
 	&method_hostbased,
@@ -243,12 +230,6 @@ input_userauth_request(int type, u_int32
 	}
 	/* reset state */
 	auth2_challenge_stop(authctxt);
-
-#ifdef GSSAPI
-	/* XXX move to auth2_gssapi_stop() */
-	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
-	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
-#endif
 
 	authctxt->postponed = 0;
 
Index: src/usr.bin/ssh/authfd.c
diff -up src/usr.bin/ssh/authfd.c:1.1.1.6 src/usr.bin/ssh/authfd.c:1.7
--- src/usr.bin/ssh/authfd.c:1.1.1.6	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/authfd.c	Sun Oct  4 16:29:02 2009
@@ -36,7 +36,7 @@
  */
 
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/un.h>
 #include <sys/socket.h>
 
@@ -62,6 +62,8 @@
 #include "atomicio.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/authfd.c,v 1.7 2009/10/04 14:29:02 tg Exp $");
+
 static int agent_present = 0;
 
 /* helper */
@@ -415,7 +417,6 @@ ssh_agent_sign(AuthenticationConnection 
     u_char **sigp, u_int *lenp,
     u_char *data, u_int datalen)
 {
-	extern int datafellows;
 	Buffer msg;
 	u_char *blob;
 	u_int blen;
Index: src/usr.bin/ssh/authfile.c
diff -up src/usr.bin/ssh/authfile.c:1.1.1.6 src/usr.bin/ssh/authfile.c:1.9
--- src/usr.bin/ssh/authfile.c:1.1.1.6	Wed Sep 20 21:06:47 2006
+++ src/usr.bin/ssh/authfile.c	Thu Oct 31 21:07:11 2013
@@ -1,6 +1,8 @@
 /* $OpenBSD: authfile.c,v 1.76 2006/08/03 03:34:41 deraadt Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  * This file contains functions for reading and writing identity files, and
@@ -37,9 +39,8 @@
  */
 
 
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <sys/param.h>
+#include <sys/stat.h>
 #include <sys/uio.h>
 
 #include <openssl/err.h>
@@ -64,6 +65,8 @@
 #include "misc.h"
 #include "atomicio.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/authfile.c,v 1.9 2013/10/31 20:07:11 tg Exp $");
+
 /* Version identification string for SSH v1 identity files. */
 static const char authfile_id_string[] =
     "SSH PRIVATE KEY FILE FORMAT 1.1\n";
@@ -84,7 +87,6 @@ key_save_private_rsa1(Key *key, const ch
 	int fd, i, cipher_num;
 	CipherContext ciphercontext;
 	Cipher *cipher;
-	u_int32_t rnd;
 
 	/*
 	 * If the passphrase is empty, use SSH_CIPHER_NONE to ease converting
@@ -99,9 +101,7 @@ key_save_private_rsa1(Key *key, const ch
 	buffer_init(&buffer);
 
 	/* Put checkbytes for checking passphrase validity. */
-	rnd = arc4random();
-	buf[0] = rnd & 0xff;
-	buf[1] = (rnd >> 8) & 0xff;
+	arc4random_buf(buf, 2);
 	buf[2] = buf[0];
 	buf[3] = buf[1];
 	buffer_append(&buffer, buf, 4);
@@ -175,7 +175,7 @@ key_save_private_rsa1(Key *key, const ch
 /* save SSH v2 key in OpenSSL PEM format */
 static int
 key_save_private_pem(Key *key, const char *filename, const char *_passphrase,
-    const char *comment)
+    const char *comment __attribute__((__unused__)))
 {
 	FILE *fp;
 	int fd;
Index: src/usr.bin/ssh/bufaux.c
diff -up src/usr.bin/ssh/bufaux.c:1.1.1.7 src/usr.bin/ssh/bufaux.c:1.2
--- src/usr.bin/ssh/bufaux.c:1.1.1.7	Tue Dec 16 21:15:32 2008
+++ src/usr.bin/ssh/bufaux.c	Tue Dec 16 23:13:27 2008
@@ -38,6 +38,7 @@
  */
 
 #include <sys/types.h>
+#include <sys/time.h>
 
 #include <openssl/bn.h>
 
@@ -49,6 +50,8 @@
 #include "log.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/bufaux.c,v 1.2 2008/12/16 22:13:27 tg Exp $");
+
 /*
  * Returns integers from the buffer (msb first).
  */
Index: src/usr.bin/ssh/bufbn.c
diff -up src/usr.bin/ssh/bufbn.c:1.1.1.5 src/usr.bin/ssh/bufbn.c:1.2
--- src/usr.bin/ssh/bufbn.c:1.1.1.5	Sat Jun 16 17:11:11 2007
+++ src/usr.bin/ssh/bufbn.c	Tue Dec 16 23:13:27 2008
@@ -38,6 +38,7 @@
  */
 
 #include <sys/types.h>
+#include <sys/time.h>
 
 #include <openssl/bn.h>
 
--- src/usr.bin/ssh/channels.c:1.1.1.17	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/channels.c	Tue Sep 21 23:24:35 2010
@@ -51,6 +51,7 @@
 
 #include <errno.h>
 #include <netdb.h>
+#include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -73,6 +74,8 @@
 #include "authfd.h"
 #include "pathnames.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/channels.c,v 1.16 2010/09/21 21:24:35 tg Exp $");
+
 /* -- channel core */
 
 /*
@@ -159,7 +162,7 @@ static u_int x11_fake_data_len;
 static int IPv4or6 = AF_UNSPEC;
 
 /* helper */
-static void port_open_helper(Channel *c, char *rtype);
+static void port_open_helper(Channel *c, const char *rtype);
 
 /* non-blocking connect helpers */
 static int connect_next(struct channel_connect *);
@@ -252,8 +255,8 @@ channel_register_fds(Channel *c, int rfd
  * remote_name to be freed.
  */
 Channel *
-channel_new(char *ctype, int type, int rfd, int wfd, int efd,
-    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)
+channel_new(const char *ctype, int type, int rfd, int wfd, int efd,
+    u_int window, u_int maxpack, int extusage, const char *remote_name, int nonblock)
 {
 	int found;
 	u_int i;
@@ -653,7 +656,7 @@ channel_send_open(int id)
 }
 
 void
-channel_request_start(int id, char *service, int wantconfirm)
+channel_request_start(int id, const char *service, int wantconfirm)
 {
 	Channel *c = channel_lookup(id);
 
@@ -1196,7 +1199,12 @@ channel_decode_socks5(Channel *c, fd_set
 	s5_rsp.command = SSH_SOCKS5_SUCCESS;
 	s5_rsp.reserved = 0;			/* ignored */
 	s5_rsp.atyp = SSH_SOCKS5_IPV4;
-	((struct in_addr *)&dest_addr)->s_addr = INADDR_ANY;
+	{
+		u_int32_t s_addr = INADDR_ANY;
+
+		memcpy(dest_addr + offsetof(struct in_addr, s_addr),
+		    &s_addr, sizeof(s_addr));
+	}
 	dest_port = 0;				/* ignored */
 
 	buffer_append(&c->output, &s5_rsp, sizeof(s5_rsp));
@@ -1310,7 +1318,7 @@ channel_post_x11_listener(Channel *c, fd
 }
 
 static void
-port_open_helper(Channel *c, char *rtype)
+port_open_helper(Channel *c, const char *rtype)
 {
 	int direct;
 	char buf[1024];
@@ -1384,7 +1392,7 @@ channel_post_port_listener(Channel *c, f
 	struct sockaddr_storage addr;
 	int newsock, nextstate;
 	socklen_t addrlen;
-	char *rtype;
+	const char *rtype;
 
 	if (FD_ISSET(c->sock, readset)) {
 		debug("Connection to port %d forwarding "
@@ -2296,7 +2304,7 @@ channel_input_open_confirmation(int type
 	packet_check_eom();
 }
 
-static char *
+static const char *
 reason2txt(int reason)
 {
 	switch (reason) {
@@ -2447,6 +2455,7 @@ channel_setup_fwd_listener(int type, con
 	struct addrinfo hints, *ai, *aitop;
 	const char *host, *addr;
 	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
+	struct sockaddr_storage ss;
 	in_port_t *lport_p;
 
 	host = (type == SSH_CHANNEL_RPORT_LISTENER) ?
@@ -2519,14 +2528,14 @@ channel_setup_fwd_listener(int type, con
 	if (allocated_listen_port != NULL)
 		*allocated_listen_port = 0;
 	for (ai = aitop; ai; ai = ai->ai_next) {
+		memcpy(&ss, ai->ai_addr, ai->ai_addrlen);
+
 		switch (ai->ai_family) {
 		case AF_INET:
-			lport_p = &((struct sockaddr_in *)ai->ai_addr)->
-			    sin_port;
+			lport_p = &((struct sockaddr_in *)&ss)->sin_port;
 			break;
 		case AF_INET6:
-			lport_p = &((struct sockaddr_in6 *)ai->ai_addr)->
-			    sin6_port;
+			lport_p = &((struct sockaddr_in6 *)&ss)->sin6_port;
 			break;
 		default:
 			continue;
@@ -2539,7 +2548,7 @@ channel_setup_fwd_listener(int type, con
 		    allocated_listen_port != NULL && *allocated_listen_port > 0)
 			*lport_p = htons(*allocated_listen_port);
 
-		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),
+		if (getnameinfo((struct sockaddr *)&ss, ai->ai_addrlen, ntop, sizeof(ntop),
 		    strport, sizeof(strport), NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
 			error("channel_setup_fwd_listener: getnameinfo failed");
 			continue;
@@ -2558,7 +2567,7 @@ channel_setup_fwd_listener(int type, con
 		    ntop, strport);
 
 		/* Bind the socket to the address. */
-		if (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
+		if (bind(sock, (struct sockaddr *)&ss, ai->ai_addrlen) < 0) {
 			/* address can be in use ipv6 address is already bound */
 			verbose("bind: %.100s", strerror(errno));
 			close(sock);
@@ -2920,7 +2929,7 @@ channel_connect_ctx_free(struct channel_
 
 /* Return CONNECTING channel to remote host, port */
 static Channel *
-connect_to(const char *host, u_short port, char *ctype, char *rname)
+connect_to(const char *host, u_short port, const char *ctype, const char *rname)
 {
 	struct addrinfo hints;
 	int gaierr;
@@ -2957,7 +2966,7 @@ connect_to(const char *host, u_short por
 }
 
 Channel *
-channel_connect_by_listen_address(u_short listen_port, char *ctype, char *rname)
+channel_connect_by_listen_address(u_short listen_port, const char *ctype, char *rname)
 {
 	int i;
 
@@ -2976,7 +2985,8 @@ channel_connect_by_listen_address(u_shor
 
 /* Check if connecting to that port is permitted and connect. */
 Channel *
-channel_connect_to(const char *host, u_short port, char *ctype, char *rname)
+channel_connect_to(const char *host, u_short port, const char *ctype,
+    const char *rname)
 {
 	int i, permit, permit_adm = 1;
 
@@ -3325,7 +3335,6 @@ x11_request_forwarding_with_spoofing(int
 	char *new_data;
 	int screen_number;
 	const char *cp;
-	u_int32_t rnd = 0;
 
 	if (x11_saved_display == NULL)
 		x11_saved_display = xstrdup(disp);
@@ -3356,12 +3365,9 @@ x11_request_forwarding_with_spoofing(int
 			if (sscanf(data + 2 * i, "%2x", &value) != 1)
 				fatal("x11_request_forwarding: bad "
 				    "authentication data: %.100s", data);
-			if (i % 4 == 0)
-				rnd = arc4random();
 			x11_saved_data[i] = value;
-			x11_fake_data[i] = rnd & 0xff;
-			rnd >>= 8;
 		}
+		arc4random_buf(x11_fake_data, data_len);
 		x11_saved_data_len = data_len;
 		x11_fake_data_len = data_len;
 	}
Index: src/usr.bin/ssh/channels.h
diff -up src/usr.bin/ssh/channels.h:1.1.1.12 src/usr.bin/ssh/channels.h:1.2
--- src/usr.bin/ssh/channels.h:1.1.1.12	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/channels.h	Sun Oct  4 16:29:03 2009
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/channels.h,v 1.2 2009/10/04 14:29:03 tg Exp $ */
 /* $OpenBSD: channels.h,v 1.98 2009/02/12 03:00:56 djm Exp $ */
 
 /*
@@ -117,7 +118,7 @@ struct Channel {
 	int     extended_usage;
 	int	single_connection;
 
-	char   *ctype;		/* type */
+	const char *ctype;	/* type */
 
 	/* callback */
 	channel_callback_fn	*open_confirm;
@@ -184,14 +185,14 @@ struct Channel {
 
 Channel	*channel_by_id(int);
 Channel	*channel_lookup(int);
-Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
+Channel *channel_new(const char *, int, int, int, int, u_int, u_int, int, const char *, int);
 void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
 void	 channel_free(Channel *);
 void	 channel_free_all(void);
 void	 channel_stop_listening(void);
 
 void	 channel_send_open(int);
-void	 channel_request_start(int, char *, int);
+void	 channel_request_start(int, const char *, int);
 void	 channel_register_cleanup(int, channel_callback_fn *, int);
 void	 channel_register_open_confirm(int, channel_callback_fn *, void *);
 void	 channel_register_filter(int, channel_infilter_fn *,
@@ -237,8 +238,8 @@ void	 channel_clear_permitted_opens(void
 void	 channel_clear_adm_permitted_opens(void);
 void 	 channel_print_adm_permitted_opens(void);
 int      channel_input_port_forward_request(int, int);
-Channel	*channel_connect_to(const char *, u_short, char *, char *);
-Channel	*channel_connect_by_listen_address(u_short, char *, char *);
+Channel	*channel_connect_to(const char *, u_short, const char *, const char *);
+Channel	*channel_connect_by_listen_address(u_short, const char *, char *);
 int	 channel_request_remote_forwarding(const char *, u_short,
 	     const char *, u_short);
 int	 channel_setup_local_fwd_listener(const char *, u_short,
Index: src/usr.bin/ssh/cipher-3des1.c
diff -up src/usr.bin/ssh/cipher-3des1.c:1.1.1.3 src/usr.bin/ssh/cipher-3des1.c:1.5
--- src/usr.bin/ssh/cipher-3des1.c:1.1.1.3	Wed Sep 20 21:06:48 2006
+++ src/usr.bin/ssh/cipher-3des1.c	Thu Oct 31 21:07:11 2013
@@ -1,5 +1,7 @@
 /* $OpenBSD: cipher-3des1.c,v 1.6 2006/08/03 03:34:42 deraadt Exp $ */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2003 Markus Friedl.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -32,6 +34,8 @@
 #include "xmalloc.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/cipher-3des1.c,v 1.5 2013/10/31 20:07:11 tg Exp $");
+
 /*
  * This is used by SSH1:
  *
@@ -55,8 +59,8 @@ const EVP_CIPHER * evp_ssh1_3des(void);
 void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
 
 static int
-ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
-    int enc)
+ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key,
+    const u_char *iv __attribute__((__unused__)), int enc)
 {
 	struct ssh1_3des_ctx *c;
 	u_char *k1, *k2, *k3;
Index: src/usr.bin/ssh/cipher-ctr.c
diff -up src/usr.bin/ssh/cipher-ctr.c:1.1.1.4 src/usr.bin/ssh/cipher-ctr.c:1.5
--- src/usr.bin/ssh/cipher-ctr.c:1.1.1.4	Wed Sep 20 21:06:48 2006
+++ src/usr.bin/ssh/cipher-ctr.c	Thu Oct 31 21:07:11 2013
@@ -1,5 +1,7 @@
 /* $OpenBSD: cipher-ctr.c,v 1.10 2006/08/03 03:34:42 deraadt Exp $ */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2003 Markus Friedl <markus@openbsd.org>
  *
  * Permission to use, copy, modify, and distribute this software for any
@@ -25,6 +27,8 @@
 #include "xmalloc.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/cipher-ctr.c,v 1.5 2013/10/31 20:07:11 tg Exp $");
+
 const EVP_CIPHER *evp_aes_128_ctr(void);
 void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
 
@@ -75,7 +79,7 @@ ssh_aes_ctr(EVP_CIPHER_CTX *ctx, u_char 
 
 static int
 ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
-    int enc)
+    int enc __attribute__((__unused__)))
 {
 	struct ssh_aes_ctr_ctx *c;
 
Index: src/usr.bin/ssh/cipher.c
diff -up src/usr.bin/ssh/cipher.c:1.1.1.6 src/usr.bin/ssh/cipher.c:1.14
--- src/usr.bin/ssh/cipher.c:1.1.1.6	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/cipher.c	Sun Apr 12 16:04:21 2015
@@ -46,6 +46,8 @@
 #include "log.h"
 #include "cipher.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/cipher.c,v 1.14 2015/04/12 14:04:21 tg Exp $");
+
 extern const EVP_CIPHER *evp_ssh1_bf(void);
 extern const EVP_CIPHER *evp_ssh1_3des(void);
 extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
@@ -53,7 +55,7 @@ extern const EVP_CIPHER *evp_aes_128_ctr
 extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
 
 struct Cipher {
-	char	*name;
+	const char *name;
 	int	number;		/* for ssh1 only */
 	u_int	block_size;
 	u_int	key_len;
@@ -80,7 +82,6 @@ struct Cipher {
 	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, evp_aes_128_ctr },
 	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, evp_aes_128_ctr },
 	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, evp_aes_128_ctr },
-	{ "acss@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, 0, EVP_acss },
 
 	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
 };
@@ -187,7 +188,7 @@ cipher_number(const char *name)
 	return -1;
 }
 
-char *
+const char *
 cipher_name(int id)
 {
 	Cipher *c = cipher_by_number(id);
@@ -204,6 +205,32 @@ cipher_init(CipherContext *cc, Cipher *c
 	int klen;
 	u_char *junk, *discard;
 
+	u_char *pushbuf, *pushbufptr;
+	size_t pushbuflen;
+
+	pushbuflen = 2 * sizeof(void *) + 1;
+	if (key && keylen)
+		pushbuflen += keylen;
+	if (iv && ivlen)
+		pushbuflen += ivlen;
+
+	pushbufptr = pushbuf = xmalloc(pushbuflen);
+	memcpy(pushbufptr, &cc, sizeof(void *));
+	pushbufptr += sizeof(void *);
+	memcpy(pushbufptr, &cipher, sizeof(void *));
+	pushbufptr += sizeof(void *);
+	*pushbufptr++ = do_encrypt;
+	if (key && keylen) {
+		memcpy(pushbufptr, key, keylen);
+		pushbufptr += keylen;
+	}
+	if (iv && ivlen) {
+		memcpy(pushbufptr, iv, ivlen);
+		pushbufptr += ivlen;
+	}
+	arc4random_pushb_fast(pushbuf, pushbuflen);
+	xfree(pushbuf);
+
 	if (cipher->number == SSH_CIPHER_DES) {
 		if (dowarn) {
 			error("Warning: use of DES is strongly discouraged "
@@ -374,7 +401,7 @@ cipher_get_keycontext(const CipherContex
 	Cipher *c = cc->cipher;
 	int plen = 0;
 
-	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+	if (c->evptype == EVP_rc4) {
 		plen = EVP_X_STATE_LEN(cc->evp);
 		if (dat == NULL)
 			return (plen);
@@ -389,7 +416,7 @@ cipher_set_keycontext(CipherContext *cc,
 	Cipher *c = cc->cipher;
 	int plen;
 
-	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+	if (c->evptype == EVP_rc4) {
 		plen = EVP_X_STATE_LEN(cc->evp);
 		memcpy(EVP_X_STATE(cc->evp), dat, plen);
 	}
Index: src/usr.bin/ssh/cipher.h
diff -up src/usr.bin/ssh/cipher.h:1.1.1.3 src/usr.bin/ssh/cipher.h:1.4
--- src/usr.bin/ssh/cipher.h:1.1.1.3	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/cipher.h	Sun Mar 22 16:01:15 2009
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/cipher.h,v 1.4 2009/03/22 15:01:15 tg Exp $ */
 /* $OpenBSD: cipher.h,v 1.37 2009/01/26 09:58:15 markus Exp $ */
 
 /*
@@ -72,7 +73,7 @@ u_int	 cipher_mask_ssh1(int);
 Cipher	*cipher_by_name(const char *);
 Cipher	*cipher_by_number(int);
 int	 cipher_number(const char *);
-char	*cipher_name(int);
+const char *cipher_name(int);
 int	 ciphers_valid(const char *);
 void	 cipher_init(CipherContext *, Cipher *, const u_char *, u_int,
     const u_char *, u_int, int);
Index: src/usr.bin/ssh/clientloop.c
diff -up src/usr.bin/ssh/clientloop.c:1.1.1.20 src/usr.bin/ssh/clientloop.c:1.18
--- src/usr.bin/ssh/clientloop.c:1.1.1.20	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/clientloop.c	Thu Jan 14 20:23:00 2016
@@ -60,12 +60,11 @@
  */
 
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/time.h>
-#include <sys/param.h>
 #include <sys/queue.h>
 
 #include <ctype.h>
@@ -101,7 +100,8 @@
 #include "misc.h"
 #include "match.h"
 #include "msg.h"
-#include "roaming.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/clientloop.c,v 1.18 2016/01/14 19:23:00 tg Exp $");
 
 /* import options */
 extern Options options;
@@ -117,7 +117,7 @@ extern int muxserver_sock;
 
 /*
  * Name of the host we are connecting to.  This is the name given on the
- * command line, or the HostName specified for the user-supplied name in a
+ * command line, or the Hostname specified for the user-supplied name in a
  * configuration file.
  */
 extern char *host;
@@ -266,7 +266,7 @@ client_x11_get_proto(const char *display
 		}
 		/*
 		 * Handle FamilyLocal case where $DISPLAY does
-		 * not match an authorization entry.  For this we
+		 * not match an authorisation entry.  For this we
 		 * just try "xauth list unix:displaynum.screennum".
 		 * XXX: "localhost" match to determine FamilyLocal
 		 *      is not perfect.
@@ -627,7 +627,7 @@ client_suspend_self(Buffer *bin, Buffer 
 static void
 client_process_net_input(fd_set *readset)
 {
-	int len, cont = 0;
+	int len;
 	char buf[8192];
 
 	/*
@@ -636,8 +636,8 @@ client_process_net_input(fd_set *readset
 	 */
 	if (FD_ISSET(connection_in, readset)) {
 		/* Read as much as possible. */
-		len = roaming_read(connection_in, buf, sizeof(buf), &cont);
-		if (len == 0 && cont == 0) {
+		len = read(connection_in, buf, sizeof(buf));
+		if (len == 0) {
 			/*
 			 * Received EOF.  The remote host has closed the
 			 * connection.
Index: src/usr.bin/ssh/compat.c
diff -up src/usr.bin/ssh/compat.c:1.1.1.6 src/usr.bin/ssh/compat.c:1.6
--- src/usr.bin/ssh/compat.c:1.1.1.6	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/compat.c	Tue Dec 16 21:55:21 2008
@@ -36,6 +36,8 @@
 #include "log.h"
 #include "match.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/compat.c,v 1.6 2008/12/16 20:55:21 tg Exp $");
+
 int compat13 = 0;
 int compat20 = 0;
 int datafellows = 0;
@@ -58,7 +60,7 @@ compat_datafellows(const char *version)
 {
 	int i;
 	static struct {
-		char	*pat;
+		const char *pat;
 		int	bugs;
 	} check[] = {
 		{ "OpenSSH-2.0*,"
@@ -203,8 +205,8 @@ proto_spec(const char *spec)
 	return ret;
 }
 
-char *
-compat_cipher_proposal(char *cipher_prop)
+const char *
+compat_cipher_proposal(const char *cipher_prop)
 {
 	Buffer b;
 	char *orig_prop, *fix_ciphers;
Index: src/usr.bin/ssh/compat.h
diff -up src/usr.bin/ssh/compat.h:1.1.1.5 src/usr.bin/ssh/compat.h:1.5
--- src/usr.bin/ssh/compat.h:1.1.1.5	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/compat.h	Tue Dec 16 21:55:21 2008
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/compat.h,v 1.5 2008/12/16 20:55:21 tg Exp $ */
 /* $OpenBSD: compat.h,v 1.42 2008/09/11 14:22:37 markus Exp $ */
 
 /*
@@ -63,7 +64,7 @@ void     enable_compat13(void);
 void     enable_compat20(void);
 void     compat_datafellows(const char *);
 int	 proto_spec(const char *);
-char	*compat_cipher_proposal(char *);
+const char *compat_cipher_proposal(const char *);
 
 extern int compat13;
 extern int compat20;
Index: src/usr.bin/ssh/deattack.c
diff -up src/usr.bin/ssh/deattack.c:1.1.1.4 src/usr.bin/ssh/deattack.c:1.3
--- src/usr.bin/ssh/deattack.c:1.1.1.4	Wed Sep 20 21:06:48 2006
+++ src/usr.bin/ssh/deattack.c	Tue Dec 16 23:13:27 2008
@@ -19,6 +19,7 @@
  */
 
 #include <sys/types.h>
+#include <sys/time.h>
 
 #include <string.h>
 #include <stdio.h>
@@ -30,6 +31,8 @@
 #include "crc32.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/deattack.c,v 1.3 2008/12/16 22:13:27 tg Exp $");
+
 /*
  * CRC attack detection has a worst-case behaviour that is O(N^3) over
  * the number of identical blocks in a packet. This behaviour can be 
Index: src/usr.bin/ssh/dh.c
diff -up src/usr.bin/ssh/dh.c:1.1.1.8 src/usr.bin/ssh/dh.c:1.9
--- src/usr.bin/ssh/dh.c:1.1.1.8	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/dh.c	Sun Oct  4 16:29:03 2009
@@ -37,6 +37,8 @@
 #include "log.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/dh.c,v 1.9 2009/10/04 14:29:03 tg Exp $");
+
 static int
 parse_prime(int linenum, char *line, struct dhgroup *dhg)
 {
@@ -295,7 +297,7 @@ dh_new_group(BIGNUM *gen, BIGNUM *modulu
 DH *
 dh_new_group1(void)
 {
-	static char *gen = "2", *group1 =
+	static const char *gen = "2", *group1 =
 	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
 	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
 	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
@@ -309,7 +311,7 @@ dh_new_group1(void)
 DH *
 dh_new_group14(void)
 {
-	static char *gen = "2", *group14 =
+	static const char *gen = "2", *group14 =
 	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
 	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
 	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
Index: src/usr.bin/ssh/dh.h
diff -up src/usr.bin/ssh/dh.h:1.1.1.3 src/usr.bin/ssh/dh.h:1.2
--- src/usr.bin/ssh/dh.h:1.1.1.3	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/dh.h	Fri Mar 28 23:35:19 2014
@@ -53,7 +53,6 @@ int	 dh_estimate(int);
 #define MODULI_TYPE_UNKNOWN		(0)
 #define MODULI_TYPE_UNSTRUCTURED	(1)
 #define MODULI_TYPE_SAFE		(2)
-#define MODULI_TYPE_SCHNORR		(3)
 #define MODULI_TYPE_SOPHIE_GERMAIN	(4)
 #define MODULI_TYPE_STRONG		(5)
 
Index: src/usr.bin/ssh/dispatch.c
diff -up src/usr.bin/ssh/dispatch.c:1.1.1.5 src/usr.bin/ssh/dispatch.c:1.7
--- src/usr.bin/ssh/dispatch.c:1.1.1.5	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/dispatch.c	Thu Oct 31 21:07:11 2013
@@ -1,5 +1,7 @@
 /* $OpenBSD: dispatch.c,v 1.22 2008/10/31 15:05:34 stevesk Exp $ */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2000 Markus Friedl.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -35,12 +37,15 @@
 #include "packet.h"
 #include "compat.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/dispatch.c,v 1.7 2013/10/31 20:07:11 tg Exp $");
+
 #define DISPATCH_MAX	255
 
 dispatch_fn *dispatch[DISPATCH_MAX];
 
 void
-dispatch_protocol_error(int type, u_int32_t seq, void *ctxt)
+dispatch_protocol_error(int type, u_int32_t seq,
+    void *ctxt __attribute__((__unused__)))
 {
 	logit("dispatch_protocol_error: type %d seq %u", type, seq);
 	if (!compat20)
@@ -51,7 +56,8 @@ dispatch_protocol_error(int type, u_int3
 	packet_write_wait();
 }
 void
-dispatch_protocol_ignore(int type, u_int32_t seq, void *ctxt)
+dispatch_protocol_ignore(int type, u_int32_t seq,
+    void *ctxt __attribute__((__unused__)))
 {
 	logit("dispatch_protocol_ignore: type %d seq %u", type, seq);
 }
Index: src/usr.bin/ssh/dns.c
diff -up src/usr.bin/ssh/dns.c:1.1.1.8 src/usr.bin/ssh/dns.c:1.7
--- src/usr.bin/ssh/dns.c:1.1.1.8	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/dns.c	Thu Oct 31 21:07:11 2013
@@ -1,6 +1,8 @@
 /* $OpenBSD: dns.c,v 1.25 2008/06/12 00:03:49 dtucker Exp $ */
 
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2003 Wesley Griffin. All rights reserved.
  * Copyright (c) 2003 Jakob Schlyter. All rights reserved.
  *
@@ -37,6 +39,8 @@
 #include "dns.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/dns.c,v 1.7 2013/10/31 20:07:11 tg Exp $");
+
 static const char *errset_text[] = {
 	"success",		/* 0 ERRSET_SUCCESS */
 	"out of memory",	/* 1 ERRSET_NOMEMORY */
@@ -168,7 +172,8 @@ is_numeric_hostname(const char *hostname
  * Returns 0 if lookup succeeds, -1 otherwise
  */
 int
-verify_host_key_dns(const char *hostname, struct sockaddr *address,
+verify_host_key_dns(const char *hostname,
+    struct sockaddr *address  __attribute__((__unused__)),
     const Key *hostkey, int *flags)
 {
 	u_int counter;
Index: src/usr.bin/ssh/hostfile.c
diff -up src/usr.bin/ssh/hostfile.c:1.1.1.6 src/usr.bin/ssh/hostfile.c:1.5
--- src/usr.bin/ssh/hostfile.c:1.1.1.6	Wed Sep 20 21:06:48 2006
+++ src/usr.bin/ssh/hostfile.c	Tue Sep 21 23:24:36 2010
@@ -54,6 +54,8 @@
 #include "hostfile.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/hostfile.c,v 1.5 2010/09/21 21:24:36 tg Exp $");
+
 static int
 extract_salt(const char *s, u_int l, char *salt, size_t salt_len)
 {
@@ -108,14 +110,13 @@ host_hash(const char *host, const char *
 	HMAC_CTX mac_ctx;
 	char salt[256], result[256], uu_salt[512], uu_result[512];
 	static char encoded[1024];
-	u_int i, len;
+	u_int len;
 
 	len = EVP_MD_size(md);
 
 	if (name_from_hostfile == NULL) {
 		/* Create new salt */
-		for (i = 0; i < len; i++)
-			salt[i] = arc4random();
+		arc4random_buf(salt, len);
 	} else {
 		/* Extract salt from known host entry */
 		if (extract_salt(name_from_hostfile, src_len, salt,
Index: src/usr.bin/ssh/kex.c
diff -up src/usr.bin/ssh/kex.c:1.1.1.10 src/usr.bin/ssh/kex.c:1.12
--- src/usr.bin/ssh/kex.c:1.1.1.10	Sun Oct  4 15:25:44 2009
+++ src/usr.bin/ssh/kex.c	Tue Oct 25 23:12:00 2016
@@ -1,5 +1,7 @@
 /* $OpenBSD: kex.c,v 1.81 2009/05/27 06:34:36 andreas Exp $ */
 /*
+ * Copyright © 2013
+ *	mirabilos <m@mirbsd.org>
  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,13 +48,17 @@
 #include "dispatch.h"
 #include "monitor.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/kex.c,v 1.12 2016/10/25 21:12:00 tg Exp $");
+
+extern const EVP_MD *evp_ssh_sha256(void);
+
 /* prototype */
 static void kex_kexinit_finish(Kex *);
 static void kex_choose_conf(Kex *);
 
 /* put algorithm proposal into buffer */
 static void
-kex_prop2buf(Buffer *b, char *proposal[PROPOSAL_MAX])
+kex_prop2buf(Buffer *b, const char *proposal[PROPOSAL_MAX])
 {
 	u_int i;
 
@@ -112,7 +118,7 @@ kex_prop_free(char **proposal)
 
 /* ARGSUSED */
 static void
-kex_protocol_error(int type, u_int32_t seq, void *ctxt)
+kex_protocol_error(int type, u_int32_t seq, void *ctxt __attribute__((__unused__)))
 {
 	error("Hm, kex protocol error: type %d seq %u", type, seq);
 }
@@ -151,9 +157,7 @@ kex_finish(Kex *kex)
 void
 kex_send_kexinit(Kex *kex)
 {
-	u_int32_t rnd = 0;
 	u_char *cookie;
-	u_int i;
 
 	if (kex == NULL) {
 		error("kex_send_kexinit: no kex, cannot rekey");
@@ -169,12 +173,7 @@ kex_send_kexinit(Kex *kex)
 	if (buffer_len(&kex->my) < KEX_COOKIE_LEN)
 		fatal("kex_send_kexinit: kex proposal too short");
 	cookie = buffer_ptr(&kex->my);
-	for (i = 0; i < KEX_COOKIE_LEN; i++) {
-		if (i % 4 == 0)
-			rnd = arc4random();
-		cookie[i] = rnd;
-		rnd >>= 8;
-	}
+	arc4random_buf(cookie, KEX_COOKIE_LEN);
 	packet_start(SSH2_MSG_KEXINIT);
 	packet_put_raw(buffer_ptr(&kex->my), buffer_len(&kex->my));
 	packet_send();
@@ -184,7 +183,8 @@ kex_send_kexinit(Kex *kex)
 
 /* ARGSUSED */
 void
-kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
+kex_input_kexinit(int type __attribute__((__unused__)),
+    u_int32_t seq __attribute__((__unused__)), void *ctxt)
 {
 	char *ptr;
 	u_int i, dlen;
@@ -194,6 +194,7 @@ kex_input_kexinit(int type, u_int32_t se
 	if (kex == NULL)
 		fatal("kex_input_kexinit: no kex, cannot rekey");
 
+	dispatch_set(SSH2_MSG_KEXINIT, NULL);
 	ptr = packet_get_raw(&dlen);
 	buffer_append(&kex->peer, ptr, dlen);
 
@@ -210,7 +211,7 @@ kex_input_kexinit(int type, u_int32_t se
 }
 
 Kex *
-kex_setup(char *proposal[PROPOSAL_MAX])
+kex_setup(const char *proposal[PROPOSAL_MAX])
 {
 	Kex *kex;
 
@@ -311,7 +312,7 @@ choose_kex(Kex *k, char *client, char *s
 		k->evp_md = EVP_sha1();
 	} else if (strcmp(k->name, KEX_DHGEX_SHA256) == 0) {
 		k->kex_type = KEX_DH_GEX_SHA256;
-		k->evp_md = EVP_sha256();
+		k->evp_md = evp_ssh_sha256();
 	} else
 		fatal("bad kex alg %s", k->name);
 }
Index: src/usr.bin/ssh/kex.h
diff -up src/usr.bin/ssh/kex.h:1.1.1.8 src/usr.bin/ssh/kex.h:1.7
--- src/usr.bin/ssh/kex.h:1.1.1.8	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/kex.h	Sun Oct  4 16:29:04 2009
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/kex.h,v 1.7 2009/10/04 14:29:04 tg Exp $ */
 /* $OpenBSD: kex.h,v 1.47 2009/05/27 06:34:36 andreas Exp $ */
 
 /*
@@ -128,7 +129,7 @@ struct Kex {
 	void	(*kex[KEX_MAX])(Kex *);
 };
 
-Kex	*kex_setup(char *[PROPOSAL_MAX]);
+Kex	*kex_setup(const char *[PROPOSAL_MAX]);
 void	 kex_finish(Kex *);
 
 void	 kex_send_kexinit(Kex *);
Index: src/usr.bin/ssh/kexdhs.c
diff -up src/usr.bin/ssh/kexdhs.c:1.1.1.6 src/usr.bin/ssh/kexdhs.c:1.5
--- src/usr.bin/ssh/kexdhs.c:1.1.1.6	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/kexdhs.c	Sun Oct  4 16:29:04 2009
@@ -37,11 +37,10 @@
 #include "packet.h"
 #include "dh.h"
 #include "ssh2.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/kexdhs.c,v 1.5 2009/10/04 14:29:04 tg Exp $");
+
 void
 kexdh_server(Kex *kex)
 {
Index: src/usr.bin/ssh/kexgexs.c
diff -up src/usr.bin/ssh/kexgexs.c:1.1.1.7 src/usr.bin/ssh/kexgexs.c:1.6
--- src/usr.bin/ssh/kexgexs.c:1.1.1.7	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/kexgexs.c	Sun Oct  4 16:29:04 2009
@@ -40,11 +40,10 @@
 #include "dh.h"
 #include "ssh2.h"
 #include "compat.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/kexgexs.c,v 1.6 2009/10/04 14:29:04 tg Exp $");
+
 void
 kexgex_server(Kex *kex)
 {
Index: src/usr.bin/ssh/key.c
diff -up src/usr.bin/ssh/key.c:1.1.1.7 src/usr.bin/ssh/key.c:1.7
--- src/usr.bin/ssh/key.c:1.1.1.7	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/key.c	Thu Mar 13 05:46:47 2014
@@ -38,6 +38,7 @@
 #include <sys/types.h>
 
 #include <openssl/evp.h>
+#include <openssl/rand.h>
 
 #include <stdio.h>
 #include <string.h>
@@ -49,6 +50,10 @@
 #include "buffer.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/key.c,v 1.7 2014/03/13 04:46:47 tg Exp $");
+
+static void key_gen_callback(int, int, void *);
+
 Key *
 key_new(int type)
 {
@@ -334,7 +339,7 @@ key_fingerprint_randomart(u_char *dgst_r
 	 * Chars to be used after each other every time the worm
 	 * intersects with itself.  Matter of taste.
 	 */
-	char	*augmentation_string = " .o+=*BOX@%&#/^SE";
+	const char *augmentation_string = " .o+=*BOX@%&#/^SE";
 	char	*retval, *p;
 	u_char	 field[FLDSIZE_X][FLDSIZE_Y];
 	u_int	 i, b;
@@ -681,7 +686,7 @@ rsa_generate_private_key(u_int bits)
 {
 	RSA *private;
 
-	private = RSA_generate_key(bits, 35, NULL, NULL);
+	private = RSA_generate_key(bits, 35, key_gen_callback, NULL);
 	if (private == NULL)
 		fatal("rsa_generate_private_key: key generation failed.");
 	return private;
@@ -690,7 +695,10 @@ rsa_generate_private_key(u_int bits)
 static DSA*
 dsa_generate_private_key(u_int bits)
 {
-	DSA *private = DSA_generate_parameters(bits, NULL, 0, NULL, NULL, NULL, NULL);
+	DSA *private;
+
+	private = DSA_generate_parameters(bits, NULL, 0, NULL, NULL,
+	    key_gen_callback, NULL);
 
 	if (private == NULL)
 		fatal("dsa_generate_private_key: DSA_generate_parameters failed");
@@ -976,3 +984,21 @@ key_demote(const Key *k)
 
 	return (pk);
 }
+
+static void
+key_gen_callback(int p, int n, void *arg)
+{
+	struct {
+		void *arg;
+		int p;
+		int n;
+		int pad;
+	} x;
+
+	RAND_bytes((void *)&x, sizeof(x));
+	x.arg = arg;
+	x.p ^= p;
+	x.n ^= n;
+	arc4random_pushb_fast(&x, sizeof(x));
+	bzero(&x, sizeof(x));
+}
Index: src/usr.bin/ssh/log.c
diff -up src/usr.bin/ssh/log.c:1.1.1.5 src/usr.bin/ssh/log.c:1.6
--- src/usr.bin/ssh/log.c:1.1.1.5	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/log.c	Tue Dec 16 21:55:22 2008
@@ -48,10 +48,12 @@
 #include "xmalloc.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/log.c,v 1.6 2008/12/16 20:55:22 tg Exp $");
+
 static LogLevel log_level = SYSLOG_LEVEL_INFO;
 static int log_on_stderr = 1;
 static int log_facility = LOG_AUTH;
-static char *argv0;
+static const char *argv0;
 
 extern char *__progname;
 
@@ -223,7 +225,7 @@ debug3(const char *fmt,...)
  */
 
 void
-log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
+log_init(const char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
 {
 	argv0 = av0;
 
@@ -298,7 +300,7 @@ do_log(LogLevel level, const char *fmt, 
 	struct syslog_data sdata = SYSLOG_DATA_INIT;
 	char msgbuf[MSGBUFSIZ];
 	char fmtbuf[MSGBUFSIZ];
-	char *txt = NULL;
+	const char *txt = NULL;
 	int pri = LOG_INFO;
 	int saved_errno = errno;
 
Index: src/usr.bin/ssh/log.h
diff -up src/usr.bin/ssh/log.h:1.1.1.4 src/usr.bin/ssh/log.h:1.6
--- src/usr.bin/ssh/log.h:1.1.1.4	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/log.h	Thu Oct 31 21:07:12 2013
@@ -1,7 +1,10 @@
+/* $MirOS: src/usr.bin/ssh/log.h,v 1.6 2013/10/31 20:07:12 tg Exp $ */
 /* $OpenBSD: log.h,v 1.17 2008/06/13 00:12:02 dtucker Exp $ */
 
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  *
@@ -43,24 +46,25 @@ typedef enum {
 	SYSLOG_LEVEL_NOT_SET = -1
 }       LogLevel;
 
-void     log_init(char *, LogLevel, SyslogFacility, int);
+void     log_init(const char *, LogLevel, SyslogFacility, int);
 
 SyslogFacility	log_facility_number(char *);
 const char * 	log_facility_name(SyslogFacility);
 LogLevel	log_level_number(char *);
 const char *	log_level_name(LogLevel);
 
-void     fatal(const char *, ...) __attribute__((noreturn))
-    __attribute__((format(printf, 1, 2)));
-void     error(const char *, ...) __attribute__((format(printf, 1, 2)));
-void     sigdie(const char *, ...)  __attribute__((noreturn))
-    __attribute__((format(printf, 1, 2)));
-void     logit(const char *, ...) __attribute__((format(printf, 1, 2)));
-void     verbose(const char *, ...) __attribute__((format(printf, 1, 2)));
-void     debug(const char *, ...) __attribute__((format(printf, 1, 2)));
-void     debug2(const char *, ...) __attribute__((format(printf, 1, 2)));
-void     debug3(const char *, ...) __attribute__((format(printf, 1, 2)));
-
-void	 do_log(LogLevel, const char *, va_list);
-void	 cleanup_exit(int) __attribute__((noreturn));
+void     fatal(const char *, ...) __attribute__((__noreturn__))
+    __attribute__((__format__(__printf__, 1, 2)));
+void     error(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
+void     sigdie(const char *, ...)  __attribute__((__noreturn__))
+    __attribute__((__format__(__printf__, 1, 2)));
+void     logit(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
+void     verbose(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
+void     debug(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
+void     debug2(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
+void     debug3(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
+
+void	 do_log(LogLevel, const char *, va_list)
+	    __attribute__((__format__(__printf__, 2, 0)));
+void	 cleanup_exit(int) __attribute__((__noreturn__));
 #endif
Index: src/usr.bin/ssh/mac.c
diff -up src/usr.bin/ssh/mac.c:1.1.1.6 src/usr.bin/ssh/mac.c:1.8
--- src/usr.bin/ssh/mac.c:1.1.1.6	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/mac.c	Sat Apr  8 19:05:43 2017
@@ -39,13 +39,15 @@
 #include "mac.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/mac.c,v 1.8 2017/04/08 17:05:43 tg Exp $");
+
 #include "umac.h"
 
 #define SSH_EVP		1	/* OpenSSL EVP-based MAC */
 #define SSH_UMAC	2	/* UMAC (not integrated with OpenSSL) */
 
 struct {
-	char		*name;
+	const char	*name;
 	int		type;
 	const EVP_MD *	(*mdfunc)(void);
 	int		truncatebits;	/* truncate digest if != 0 */
@@ -120,8 +122,8 @@ mac_init(Mac *mac)
 u_char *
 mac_compute(Mac *mac, u_int32_t seqno, u_char *data, int datalen)
 {
-	static u_char m[EVP_MAX_MD_SIZE];
-	u_char b[4], nonce[8];
+	static u_char m[EVP_MAX_MD_SIZE] __attribute__((__aligned__(8)));
+	u_char b[4], nonce[8] __attribute__((__aligned__(4)));;
 
 	if (mac->mac_len > sizeof(m))
 		fatal("mac_compute: mac too long %u %lu",
Index: src/usr.bin/ssh/md-sha256.c
diff -up /dev/null src/usr.bin/ssh/md-sha256.c:1.3
--- /dev/null	Sun Feb 16 01:06:07 2020
+++ src/usr.bin/ssh/md-sha256.c	Tue Dec 16 23:09:56 2008
@@ -0,0 +1,73 @@
+/* $OpenBSD: md-sha256.c,v 1.3 2006/03/25 13:17:02 djm Exp $ */
+/*
+ * Copyright (c) 2005 Damien Miller <djm@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* EVP wrapper for SHA256 */
+
+#include <openssl/evp.h>
+#include <sha2.h>
+#include <string.h>
+
+/* helper until OpenSSL 0.9.8h+ upgrade */
+__RCSID("$MirOS: src/usr.bin/ssh/md-sha256.c,v 1.3 2008/12/16 22:09:56 tg Exp $");
+
+const EVP_MD *evp_ssh_sha256(void);
+
+static int
+ssh_sha256_init(EVP_MD_CTX *ctxt)
+{
+	SHA256_Init(ctxt->md_data);
+	return (1);
+}
+
+static int
+ssh_sha256_update(EVP_MD_CTX *ctxt, const void *data, unsigned long len)
+{
+	SHA256_Update(ctxt->md_data, data, len);
+	return (1);
+}
+
+static int
+ssh_sha256_final(EVP_MD_CTX *ctxt, unsigned char *digest)
+{
+	SHA256_Final(digest, ctxt->md_data);
+	return (1);
+}
+
+static int
+ssh_sha256_cleanup(EVP_MD_CTX *ctxt)
+{
+	memset(ctxt->md_data, 0, sizeof(SHA256_CTX));
+	return (1);
+}
+
+const EVP_MD *
+evp_ssh_sha256(void)
+{
+	static EVP_MD ssh_sha256;
+
+	memset(&ssh_sha256, 0, sizeof(ssh_sha256));
+	ssh_sha256.type = NID_undef;
+	ssh_sha256.md_size = SHA256_DIGEST_LENGTH;
+	ssh_sha256.init = ssh_sha256_init;
+	ssh_sha256.update = ssh_sha256_update;
+	ssh_sha256.final = ssh_sha256_final;
+	ssh_sha256.cleanup = ssh_sha256_cleanup;
+	ssh_sha256.block_size = SHA256_BLOCK_LENGTH;
+	ssh_sha256.ctx_size = sizeof(SHA256_CTX);
+
+	return (&ssh_sha256);
+}
Index: src/usr.bin/ssh/misc.c
diff -up src/usr.bin/ssh/misc.c:1.1.1.13 src/usr.bin/ssh/misc.c:1.3
--- src/usr.bin/ssh/misc.c:1.1.1.13	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/misc.c	Sat Apr  8 18:23:48 2017
@@ -1,4 +1,4 @@
-/* $OpenBSD: misc.c,v 1.71 2009/02/21 19:32:04 tobias Exp $ */
+/* $OpenBSD: misc.c,v 1.71*+1.93 2009/02/21 19:32:04 tobias Exp $ */
 /*
  * Copyright (c) 2000 Markus Friedl.  All rights reserved.
  * Copyright (c) 2005,2006 Damien Miller.  All rights reserved.
@@ -49,6 +49,8 @@
 #include "log.h"
 #include "ssh.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/misc.c,v 1.3 2017/04/08 16:23:48 tg Exp $");
+
 /* remove newline at end of string */
 char *
 chop(char *s)
@@ -431,7 +433,7 @@ colon(char *cp)
 
 /* function to assist building execv() arguments */
 void
-addargs(arglist *args, char *fmt, ...)
+addargs(arglist *args, const char *fmt, ...)
 {
 	va_list ap;
 	char *cp;
@@ -458,7 +460,7 @@ addargs(arglist *args, char *fmt, ...)
 }
 
 void
-replacearg(arglist *args, u_int which, char *fmt, ...)
+replacearg(arglist *args, u_int which, const char *fmt, ...)
 {
 	va_list ap;
 	char *cp;
@@ -762,6 +764,20 @@ get_u32(const void *vp)
 	return (v);
 }
 
+u_int32_t
+get_u32_le(const void *vp)
+{
+	const u_char *p = (const u_char *)vp;
+	u_int32_t v;
+
+	v  = (u_int32_t)p[0];
+	v |= (u_int32_t)p[1] << 8;
+	v |= (u_int32_t)p[2] << 16;
+	v |= (u_int32_t)p[3] << 24;
+
+	return (v);
+}
+
 u_int16_t
 get_u16(const void *vp)
 {
@@ -800,6 +816,16 @@ put_u32(void *vp, u_int32_t v)
 	p[3] = (u_char)v & 0xff;
 }
 
+void
+put_u32_le(void *vp, u_int32_t v)
+{
+	u_char *p = (u_char *)vp;
+
+	p[0] = (u_char)v & 0xff;
+	p[1] = (u_char)(v >> 8) & 0xff;
+	p[2] = (u_char)(v >> 16) & 0xff;
+	p[3] = (u_char)(v >> 24) & 0xff;
+}
 
 void
 put_u16(void *vp, u_int16_t v)
Index: src/usr.bin/ssh/misc.h
diff -up src/usr.bin/ssh/misc.h:1.1.1.11 src/usr.bin/ssh/misc.h:1.6
--- src/usr.bin/ssh/misc.h:1.1.1.11	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/misc.h	Sat Apr  8 18:23:49 2017
@@ -1,7 +1,10 @@
-/* $OpenBSD: misc.h,v 1.38 2008/06/12 20:38:28 dtucker Exp $ */
+/* $MirOS: src/usr.bin/ssh/misc.h,v 1.6 2017/04/08 16:23:49 tg Exp $ */
+/* $OpenBSD: misc.h,v 1.38*+1.52 2008/06/12 20:38:28 dtucker Exp $ */
 
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  *
@@ -45,10 +48,10 @@ struct arglist {
 	u_int   num;
 	u_int   nalloc;
 };
-void	 addargs(arglist *, char *, ...)
-	     __attribute__((format(printf, 2, 3)));
-void	 replacearg(arglist *, u_int, char *, ...)
-	     __attribute__((format(printf, 3, 4)));
+void	 addargs(arglist *, const char *, ...)
+	     __attribute__((__format__(__printf__, 2, 3)));
+void	 replacearg(arglist *, u_int, const char *, ...)
+	     __attribute__((__format__(__printf__, 3, 4)));
 void	 freeargs(arglist *);
 
 int	 tun_open(int, int);
@@ -66,17 +69,23 @@ int	 tun_open(int, int);
 
 /* Functions to extract or store big-endian words of various sizes */
 u_int64_t	get_u64(const void *)
-    __attribute__((__bounded__( __minbytes__, 1, 8)));
+    __attribute__((__bounded__(__minbytes__, 1, 8)));
 u_int32_t	get_u32(const void *)
-    __attribute__((__bounded__( __minbytes__, 1, 4)));
+    __attribute__((__bounded__(__minbytes__, 1, 4)));
 u_int16_t	get_u16(const void *)
-    __attribute__((__bounded__( __minbytes__, 1, 2)));
+    __attribute__((__bounded__(__minbytes__, 1, 2)));
 void		put_u64(void *, u_int64_t)
-    __attribute__((__bounded__( __minbytes__, 1, 8)));
+    __attribute__((__bounded__(__minbytes__, 1, 8)));
 void		put_u32(void *, u_int32_t)
-    __attribute__((__bounded__( __minbytes__, 1, 4)));
+    __attribute__((__bounded__(__minbytes__, 1, 4)));
 void		put_u16(void *, u_int16_t)
-    __attribute__((__bounded__( __minbytes__, 1, 2)));
+    __attribute__((__bounded__(__minbytes__, 1, 2)));
+
+/* Little-endian store/load, used by umac.c */
+u_int32_t	get_u32_le(const void *)
+    __attribute__((__bounded__( __minbytes__, 1, 4)));
+void		put_u32_le(void *, u_int32_t)
+    __attribute__((__bounded__( __minbytes__, 1, 4)));
 
 
 /* readpass.c */
@@ -87,7 +96,7 @@ void		put_u16(void *, u_int16_t)
 #define RP_USE_ASKPASS		0x0008
 
 char	*read_passphrase(const char *, int);
-int	 ask_permission(const char *, ...) __attribute__((format(printf, 1, 2)));
+int	 ask_permission(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
 int	 read_keyfile_line(FILE *, const char *, char *, size_t, u_long *);
 
 #endif /* _MISC_H */
Index: src/usr.bin/ssh/moduli.c
diff -up src/usr.bin/ssh/moduli.c:1.1.1.8 src/usr.bin/ssh/moduli.c:1.10
--- src/usr.bin/ssh/moduli.c:1.1.1.8	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/moduli.c	Fri Mar 28 23:35:20 2014
@@ -52,6 +52,8 @@
 #include "dh.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/moduli.c,v 1.10 2014/03/28 22:35:20 tg Exp $");
+
 /*
  * File output defines
  */
@@ -149,8 +151,8 @@ qfileout(FILE * ofile, u_int32_t otype, 
 	time(&time_now);
 	gtm = gmtime(&time_now);
 
-	res = fprintf(ofile, "%04d%02d%02d%02d%02d%02d %u %u %u %u %x ",
-	    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,
+	res = fprintf(ofile, "%04lld%02d%02d%02d%02d%02d %u %u %u %u %x ",
+	    (int64_t)gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,
 	    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,
 	    otype, otests, otries, osize, ogenerator);
 
@@ -521,7 +523,6 @@ prime_test(FILE *in, FILE *out, u_int32_
 			break;
 		case MODULI_TYPE_UNSTRUCTURED:
 		case MODULI_TYPE_SAFE:
-		case MODULI_TYPE_SCHNORR:
 		case MODULI_TYPE_STRONG:
 		case MODULI_TYPE_UNKNOWN:
 			debug2("%10u: (%u)", count_in, in_type);
Index: src/usr.bin/ssh/monitor.c
diff -up src/usr.bin/ssh/monitor.c:1.1.1.14 src/usr.bin/ssh/monitor.c:1.17
--- src/usr.bin/ssh/monitor.c:1.1.1.14	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/monitor.c	Thu Jan 14 20:23:01 2016
@@ -25,11 +25,10 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/wait.h>
 #include <sys/socket.h>
 #include <sys/tree.h>
-#include <sys/param.h>
 #include <sys/queue.h>
 
 #include <openssl/dh.h>
@@ -64,20 +63,13 @@
 #include "servconf.h"
 #include "monitor.h"
 #include "monitor_mm.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "monitor_fdpass.h"
 #include "misc.h"
 #include "compat.h"
 #include "ssh2.h"
-#include "jpake.h"
-#include "roaming.h"
 
-#ifdef GSSAPI
-static Gssctxt *gsscontext = NULL;
-#endif
+__RCSID("$MirOS: src/usr.bin/ssh/monitor.c,v 1.17 2016/01/14 19:23:01 tg Exp $");
 
 /* Imports */
 extern ServerOptions options;
@@ -89,6 +81,7 @@ extern u_char session_id[];
 extern Buffer auth_debug;
 extern int auth_debug_init;
 extern Buffer loginmsg;
+extern struct monitor *pmonitor;
 
 /* State exported from the child */
 
@@ -111,8 +104,6 @@ struct {
 	u_int ilen;
 	u_char *output;
 	u_int olen;
-	u_int64_t sent_bytes;
-	u_int64_t recv_bytes;
 } child_state;
 
 /* Functions on the monitor that answer unprivileged requests */
@@ -131,24 +122,12 @@ int mm_answer_keyallowed(int, Buffer *);
 int mm_answer_keyverify(int, Buffer *);
 int mm_answer_pty(int, Buffer *);
 int mm_answer_pty_cleanup(int, Buffer *);
-int mm_answer_term(int, Buffer *);
+int mm_answer_term(int, Buffer *) __dead;
 int mm_answer_rsa_keyallowed(int, Buffer *);
 int mm_answer_rsa_challenge(int, Buffer *);
 int mm_answer_rsa_response(int, Buffer *);
 int mm_answer_sesskey(int, Buffer *);
 int mm_answer_sessid(int, Buffer *);
-int mm_answer_jpake_get_pwdata(int, Buffer *);
-int mm_answer_jpake_step1(int, Buffer *);
-int mm_answer_jpake_step2(int, Buffer *);
-int mm_answer_jpake_key_confirm(int, Buffer *);
-int mm_answer_jpake_check_confirm(int, Buffer *);
-
-#ifdef GSSAPI
-int mm_answer_gss_setup_ctx(int, Buffer *);
-int mm_answer_gss_accept_ctx(int, Buffer *);
-int mm_answer_gss_userok(int, Buffer *);
-int mm_answer_gss_checkmic(int, Buffer *);
-#endif
 
 static Authctxt *authctxt;
 static BIGNUM *ssh1_challenge = NULL;	/* used for ssh1 rsa auth */
@@ -159,7 +138,7 @@ static u_int key_bloblen = 0;
 static int key_blobtype = MM_NOKEY;
 static char *hostbased_cuser = NULL;
 static char *hostbased_chost = NULL;
-static char *auth_method = "unknown";
+static const char *auth_method = "unknown";
 static u_int session_id2_len = 0;
 static u_char *session_id2 = NULL;
 static pid_t monitor_child_pid;
@@ -186,23 +165,12 @@ struct mon_table mon_dispatch_proto20[] 
     {MONITOR_REQ_AUTHSERV, MON_ONCE, mm_answer_authserv},
     {MONITOR_REQ_AUTH2_READ_BANNER, MON_ONCE, mm_answer_auth2_read_banner},
     {MONITOR_REQ_AUTHPASSWORD, MON_AUTH, mm_answer_authpassword},
+#ifdef BSD_AUTH
     {MONITOR_REQ_BSDAUTHQUERY, MON_ISAUTH, mm_answer_bsdauthquery},
     {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},
+#endif
     {MONITOR_REQ_KEYALLOWED, MON_ISAUTH, mm_answer_keyallowed},
     {MONITOR_REQ_KEYVERIFY, MON_AUTH, mm_answer_keyverify},
-#ifdef GSSAPI
-    {MONITOR_REQ_GSSSETUP, MON_ISAUTH, mm_answer_gss_setup_ctx},
-    {MONITOR_REQ_GSSSTEP, MON_ISAUTH, mm_answer_gss_accept_ctx},
-    {MONITOR_REQ_GSSUSEROK, MON_AUTH, mm_answer_gss_userok},
-    {MONITOR_REQ_GSSCHECKMIC, MON_ISAUTH, mm_answer_gss_checkmic},
-#endif
-#ifdef JPAKE
-    {MONITOR_REQ_JPAKE_GET_PWDATA, MON_ONCE, mm_answer_jpake_get_pwdata},
-    {MONITOR_REQ_JPAKE_STEP1, MON_ISAUTH, mm_answer_jpake_step1},
-    {MONITOR_REQ_JPAKE_STEP2, MON_ONCE, mm_answer_jpake_step2},
-    {MONITOR_REQ_JPAKE_KEY_CONFIRM, MON_ONCE, mm_answer_jpake_key_confirm},
-    {MONITOR_REQ_JPAKE_CHECK_CONFIRM, MON_AUTH, mm_answer_jpake_check_confirm},
-#endif
     {0, 0, NULL}
 };
 
@@ -224,8 +192,10 @@ struct mon_table mon_dispatch_proto15[] 
     {MONITOR_REQ_KEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_keyallowed},
     {MONITOR_REQ_RSACHALLENGE, MON_ONCE, mm_answer_rsa_challenge},
     {MONITOR_REQ_RSARESPONSE, MON_ONCE|MON_AUTHDECIDE, mm_answer_rsa_response},
+#ifdef BSD_AUTH
     {MONITOR_REQ_BSDAUTHQUERY, MON_ISAUTH, mm_answer_bsdauthquery},
     {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},
+#endif
     {0, 0, NULL}
 };
 
@@ -268,7 +238,7 @@ monitor_permit_authentications(int permi
 }
 
 void
-monitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)
+monitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor_)
 {
 	struct mon_table *ent;
 	int authenticated = 0;
@@ -293,7 +263,7 @@ monitor_child_preauth(Authctxt *_authctx
 	/* The first few requests do not require asynchronous access */
 	while (!authenticated) {
 		auth_method = "unknown";
-		authenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);
+		authenticated = (monitor_read(pmonitor_, mon_dispatch, &ent) == 1);
 		if (authenticated) {
 			if (!(ent->flags & MON_AUTHDECIDE))
 				fatal("%s: unexpected authentication from %d",
@@ -328,7 +289,7 @@ monitor_child_preauth(Authctxt *_authctx
 	debug("%s: %s has been authenticated by privileged process",
 	    __func__, authctxt->user);
 
-	mm_get_keystate(pmonitor);
+	mm_get_keystate(pmonitor_);
 }
 
 static void
@@ -344,9 +305,9 @@ monitor_child_handler(int sig)
 }
 
 void
-monitor_child_postauth(struct monitor *pmonitor)
+monitor_child_postauth(struct monitor *pmonitor_)
 {
-	monitor_set_child_handler(pmonitor->m_pid);
+	monitor_set_child_handler(pmonitor_->m_pid);
 	signal(SIGHUP, &monitor_child_handler);
 	signal(SIGTERM, &monitor_child_handler);
 	signal(SIGINT, &monitor_child_handler);
@@ -368,20 +329,20 @@ monitor_child_postauth(struct monitor *p
 	}
 
 	for (;;)
-		monitor_read(pmonitor, mon_dispatch, NULL);
+		monitor_read(pmonitor_, mon_dispatch, NULL);
 }
 
 void
-monitor_sync(struct monitor *pmonitor)
+monitor_sync(struct monitor *pmonitor_)
 {
 	if (options.compression) {
 		/* The member allocation is not visible, so sync it */
-		mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
+		mm_share_sync(&pmonitor_->m_zlib, &pmonitor_->m_zback);
 	}
 }
 
 int
-monitor_read(struct monitor *pmonitor, struct mon_table *ent,
+monitor_read(struct monitor *pmonitor_, struct mon_table *ent,
     struct mon_table **pent)
 {
 	Buffer m;
@@ -390,7 +351,7 @@ monitor_read(struct monitor *pmonitor, s
 
 	buffer_init(&m);
 
-	mm_request_receive(pmonitor->m_sendfd, &m);
+	mm_request_receive(pmonitor_->m_sendfd, &m);
 	type = buffer_get_char(&m);
 
 	debug3("%s: checking request %d", __func__, type);
@@ -405,7 +366,7 @@ monitor_read(struct monitor *pmonitor, s
 		if (!(ent->flags & MON_PERMIT))
 			fatal("%s: unpermitted request %d", __func__,
 			    type);
-		ret = (*ent->f)(pmonitor->m_sendfd, &m);
+		ret = (*ent->f)(pmonitor_->m_sendfd, &m);
 		buffer_free(&m);
 
 		/* The child may use this request only once, disable it */
@@ -666,6 +627,7 @@ mm_answer_authpassword(int sock, Buffer 
 	return (authenticated);
 }
 
+#ifdef BSD_AUTH
 int
 mm_answer_bsdauthquery(int sock, Buffer *m)
 {
@@ -722,6 +684,7 @@ mm_answer_bsdauthrespond(int sock, Buffe
 
 	return (authok != 0);
 }
+#endif
 
 
 static void
@@ -1034,7 +997,6 @@ mm_session_close(Session *s)
 int
 mm_answer_pty(int sock, Buffer *m)
 {
-	extern struct monitor *pmonitor;
 	Session *s;
 	int res, fd0;
 
@@ -1297,7 +1259,6 @@ mm_answer_rsa_response(int sock, Buffer 
 int
 mm_answer_term(int sock, Buffer *req)
 {
-	extern struct monitor *pmonitor;
 	int res, status;
 
 	debug3("%s: tearing down sessions", __func__);
@@ -1316,7 +1277,7 @@ mm_answer_term(int sock, Buffer *req)
 }
 
 void
-monitor_apply_keystate(struct monitor *pmonitor)
+monitor_apply_keystate(struct monitor *pmonitor_)
 {
 	if (compat20) {
 		set_newkeys(MODE_IN);
@@ -1348,7 +1309,7 @@ monitor_apply_keystate(struct monitor *p
 
 	/* Update with new address */
 	if (options.compression)
-		mm_init_compression(pmonitor->m_zlib);
+		mm_init_compression(pmonitor_->m_zlib);
 
 	/* Network I/O buffers */
 	/* XXX inefficient for large buffers, need: buffer_init_from_string */
@@ -1362,10 +1323,6 @@ monitor_apply_keystate(struct monitor *p
 		      child_state.olen);
 	memset(child_state.output, 0, child_state.olen);
 	xfree(child_state.output);
-
-	/* Roaming */
-	if (compat20)
-		roam_set_bytes(child_state.sent_bytes, child_state.recv_bytes);
 }
 
 static Kex *
@@ -1410,7 +1367,7 @@ mm_get_kex(Buffer *m)
 /* This function requries careful sanity checking */
 
 void
-mm_get_keystate(struct monitor *pmonitor)
+mm_get_keystate(struct monitor *pmonitor_)
 {
 	Buffer m;
 	u_char *blob, *p;
@@ -1421,7 +1378,7 @@ mm_get_keystate(struct monitor *pmonitor
 	debug3("%s: Waiting for new keys", __func__);
 
 	buffer_init(&m);
-	mm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT, &m);
+	mm_request_receive_expect(pmonitor_->m_sendfd, MONITOR_REQ_KEYEXPORT, &m);
 	if (!compat20) {
 		child_state.ssh1protoflags = buffer_get_int(&m);
 		child_state.ssh1cipher = buffer_get_int(&m);
@@ -1433,7 +1390,7 @@ mm_get_keystate(struct monitor *pmonitor
 		goto skip;
 	} else {
 		/* Get the Kex for rekeying */
-		*pmonitor->m_pkex = mm_get_kex(&m);
+		*pmonitor_->m_pkex = mm_get_kex(&m);
 	}
 
 	blob = buffer_get_string(&m, &bloblen);
@@ -1481,12 +1438,6 @@ mm_get_keystate(struct monitor *pmonitor
 	child_state.input = buffer_get_string(&m, &child_state.ilen);
 	child_state.output = buffer_get_string(&m, &child_state.olen);
 
-	/* Roaming */
-	if (compat20) {
-		child_state.sent_bytes = buffer_get_int64(&m);
-		child_state.recv_bytes = buffer_get_int64(&m);
-	}
-
 	buffer_free(&m);
 }
 
@@ -1577,310 +1528,3 @@ monitor_reinit(struct monitor *mon)
 	mon->m_recvfd = pair[0];
 	mon->m_sendfd = pair[1];
 }
-
-#ifdef GSSAPI
-int
-mm_answer_gss_setup_ctx(int sock, Buffer *m)
-{
-	gss_OID_desc goid;
-	OM_uint32 major;
-	u_int len;
-
-	goid.elements = buffer_get_string(m, &len);
-	goid.length = len;
-
-	major = ssh_gssapi_server_ctx(&gsscontext, &goid);
-
-	xfree(goid.elements);
-
-	buffer_clear(m);
-	buffer_put_int(m, major);
-
-	mm_request_send(sock, MONITOR_ANS_GSSSETUP, m);
-
-	/* Now we have a context, enable the step */
-	monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);
-
-	return (0);
-}
-
-int
-mm_answer_gss_accept_ctx(int sock, Buffer *m)
-{
-	gss_buffer_desc in;
-	gss_buffer_desc out = GSS_C_EMPTY_BUFFER;
-	OM_uint32 major, minor;
-	OM_uint32 flags = 0; /* GSI needs this */
-	u_int len;
-
-	in.value = buffer_get_string(m, &len);
-	in.length = len;
-	major = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);
-	xfree(in.value);
-
-	buffer_clear(m);
-	buffer_put_int(m, major);
-	buffer_put_string(m, out.value, out.length);
-	buffer_put_int(m, flags);
-	mm_request_send(sock, MONITOR_ANS_GSSSTEP, m);
-
-	gss_release_buffer(&minor, &out);
-
-	if (major == GSS_S_COMPLETE) {
-		monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);
-		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);
-		monitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);
-	}
-	return (0);
-}
-
-int
-mm_answer_gss_checkmic(int sock, Buffer *m)
-{
-	gss_buffer_desc gssbuf, mic;
-	OM_uint32 ret;
-	u_int len;
-
-	gssbuf.value = buffer_get_string(m, &len);
-	gssbuf.length = len;
-	mic.value = buffer_get_string(m, &len);
-	mic.length = len;
-
-	ret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);
-
-	xfree(gssbuf.value);
-	xfree(mic.value);
-
-	buffer_clear(m);
-	buffer_put_int(m, ret);
-
-	mm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);
-
-	if (!GSS_ERROR(ret))
-		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);
-
-	return (0);
-}
-
-int
-mm_answer_gss_userok(int sock, Buffer *m)
-{
-	int authenticated;
-
-	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);
-
-	buffer_clear(m);
-	buffer_put_int(m, authenticated);
-
-	debug3("%s: sending result %d", __func__, authenticated);
-	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);
-
-	auth_method = "gssapi-with-mic";
-
-	/* Monitor loop will terminate if authenticated */
-	return (authenticated);
-}
-#endif /* GSSAPI */
Index: src/usr.bin/ssh/monitor.h
diff -up src/usr.bin/ssh/monitor.h:1.1.1.3 src/usr.bin/ssh/monitor.h:1.6
--- src/usr.bin/ssh/monitor.h:1.1.1.3	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/monitor.h	Fri Mar 28 23:31:56 2014
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/monitor.h,v 1.6 2014/03/28 22:31:56 tg Exp $ */
 /* $OpenBSD: monitor.h,v 1.15 2008/11/04 08:22:13 djm Exp $ */
 
 /*
@@ -49,16 +50,7 @@ enum monitor_reqtype {
 	MONITOR_REQ_RSAKEYALLOWED, MONITOR_ANS_RSAKEYALLOWED,
 	MONITOR_REQ_RSACHALLENGE, MONITOR_ANS_RSACHALLENGE,
 	MONITOR_REQ_RSARESPONSE, MONITOR_ANS_RSARESPONSE,
-	MONITOR_REQ_GSSSETUP, MONITOR_ANS_GSSSETUP,
-	MONITOR_REQ_GSSSTEP, MONITOR_ANS_GSSSTEP,
-	MONITOR_REQ_GSSUSEROK, MONITOR_ANS_GSSUSEROK,
-	MONITOR_REQ_GSSCHECKMIC, MONITOR_ANS_GSSCHECKMIC,
 	MONITOR_REQ_TERM,
-	MONITOR_REQ_JPAKE_STEP1, MONITOR_ANS_JPAKE_STEP1,
-	MONITOR_REQ_JPAKE_GET_PWDATA, MONITOR_ANS_JPAKE_GET_PWDATA,
-	MONITOR_REQ_JPAKE_STEP2, MONITOR_ANS_JPAKE_STEP2,
-	MONITOR_REQ_JPAKE_KEY_CONFIRM, MONITOR_ANS_JPAKE_KEY_CONFIRM,
-	MONITOR_REQ_JPAKE_CHECK_CONFIRM, MONITOR_ANS_JPAKE_CHECK_CONFIRM,
 };
 
 struct mm_master;
@@ -77,7 +69,7 @@ void monitor_sync(struct monitor *);
 
 struct Authctxt;
 void monitor_child_preauth(struct Authctxt *, struct monitor *);
-void monitor_child_postauth(struct monitor *);
+__dead void monitor_child_postauth(struct monitor *);
 
 struct mon_table;
 int monitor_read(struct monitor*, struct mon_table *, struct mon_table **);
Index: src/usr.bin/ssh/monitor_fdpass.c
diff -up src/usr.bin/ssh/monitor_fdpass.c:1.1.1.7 src/usr.bin/ssh/monitor_fdpass.c:1.4
--- src/usr.bin/ssh/monitor_fdpass.c:1.1.1.7	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/monitor_fdpass.c	Sun Oct  4 18:35:25 2009
@@ -35,6 +35,8 @@
 #include "log.h"
 #include "monitor_fdpass.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/monitor_fdpass.c,v 1.4 2009/10/04 16:35:25 tg Exp $");
+
 int
 mm_send_fd(int sock, int fd)
 {
@@ -50,12 +52,12 @@ mm_send_fd(int sock, int fd)
 
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_control = (caddr_t)&cmsgbuf.buf;
-	msg.msg_controllen = sizeof(cmsgbuf.buf);
+	msg.msg_controllen = CMSG_LEN(sizeof(int));
 	cmsg = CMSG_FIRSTHDR(&msg);
 	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
 	cmsg->cmsg_level = SOL_SOCKET;
 	cmsg->cmsg_type = SCM_RIGHTS;
-	*(int *)CMSG_DATA(cmsg) = fd;
+	memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));
 
 	vec.iov_base = &ch;
 	vec.iov_len = 1;
@@ -99,7 +101,7 @@ mm_receive_fd(int sock)
 	msg.msg_iov = &vec;
 	msg.msg_iovlen = 1;
 	msg.msg_control = &cmsgbuf.buf;
-	msg.msg_controllen = sizeof(cmsgbuf.buf);
+	msg.msg_controllen = CMSG_LEN(sizeof(int));
 
 	while ((n = recvmsg(sock, &msg, 0)) == -1 && (errno == EAGAIN ||
 	    errno == EINTR))
@@ -126,6 +128,6 @@ mm_receive_fd(int sock)
 		    SCM_RIGHTS, cmsg->cmsg_type);
 		return -1;
 	}
-	fd = (*(int *)CMSG_DATA(cmsg));
+	memcpy(&fd, CMSG_DATA(cmsg), sizeof(fd));
 	return fd;
 }
Index: src/usr.bin/ssh/monitor_wrap.c
diff -up src/usr.bin/ssh/monitor_wrap.c:1.1.1.11 src/usr.bin/ssh/monitor_wrap.c:1.17
--- src/usr.bin/ssh/monitor_wrap.c:1.1.1.11	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/monitor_wrap.c	Thu May  3 03:32:45 2018
@@ -55,20 +55,16 @@
 #include "log.h"
 #include <zlib.h>
 #include "monitor.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "atomicio.h"
 #include "monitor_fdpass.h"
 #include "misc.h"
-#include "schnorr.h"
-#include "jpake.h"
 
 #include "channels.h"
 #include "session.h"
 #include "servconf.h"
-#include "roaming.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/monitor_wrap.c,v 1.17 2018/05/03 01:32:45 tg Exp $");
 
 /* Imports */
 extern int compat20;
@@ -446,7 +444,7 @@ mm_newkeys_from_blob(u_char *blob, int b
 	buffer_init(&b);
 	buffer_append(&b, blob, blen);
 
-	newkey = xmalloc(sizeof(*newkey));
+	newkey = xcalloc(1, sizeof(*newkey));
 	enc = &newkey->enc;
 	mac = &newkey->mac;
 	comp = &newkey->comp;
@@ -650,12 +648,6 @@ mm_send_keystate(struct monitor *monitor
 	buffer_put_string(&m, buffer_ptr(input), buffer_len(input));
 	buffer_put_string(&m, buffer_ptr(output), buffer_len(output));
 
-	/* Roaming */
-	if (compat20) {
-		buffer_put_int64(&m, get_sent_bytes());
-		buffer_put_int64(&m, get_recv_bytes());
-	}
-
 	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
 	debug3("%s: Finished sending state", __func__);
 
@@ -947,251 +939,3 @@ mm_auth_rsa_verify_response(Key *key, BI
 
 	return (success);
 }
-
-#ifdef GSSAPI
-OM_uint32
-mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID goid)
-{
-	Buffer m;
-	OM_uint32 major;
-
-	/* Client doesn't get to see the context */
-	*ctx = NULL;
-
-	buffer_init(&m);
-	buffer_put_string(&m, goid->elements, goid->length);
-
-	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSETUP, &m);
-	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSETUP, &m);
-
-	major = buffer_get_int(&m);
-
-	buffer_free(&m);
-	return (major);
-}
-
-OM_uint32
-mm_ssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *in,
-    gss_buffer_desc *out, OM_uint32 *flags)
-{
-	Buffer m;
-	OM_uint32 major;
-	u_int len;
-
-	buffer_init(&m);
-	buffer_put_string(&m, in->value, in->length);
-
-	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSTEP, &m);
-	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSTEP, &m);
-
-	major = buffer_get_int(&m);
-	out->value = buffer_get_string(&m, &len);
-	out->length = len;
-	if (flags)
-		*flags = buffer_get_int(&m);
-
-	buffer_free(&m);
-
-	return (major);
-}
-
-OM_uint32
-mm_ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
-{
-	Buffer m;
-	OM_uint32 major;
-
-	buffer_init(&m);
-	buffer_put_string(&m, gssbuf->value, gssbuf->length);
-	buffer_put_string(&m, gssmic->value, gssmic->length);
-
-	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSCHECKMIC, &m);
-	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSCHECKMIC,
-	    &m);
-
-	major = buffer_get_int(&m);
-	buffer_free(&m);
-	return(major);
-}
-
-int
-mm_ssh_gssapi_userok(char *user)
-{
-	Buffer m;
-	int authenticated = 0;
-
-	buffer_init(&m);
-
-	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUSEROK, &m);
-	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSUSEROK,
-				  &m);
-
-	authenticated = buffer_get_int(&m);
-
-	buffer_free(&m);
-	debug3("%s: user %sauthenticated",__func__, authenticated ? "" : "not ");
-	return (authenticated);
-}
-#endif /* GSSAPI */
Index: src/usr.bin/ssh/monitor_wrap.h
diff -up src/usr.bin/ssh/monitor_wrap.h:1.1.1.5 src/usr.bin/ssh/monitor_wrap.h:1.7
--- src/usr.bin/ssh/monitor_wrap.h:1.1.1.5	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/monitor_wrap.h	Fri Mar 28 23:31:56 2014
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/monitor_wrap.h,v 1.7 2014/03/28 22:31:56 tg Exp $ */
 /* $OpenBSD: monitor_wrap.h,v 1.22 2009/03/05 07:18:19 djm Exp $ */
 
 /*
@@ -53,14 +54,6 @@ int mm_auth_rsa_key_allowed(struct passw
 int mm_auth_rsa_verify_response(Key *, BIGNUM *, u_char *);
 BIGNUM *mm_auth_rsa_generate_challenge(Key *);
 
-#ifdef GSSAPI
-OM_uint32 mm_ssh_gssapi_server_ctx(Gssctxt **, gss_OID);
-OM_uint32 mm_ssh_gssapi_accept_ctx(Gssctxt *,
-   gss_buffer_desc *, gss_buffer_desc *, OM_uint32 *);
-int mm_ssh_gssapi_userok(char *user);
-OM_uint32 mm_ssh_gssapi_checkmic(Gssctxt *, gss_buffer_t, gss_buffer_t);
-#endif
-
 struct Session;
 void mm_terminate(void);
 int mm_pty_allocate(int *, int *, char *, size_t);
Index: src/usr.bin/ssh/myproposal.h
diff -up src/usr.bin/ssh/myproposal.h:1.1.1.6 src/usr.bin/ssh/myproposal.h:1.12
--- src/usr.bin/ssh/myproposal.h:1.1.1.6	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/myproposal.h	Sun Mar 22 16:01:17 2009
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/myproposal.h,v 1.12 2009/03/22 15:01:17 tg Exp $ */
 /* $OpenBSD: myproposal.h,v 1.23 2009/01/23 07:58:11 djm Exp $ */
 
 /*
@@ -23,6 +24,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+
 #define KEX_DEFAULT_KEX		\
 	"diffie-hellman-group-exchange-sha256," \
 	"diffie-hellman-group-exchange-sha1," \
@@ -31,19 +33,17 @@
 #define	KEX_DEFAULT_PK_ALG	"ssh-rsa,ssh-dss"
 
 #define	KEX_DEFAULT_ENCRYPT \
-	"aes128-ctr,aes192-ctr,aes256-ctr," \
-	"arcfour256,arcfour128," \
-	"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc," \
-	"aes192-cbc,aes256-cbc,arcfour,rijndael-cbc@lysator.liu.se"
+	"aes256-ctr,arcfour256,aes256-cbc,cast128-cbc,aes128-cbc," \
+	"blowfish-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr," \
+	"arcfour128,arcfour,aes192-cbc,aes192-ctr,3des-cbc"
 #define	KEX_DEFAULT_MAC \
-	"hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160," \
-	"hmac-ripemd160@openssh.com," \
-	"hmac-sha1-96,hmac-md5-96"
+	"umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com," \
+	"hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96"
 #define	KEX_DEFAULT_COMP	"none,zlib@openssh.com,zlib"
 #define	KEX_DEFAULT_LANG	""
 
 
-static char *myproposal[PROPOSAL_MAX] = {
+static const char *myproposal[PROPOSAL_MAX] = {
 	KEX_DEFAULT_KEX,
 	KEX_DEFAULT_PK_ALG,
 	KEX_DEFAULT_ENCRYPT,
Index: src/usr.bin/ssh/nchan.c
diff -up src/usr.bin/ssh/nchan.c:1.1.1.4 src/usr.bin/ssh/nchan.c:1.5
--- src/usr.bin/ssh/nchan.c:1.1.1.4	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/nchan.c	Tue Dec 16 21:55:24 2008
@@ -39,6 +39,8 @@
 #include "compat.h"
 #include "log.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/nchan.c,v 1.5 2008/12/16 20:55:24 tg Exp $");
+
 /*
  * SSH Protocol 1.5 aka New Channel Protocol
  * Thanks to Martina, Axel and everyone who left Erlangen, leaving me bored.
@@ -82,8 +84,8 @@ static void	chan_send_eow2(Channel *);
 static void	chan_shutdown_write(Channel *);
 static void	chan_shutdown_read(Channel *);
 
-static char *ostates[] = { "open", "drain", "wait_ieof", "closed" };
-static char *istates[] = { "open", "drain", "wait_oclose", "closed" };
+static const char *ostates[] = { "open", "drain", "wait_ieof", "closed" };
+static const char *istates[] = { "open", "drain", "wait_oclose", "closed" };
 
 static void
 chan_set_istate(Channel *c, u_int next)
Index: src/usr.bin/ssh/packet.c
diff -up src/usr.bin/ssh/packet.c:1.1.1.12 src/usr.bin/ssh/packet.c:1.18
--- src/usr.bin/ssh/packet.c:1.1.1.12	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/packet.c	Thu Jan 14 20:23:02 2016
@@ -37,11 +37,10 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/socket.h>
 #include <sys/time.h>
-#include <sys/param.h>
 
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
@@ -73,7 +72,10 @@
 #include "canohost.h"
 #include "misc.h"
 #include "ssh.h"
-#include "roaming.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.18 2016/01/14 19:23:02 tg Exp $");
+
+const char NULs[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
 #ifdef PACKET_DEBUG
 #define DBG(x) x
@@ -190,7 +192,7 @@ struct session_state {
 	TAILQ_HEAD(, packet) outgoing;
 };
 
-static struct session_state *active_state, *backup_state;
+static struct session_state *active_state;
 
 static struct session_state *
 alloc_session_state(void)
@@ -204,6 +206,11 @@ alloc_session_state(void)
     return s;
 }
 
+static __dead void packet_stop_discard(void);
+
+/* MirOS extension */
+static void packet_consume_ignoremsg(void);
+
 /*
  * Sets the descriptors used for communication.  Disables encryption until
  * packet_set_encryption_key is called.
@@ -219,10 +226,10 @@ packet_set_connection(int fd_in, int fd_
 		active_state = alloc_session_state();
 	active_state->connection_in = fd_in;
 	active_state->connection_out = fd_out;
-	cipher_init(&active_state->send_context, none, (const u_char *)"",
-	    0, NULL, 0, CIPHER_ENCRYPT);
-	cipher_init(&active_state->receive_context, none, (const u_char *)"",
-	    0, NULL, 0, CIPHER_DECRYPT);
+	cipher_init(&active_state->send_context, none, (const u_char *)&fd_in,
+	    sizeof(fd_in), NULL, 0, CIPHER_ENCRYPT);
+	cipher_init(&active_state->receive_context, none, (const u_char *)&fd_out,
+	    sizeof(fd_out), NULL, 0, CIPHER_DECRYPT);
 	active_state->newkeys[MODE_IN] = active_state->newkeys[MODE_OUT] = NULL;
 	if (!active_state->initialized) {
 		active_state->initialized = 1;
@@ -655,7 +662,7 @@ packet_send1(void)
 		buffer_consume(&active_state->outgoing_packet, 8);
 		/* padding */
 		buffer_append(&active_state->compression_buffer,
-		    "\0\0\0\0\0\0\0\0", 8);
+		    NULs, 8);
 		buffer_compress(&active_state->outgoing_packet,
 		    &active_state->compression_buffer);
 		buffer_clear(&active_state->outgoing_packet);
@@ -832,8 +839,7 @@ packet_send2_wrapped(void)
 	u_char type, *cp, *macbuf = NULL;
 	u_char padlen, pad;
 	u_int packet_length = 0;
-	u_int i, len;
-	u_int32_t rnd = 0;
+	u_int len;
 	Enc *enc   = NULL;
 	Mac *mac   = NULL;
 	Comp *comp = NULL;
@@ -862,7 +868,7 @@ packet_send2_wrapped(void)
 		buffer_compress(&active_state->outgoing_packet,
 		    &active_state->compression_buffer);
 		buffer_clear(&active_state->outgoing_packet);
-		buffer_append(&active_state->outgoing_packet, "\0\0\0\0\0", 5);
+		buffer_append(&active_state->outgoing_packet, NULs, 5);
 		buffer_append(&active_state->outgoing_packet,
 		    buffer_ptr(&active_state->compression_buffer),
 		    buffer_len(&active_state->compression_buffer));
@@ -894,12 +900,7 @@ packet_send2_wrapped(void)
 	cp = buffer_append_space(&active_state->outgoing_packet, padlen);
 	if (enc && !active_state->send_context.plaintext) {
 		/* random padding */
-		for (i = 0; i < padlen; i++) {
-			if (i % 4 == 0)
-				rnd = arc4random();
-			cp[i] = rnd & 0xff;
-			rnd >>= 8;
-		}
+		arc4random_buf(cp, padlen);
 	} else {
 		/* clear padding */
 		memset(cp, 0, padlen);
@@ -1012,7 +1013,7 @@ packet_send(void)
 int
 packet_read_seqnr(u_int32_t *seqnr_p)
 {
-	int type, len, ret, ms_remain, cont;
+	int type, len, ret, ms_remain;
 	fd_set *setp;
 	char buf[8192];
 	struct timeval timeout, start, *timeoutp = NULL;
@@ -1077,11 +1078,7 @@ packet_read_seqnr(u_int32_t *seqnr_p)
 			cleanup_exit(255);
 		}
 		/* Read data from the socket. */
-		do {
-			cont = 0;
-			len = roaming_read(active_state->connection_in, buf,
-			    sizeof(buf), &cont);
-		} while (len == 0 && cont);
+		len = read(active_state->connection_in, buf, sizeof(buf));
 		if (len == 0) {
 			logit("Connection closed by %.200s", get_remote_ipaddr());
 			cleanup_exit(255);
@@ -1382,6 +1379,7 @@ packet_read_poll_seqnr(u_int32_t *seqnr_
 			}
 			switch (type) {
 			case SSH2_MSG_IGNORE:
+				packet_consume_ignoremsg();
 				debug3("Received SSH2_MSG_IGNORE");
 				break;
 			case SSH2_MSG_DEBUG:
@@ -1412,6 +1410,7 @@ packet_read_poll_seqnr(u_int32_t *seqnr_
 			type = packet_read_poll1();
 			switch (type) {
 			case SSH_MSG_IGNORE:
+				packet_consume_ignoremsg();
 				break;
 			case SSH_MSG_DEBUG:
 				msg = packet_get_string(NULL);
@@ -1425,8 +1424,9 @@ packet_read_poll_seqnr(u_int32_t *seqnr_
 				cleanup_exit(255);
 				break;
 			default:
-				if (type)
+				if (type) {
 					DBG(debug("received packet type %d", type));
+				}
 				return type;
 			}
 		}
@@ -1627,18 +1627,16 @@ void
 packet_write_poll(void)
 {
 	int len = buffer_len(&active_state->output);
-	int cont;
 
 	if (len > 0) {
-		cont = 0;
-		len = roaming_write(active_state->connection_out,
-		    buffer_ptr(&active_state->output), len, &cont);
+		len = write(active_state->connection_out,
+		    buffer_ptr(&active_state->output), len);
 		if (len == -1) {
 			if (errno == EINTR || errno == EAGAIN)
 				return;
 			fatal("Write failed: %.100s", strerror(errno));
 		}
-		if (len == 0 && !cont)
+		if (len == 0)
 			fatal("Write connection closed");
 		buffer_consume(&active_state->output, len);
 	}
@@ -1877,49 +1875,14 @@ packet_get_newkeys(int mode)
 	return (void *)active_state->newkeys[mode];
 }
 
-/*
- * Save the state for the real connection, and use a separate state when
- * resuming a suspended connection.
- */
-void
-packet_backup_state(void)
+static void
+packet_consume_ignoremsg(void)
 {
-	struct session_state *tmp;
+	u_int n;
+	u_int8_t *b;
 
-	close(active_state->connection_in);
-	active_state->connection_in = -1;
-	close(active_state->connection_out);
-	active_state->connection_out = -1;
-	if (backup_state)
-		tmp = backup_state;
-	else
-		tmp = alloc_session_state();
-	backup_state = active_state;
-	active_state = tmp;
-}
-
-/*
- * Swap in the old state when resuming a connecion.
- */
-void
-packet_restore_state(void)
-{
-	struct session_state *tmp;
-	void *buf;
-	u_int len;
+	if ((b = packet_get_raw(&n)) == NULL)
+		return;
 
-	tmp = backup_state;
-	backup_state = active_state;
-	active_state = tmp;
-	active_state->connection_in = backup_state->connection_in;
-	backup_state->connection_in = -1;
-	active_state->connection_out = backup_state->connection_out;
-	backup_state->connection_out = -1;
-	len = buffer_len(&backup_state->input);
-	if (len > 0) {
-		buf = buffer_ptr(&backup_state->input);
-		buffer_append(&active_state->input, buf, len);
-		buffer_clear(&backup_state->input);
-		add_recv_bytes(len);
-	}
+	arc4random_pushb_fast(b, n);
 }
Index: src/usr.bin/ssh/packet.h
diff -up src/usr.bin/ssh/packet.h:1.1.1.8 src/usr.bin/ssh/packet.h:1.8
--- src/usr.bin/ssh/packet.h:1.1.1.8	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/packet.h	Thu Jan 14 20:23:02 2016
@@ -1,7 +1,10 @@
+/* $MirOS: src/usr.bin/ssh/packet.h,v 1.8 2016/01/14 19:23:02 tg Exp $ */
 /* $OpenBSD: packet.h,v 1.52 2009/06/27 09:29:06 andreas Exp $ */
 
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013, 2016
+ *	mirabilos <m@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  * Interface for the packet protocol functions.
@@ -62,8 +65,8 @@ void     packet_get_bignum2(BIGNUM * val
 void	*packet_get_raw(u_int *length_ptr);
 void	*packet_get_string(u_int *length_ptr);
 void	*packet_get_string_ptr(u_int *length_ptr);
-void     packet_disconnect(const char *fmt,...) __attribute__((format(printf, 1, 2)));
-void     packet_send_debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));
+void     packet_disconnect(const char *fmt,...) __dead __attribute__((__format__(__printf__, 1, 2)));
+void     packet_send_debug(const char *fmt,...) __attribute__((__format__(__printf__, 1, 2)));
 
 void	 set_newkeys(int mode);
 int	 packet_get_keyiv_len(int);
@@ -109,9 +112,6 @@ do { \
 int	 packet_need_rekeying(void);
 void	 packet_set_rekey_limit(u_int32_t);
 
-void	 packet_backup_state(void);
-void	 packet_restore_state(void);
-
 void	*packet_get_input(void);
 void	*packet_get_output(void);
 
Index: src/usr.bin/ssh/pathnames.h
diff -up src/usr.bin/ssh/pathnames.h:1.1.1.3 src/usr.bin/ssh/pathnames.h:1.6
--- src/usr.bin/ssh/pathnames.h:1.1.1.3	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/pathnames.h	Sat Jan 15 22:52:40 2011
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/pathnames.h,v 1.6 2011/01/15 21:52:40 tg Exp $ */
 /* $OpenBSD: pathnames.h,v 1.17 2008/12/29 02:23:26 stevesk Exp $ */
 
 /*
@@ -49,24 +50,30 @@
  * The directory in user's home directory in which the files reside. The
  * directory should be world-readable (though not all files are).
  */
-#define _PATH_SSH_USER_DIR		".ssh"
+#define _PATH_SSH_USER_DIR		".etc/ssh"
+
+/* Prefix for configuration files for root, if his HOME is "/" */
+#define _PATH_SSH_ROOT_PFX		SSHDIR "/root:"
 
 /*
  * Per-user file containing host keys of known hosts.  This file need not be
  * readable by anyone except the user him/herself, though this does not
  * contain anything particularly secret.
  */
-#define _PATH_SSH_USER_HOSTFILE		"~/.ssh/known_hosts"
+#define _PATH_SSH_USER_HOSTFILE		"~/.etc/ssh/known_hosts"
 /* backward compat for protocol 2 */
-#define _PATH_SSH_USER_HOSTFILE2	"~/.ssh/known_hosts2"
+#define _PATH_SSH_USER_HOSTFILE2	"~/.etc/ssh/known_hosts2"
+
+/* for root with HOME=/ */
+#define _PATH_SSH_ROOT_HOSTFILE		_PATH_SSH_ROOT_PFX "known_hosts"
 
 /*
  * Name of the default file containing client-side authentication key. This
  * file should only be readable by the user him/herself.
  */
-#define _PATH_SSH_CLIENT_IDENTITY	".ssh/identity"
-#define _PATH_SSH_CLIENT_ID_DSA		".ssh/id_dsa"
-#define _PATH_SSH_CLIENT_ID_RSA		".ssh/id_rsa"
+#define _PATH_SSH_CLIENT_IDENTITY	".etc/ssh/identity"
+#define _PATH_SSH_CLIENT_ID_DSA		".etc/ssh/id_dsa"
+#define _PATH_SSH_CLIENT_ID_RSA		".etc/ssh/id_rsa"
 
 /*
  * Configuration file in user's home directory.  This file need not be
@@ -74,7 +81,10 @@
  * particularly secret.  If the user's home directory resides on an NFS
  * volume where root is mapped to nobody, this may need to be world-readable.
  */
-#define _PATH_SSH_USER_CONFFILE		".ssh/config"
+#define _PATH_SSH_USER_CONFFILE		".etc/ssh/config"
+
+/* for root with HOME=/ */
+#define _PATH_SSH_ROOT_CONFFILE		_PATH_SSH_ROOT_PFX "config"
 
 /*
  * File containing a list of those rsa keys that permit logging in as this
@@ -84,10 +94,13 @@
  * may need to be world-readable.  (This file is read by the daemon which is
  * running as root.)
  */
-#define _PATH_SSH_USER_PERMITTED_KEYS	".ssh/authorized_keys"
+#define _PATH_SSH_USER_PERMITTED_KEYS	".etc/ssh/authorised_keys"
+
+/* rarely known feature */
+#define _PATH_SSH_USER_PERMITTED_KEYS2	".ssh/authorized_keys"
 
-/* backward compat for protocol v2 */
-#define _PATH_SSH_USER_PERMITTED_KEYS2	".ssh/authorized_keys2"
+/* for root with HOME=/ */
+#define _PATH_SSH_ROOT_PERMITTED_KEYS	_PATH_SSH_ROOT_PFX "authorised_keys"
 
 /*
  * Per-user and system-wide ssh "rc" files.  These files are executed with
@@ -95,7 +108,7 @@
  * passed "proto cookie" as arguments if X11 forwarding with spoofing is in
  * use.  xauth will be run if neither of these exists.
  */
-#define _PATH_SSH_USER_RC		".ssh/rc"
+#define _PATH_SSH_USER_RC		".etc/ssh/rc"
 #define _PATH_SSH_SYSTEM_RC		SSHDIR "/sshrc"
 
 /*
Index: src/usr.bin/ssh/progressmeter.c
diff -up src/usr.bin/ssh/progressmeter.c:1.1.1.6 src/usr.bin/ssh/progressmeter.c:1.5
--- src/usr.bin/ssh/progressmeter.c:1.1.1.6	Wed Sep 20 21:06:49 2006
+++ src/usr.bin/ssh/progressmeter.c	Thu Oct 31 21:07:12 2013
@@ -1,5 +1,7 @@
 /* $OpenBSD: progressmeter.c,v 1.37 2006/08/03 03:34:42 deraadt Exp $ */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2003 Nils Nordman.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,6 +39,8 @@
 #include "progressmeter.h"
 #include "atomicio.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/progressmeter.c,v 1.5 2013/10/31 20:07:12 tg Exp $");
+
 #define DEFAULT_WINSIZE 80
 #define MAX_WINSIZE 512
 #define PADDING 1		/* padding between the progress indicators */
@@ -225,7 +229,7 @@ refresh_progress_meter(void)
 
 /*ARGSUSED*/
 static void
-update_progress_meter(int ignore)
+update_progress_meter(int ignore __attribute__((__unused__)))
 {
 	int save_errno;
 
Index: src/usr.bin/ssh/readconf.c
diff -up src/usr.bin/ssh/readconf.c:1.1.1.15 src/usr.bin/ssh/readconf.c:1.22
--- src/usr.bin/ssh/readconf.c:1.1.1.15	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/readconf.c	Thu Jan 14 20:23:02 2016
@@ -21,6 +21,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <netdb.h>
+#include <pwd.h>
 #include <signal.h>
 #include <stdio.h>
 #include <string.h>
@@ -40,6 +41,8 @@
 #include "kex.h"
 #include "mac.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.22 2016/01/14 19:23:02 tg Exp $");
+
 /* Format of the configuration file:
 
    # Configuration data is parsed as follows:
@@ -58,7 +61,7 @@
      User foo
 
    Host fake.com
-     HostName another.host.name.real.org
+     Hostname another.host.name.real.org
      User blaah
      Port 34289
      ForwardX11 no
@@ -97,7 +100,7 @@
      RhostsRSAAuthentication yes
      StrictHostKeyChecking yes
      TcpKeepAlive no
-     IdentityFile ~/.ssh/identity
+     IdentityFile ~/.etc/ssh/identity
      Port 22
      EscapeChar ~
 
@@ -123,11 +126,11 @@ typedef enum {
 	oHostKeyAlgorithms, oBindAddress, oSmartcardDevice,
 	oClearAllForwardings, oNoHostAuthenticationForLocalhost,
 	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,
-	oAddressFamily, oGssAuthentication, oGssDelegateCreds,
+	oAddressFamily,
 	oServerAliveInterval, oServerAliveCountMax, oIdentitiesOnly,
 	oSendEnv, oControlPath, oControlMaster, oHashKnownHosts,
 	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
-	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
+	oVisualHostKey,
 	oDeprecated, oUnsupported
 } OpCodes;
 
@@ -159,13 +162,8 @@ static struct {
 	{ "kerberosauthentication", oUnsupported },
 	{ "kerberostgtpassing", oUnsupported },
 	{ "afstokenpassing", oUnsupported },
-#if defined(GSSAPI)
-	{ "gssapiauthentication", oGssAuthentication },
-	{ "gssapidelegatecredentials", oGssDelegateCreds },
-#else
 	{ "gssapiauthentication", oUnsupported },
 	{ "gssapidelegatecredentials", oUnsupported },
-#endif
 	{ "fallbacktorsh", oDeprecated },
 	{ "usersh", oDeprecated },
 	{ "identityfile", oIdentityFile },
@@ -445,14 +433,6 @@ parse_flag:
 		intptr = &options->challenge_response_authentication;
 		goto parse_flag;
 
-	case oGssAuthentication:
-		intptr = &options->gss_authentication;
-		goto parse_flag;
-
-	case oGssDelegateCreds:
-		intptr = &options->gss_deleg_creds;
-		goto parse_flag;
-
 	case oBatchMode:
 		intptr = &options->batch_mode;
 		goto parse_flag;
@@ -910,10 +890,6 @@ parse_int:
 		intptr = &options->visual_host_key;
 		goto parse_flag;
 
-	case oUseRoaming:
-		intptr = &options->use_roaming;
-		goto parse_flag;
-
 	case oDeprecated:
 		debug("%s line %d: Deprecated option \"%s\"",
 		    filename, linenum, keyword);
@@ -994,7 +970,7 @@ read_config_file(const char *filename, c
  */
 
 void
-initialize_options(Options * options)
+initialize_options(Options *options)
 {
 	memset(options, 'X', sizeof(*options));
 	options->forward_agent = -1;
@@ -1007,8 +983,6 @@ initialize_options(Options * options)
 	options->rsa_authentication = -1;
 	options->pubkey_authentication = -1;
 	options->challenge_response_authentication = -1;
-	options->gss_authentication = -1;
-	options->gss_deleg_creds = -1;
 	options->password_authentication = -1;
 	options->kbd_interactive_authentication = -1;
 	options->kbd_interactive_devices = NULL;
@@ -1063,8 +1037,7 @@ initialize_options(Options * options)
 	options->tun_remote = -1;
 	options->local_command = NULL;
 	options->permit_local_command = -1;
-	options->use_roaming = -1;
 	options->visual_host_key = -1;
 }
 
 /*
@@ -1074,7 +1046,7 @@ initialize_options(Options * options)
  */
 
 void
-fill_default_options(Options * options)
+fill_default_options(Options *options, struct passwd *pw)
 {
 	int len;
 
@@ -1087,7 +1059,7 @@ fill_default_options(Options * options)
 	if (options->exit_on_forward_failure == -1)
 		options->exit_on_forward_failure = 0;
 	if (options->xauth_location == NULL)
-		options->xauth_location = _PATH_XAUTH;
+		options->xauth_location = (char *)_PATH_XAUTH;
 	if (options->gateway_ports == -1)
 		options->gateway_ports = 0;
 	if (options->use_privileged_port == -1)
@@ -1098,10 +1070,6 @@ fill_default_options(Options * options)
 		options->pubkey_authentication = 1;
 	if (options->challenge_response_authentication == -1)
 		options->challenge_response_authentication = 1;
-	if (options->gss_authentication == -1)
-		options->gss_authentication = 0;
-	if (options->gss_deleg_creds == -1)
-		options->gss_deleg_creds = 0;
 	if (options->password_authentication == -1)
 		options->password_authentication = 1;
 	if (options->kbd_interactive_authentication == -1)
@@ -1163,13 +1131,18 @@ fill_default_options(Options * options)
 	if (options->escape_char == -1)
 		options->escape_char = '~';
 	if (options->system_hostfile == NULL)
 		options->system_hostfile = _PATH_SSH_SYSTEM_HOSTFILE;
 	if (options->user_hostfile == NULL)
-		options->user_hostfile = _PATH_SSH_USER_HOSTFILE;
+		options->user_hostfile =
+#ifdef _PATH_SSH_ROOT_HOSTFILE
+		    (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
+		    !pw->pw_dir[1])) ? (char *)_PATH_SSH_ROOT_HOSTFILE :
+#endif
+		    (char *)_PATH_SSH_USER_HOSTFILE;
 	if (options->system_hostfile2 == NULL)
 		options->system_hostfile2 = _PATH_SSH_SYSTEM_HOSTFILE2;
 	if (options->user_hostfile2 == NULL)
 		options->user_hostfile2 = _PATH_SSH_USER_HOSTFILE2;
 	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
 		options->log_level = SYSLOG_LEVEL_INFO;
 	if (options->clear_forwardings == 1)
@@ -1200,10 +1173,8 @@ fill_default_options(Options * options)
 		options->tun_remote = SSH_TUNID_ANY;
 	if (options->permit_local_command == -1)
 		options->permit_local_command = 0;
-	if (options->use_roaming == -1)
-		options->use_roaming = 1;
 	if (options->visual_host_key == -1)
 		options->visual_host_key = 0;
 	/* options->local_command should not be set by default */
 	/* options->proxy_command should not be set by default */
 	/* options->user will be set in the main program if appropriate */
Index: src/usr.bin/ssh/readconf.h
diff -up src/usr.bin/ssh/readconf.h:1.1.1.10 src/usr.bin/ssh/readconf.h:1.16
--- src/usr.bin/ssh/readconf.h:1.1.1.10	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/readconf.h	Thu Jan 14 20:23:03 2016
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/readconf.h,v 1.16 2016/01/14 19:23:03 tg Exp $ */
 /* $OpenBSD: readconf.h,v 1.79 2009/06/27 09:35:06 andreas Exp $ */
 
 /*
@@ -43,12 +44,10 @@ typedef struct {
 	int     hostbased_authentication;	/* ssh2's rhosts_rsa */
 	int     challenge_response_authentication;
 					/* Try S/Key or TIS, authentication. */
-	int     gss_authentication;	/* Try GSS authentication */
-	int     gss_deleg_creds;	/* Delegate GSS credentials */
 	int     password_authentication;	/* Try password
 						 * authentication. */
 	int     kbd_interactive_authentication; /* Try keyboard-interactive auth. */
 	char	*kbd_interactive_devices; /* Keyboard-interactive auth devices. */
 	int     batch_mode;	/* Batch mode: do not ask for passwords. */
 	int     check_host_ip;	/* Also keep track of keys for IP address */
 	int     strict_host_key_checking;	/* Strict host key checking. */
@@ -68,18 +66,18 @@ typedef struct {
 	int     number_of_password_prompts;	/* Max number of password
 						 * prompts. */
 	int     cipher;		/* Cipher to use. */
-	char   *ciphers;	/* SSH2 ciphers in order of preference. */
-	char   *macs;		/* SSH2 macs in order of preference. */
+	const char   *ciphers;	/* SSH2 ciphers in order of preference. */
+	const char   *macs;	/* SSH2 macs in order of preference. */
 	char   *hostkeyalgorithms;	/* SSH2 server key types in order of preference. */
 	int	protocol;	/* Protocol in order of preference. */
 	char   *hostname;	/* Real host to connect. */
-	char   *host_key_alias;	/* hostname alias for .ssh/known_hosts */
+	char   *host_key_alias;	/* hostname alias for .etc/ssh/known_hosts */
 	char   *proxy_command;	/* Proxy command for connecting the host. */
 	char   *user;		/* User to log in as. */
 	int     escape_char;	/* Escape character; -2 = none */
 
 	char   *system_hostfile;/* Path for /etc/ssh/ssh_known_hosts. */
-	char   *user_hostfile;	/* Path for $HOME/.ssh/known_hosts. */
+	char   *user_hostfile;	/* Path for $HOME/.etc/ssh/known_hosts. */
 	char   *system_hostfile2;
 	char   *user_hostfile2;
 	char   *preferred_authentications;
@@ -123,8 +121,6 @@ typedef struct {
 	int	permit_local_command;
 	int	visual_host_key;
 
-	int	use_roaming;
-
 }       Options;
 
 #define SSHCTL_MASTER_NO	0
@@ -133,8 +129,10 @@ typedef struct {
 #define SSHCTL_MASTER_ASK	3
 #define SSHCTL_MASTER_AUTO_ASK	4
 
+struct passwd;	/* in case this was not imported */
+
 void     initialize_options(Options *);
-void     fill_default_options(Options *);
+void     fill_default_options(Options *, struct passwd *);
 int	 read_config_file(const char *, const char *, Options *, int);
 int	 parse_forward(Forward *, const char *, int, int);
 
Index: src/usr.bin/ssh/roaming.h
diff -up src/usr.bin/ssh/roaming.h:1.1.1.1 src/usr.bin/ssh/roaming.h:removed
--- src/usr.bin/ssh/roaming.h:1.1.1.1	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/roaming.h	Sun Feb 16 01:06:07 2020
@@ -1,38 +0,0 @@
Index: src/usr.bin/ssh/roaming_common.c
diff -up src/usr.bin/ssh/roaming_common.c:1.1.1.1 src/usr.bin/ssh/roaming_common.c:removed
--- src/usr.bin/ssh/roaming_common.c:1.1.1.1	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/roaming_common.c	Sun Feb 16 01:06:07 2020
@@ -1,197 +0,0 @@
Index: src/usr.bin/ssh/roaming_dummy.c
diff -up src/usr.bin/ssh/roaming_dummy.c:1.1.1.1 src/usr.bin/ssh/roaming_dummy.c:removed
--- src/usr.bin/ssh/roaming_dummy.c:1.1.1.1	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/roaming_dummy.c	Sun Feb 16 01:06:07 2020
@@ -1,59 +0,0 @@
Index: src/usr.bin/ssh/schnorr.c
diff -up src/usr.bin/ssh/schnorr.c:1.1.1.2 src/usr.bin/ssh/schnorr.c:removed
--- src/usr.bin/ssh/schnorr.c:1.1.1.2	Sun Mar 22 13:02:59 2009
+++ src/usr.bin/ssh/schnorr.c	Sun Feb 16 01:06:07 2020
@@ -1,645 +0,0 @@
Index: src/usr.bin/ssh/schnorr.h
diff -up src/usr.bin/ssh/schnorr.h:1.1.1.1 src/usr.bin/ssh/schnorr.h:removed
--- src/usr.bin/ssh/schnorr.h:1.1.1.1	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/schnorr.h	Sun Feb 16 01:06:07 2020
@@ -1,60 +0,0 @@
Index: src/usr.bin/ssh/scp.1
diff -up src/usr.bin/ssh/scp.1:1.1.1.8 src/usr.bin/ssh/scp.1:1.11
--- src/usr.bin/ssh/scp.1:1.1.1.8	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/scp.1	Fri Oct  2 18:58:48 2009
@@ -9,9 +9,10 @@
 .\"
 .\" Created: Sun May  7 00:14:37 1995 ylo
 .\"
+.\" $MirOS: src/usr.bin/ssh/scp.1,v 1.11 2009/10/02 16:58:48 tg Exp $
 .\" $OpenBSD: scp.1,v 1.46 2008/07/12 05:33:41 djm Exp $
 .\"
-.Dd $Mdocdate: December 16 2008 $
+.Dd $Mdocdate: October 2 2009 $
 .Dt SCP 1
 .Os
 .Sh NAME
@@ -137,14 +138,12 @@ For full details of the options listed b
 .It ControlMaster
 .It ControlPath
 .It GlobalKnownHostsFile
-.It GSSAPIAuthentication
-.It GSSAPIDelegateCredentials
 .It HashKnownHosts
 .It Host
 .It HostbasedAuthentication
 .It HostKeyAlgorithms
 .It HostKeyAlias
-.It HostName
+.It Hostname
 .It IdentityFile
 .It IdentitiesOnly
 .It KbdInteractiveDevices
Index: src/usr.bin/ssh/scp.c
diff -up src/usr.bin/ssh/scp.c:1.1.1.14 src/usr.bin/ssh/scp.c:1.20
--- src/usr.bin/ssh/scp.c:1.1.1.14	Tue Dec 16 21:15:33 2008
+++ src/usr.bin/ssh/scp.c	Thu Oct 31 21:07:13 2013
@@ -15,6 +15,8 @@
  * called by a name other than "ssh" or "Secure Shell".
  */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
  * Copyright (c) 1999 Aaron Campbell.  All rights reserved.
  *
@@ -72,7 +74,6 @@
  */
 
 #include <sys/param.h>
-#include <sys/types.h>
 #include <sys/poll.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
@@ -100,6 +101,8 @@
 #include "misc.h"
 #include "progressmeter.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.20 2013/10/31 20:07:13 tg Exp $");
+
 #define COPY_BUFLEN	16384
 
 int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout);
@@ -122,12 +125,12 @@ int verbose_mode = 0;
 int showprogress = 1;
 
 /* This is the program to execute for the secured connection. ("ssh" or -S) */
-char *ssh_program = _PATH_SSH_PROGRAM;
+const char *ssh_program = _PATH_SSH_PROGRAM;
 
 /* This is used to store the pid of ssh_program */
 pid_t do_cmd_pid = -1;
 
-static void
+static __dead void
 killchild(int signo)
 {
 	if (do_cmd_pid > 1) {
@@ -256,9 +259,9 @@ typedef struct {
 } BUF;
 
 BUF *allocbuf(BUF *, int, int);
-void lostconn(int);
+static __dead void lostconn(int);
 int okname(char *);
-void run_err(const char *,...);
+static void run_err(const char *,...) __attribute__((__format__(__printf__, 1, 2)));
 void verifydir(char *);
 
 struct passwd *pwd;
@@ -275,7 +278,7 @@ void sink(int, char *[]);
 void source(int, char *[]);
 void tolocal(int, char *[]);
 void toremote(char *, int, char *[]);
-void usage(void);
+static __dead void usage(void);
 
 int
 main(int argc, char **argv)
@@ -283,8 +286,6 @@ main(int argc, char **argv)
 	int ch, fflag, tflag, status, n;
 	double speed;
 	char *targ, *endp, **newargv;
-	extern char *optarg;
-	extern int optind;
 
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
@@ -846,7 +847,8 @@ sink(int argc, char **argv)
 	mode_t mode, omode, mask;
 	off_t size, statbytes;
 	int setimes, targisdir, wrerrno = 0;
-	char ch, *cp, *np, *targ, *why, *vect[1], buf[2048];
+	char ch, *cp, *np, *targ, *vect[1], buf[2048];
+	const char *why;
 	struct timeval tv[2];
 
 #define	atime	tv[0]
@@ -1148,7 +1150,7 @@ usage(void)
 	exit(1);
 }
 
-void
+static void
 run_err(const char *fmt,...)
 {
 	static FILE *fp;
Index: src/usr.bin/ssh/servconf.c
diff -up src/usr.bin/ssh/servconf.c:1.1.1.15 src/usr.bin/ssh/servconf.c:1.26
--- src/usr.bin/ssh/servconf.c:1.1.1.15	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/servconf.c	Thu May  3 03:32:46 2018
@@ -39,6 +39,9 @@
 #include "match.h"
 #include "channels.h"
 #include "groupaccess.h"
+#include "canohost.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.26 2018/05/03 01:32:46 tg Exp $");
 
 static void add_listen_addr(ServerOptions *, char *, int);
 static void add_one_listen_addr(ServerOptions *, char *, int);
@@ -80,12 +83,6 @@ initialize_server_options(ServerOptions 
 	options->hostbased_uses_name_from_packet_only = -1;
 	options->rsa_authentication = -1;
 	options->pubkey_authentication = -1;
-	options->kerberos_authentication = -1;
-	options->kerberos_or_local_passwd = -1;
-	options->kerberos_ticket_cleanup = -1;
-	options->kerberos_get_afs_token = -1;
-	options->gss_authentication=-1;
-	options->gss_cleanup_creds = -1;
 	options->password_authentication = -1;
 	options->kbd_interactive_authentication = -1;
 	options->challenge_response_authentication = -1;
@@ -113,14 +110,14 @@ initialize_server_options(ServerOptions 
 	options->use_dns = -1;
 	options->client_alive_interval = -1;
 	options->client_alive_count_max = -1;
-	options->authorized_keys_file = NULL;
-	options->authorized_keys_file2 = NULL;
+	options->authorised_keys_file1 = NULL;
+	options->authorised_keys_file2 = NULL;
 	options->num_accept_env = 0;
 	options->permit_tun = -1;
@@ -153,7 +150,7 @@ fill_default_server_options(ServerOption
 	if (options->key_regeneration_time == -1)
 		options->key_regeneration_time = 3600;
 	if (options->permit_root_login == PERMIT_NOT_SET)
-		options->permit_root_login = PERMIT_YES;
+		options->permit_root_login = PERMIT_NO;
 	if (options->ignore_rhosts == -1)
 		options->ignore_rhosts = 1;
 	if (options->ignore_user_known_hosts == -1)
@@ -188,18 +185,6 @@ fill_default_server_options(ServerOption
 		options->rsa_authentication = 1;
 	if (options->pubkey_authentication == -1)
 		options->pubkey_authentication = 1;
-	if (options->kerberos_authentication == -1)
-		options->kerberos_authentication = 0;
-	if (options->kerberos_or_local_passwd == -1)
-		options->kerberos_or_local_passwd = 1;
-	if (options->kerberos_ticket_cleanup == -1)
-		options->kerberos_ticket_cleanup = 1;
-	if (options->kerberos_get_afs_token == -1)
-		options->kerberos_get_afs_token = 0;
-	if (options->gss_authentication == -1)
-		options->gss_authentication = 0;
-	if (options->gss_cleanup_creds == -1)
-		options->gss_cleanup_creds = 1;
 	if (options->password_authentication == -1)
 		options->password_authentication = 1;
 	if (options->kbd_interactive_authentication == -1)
@@ -236,23 +221,24 @@ fill_default_server_options(ServerOption
 		options->client_alive_interval = 0;
 	if (options->client_alive_count_max == -1)
 		options->client_alive_count_max = 3;
-	if (options->authorized_keys_file2 == NULL) {
-		/* authorized_keys_file2 falls back to authorized_keys_file */
-		if (options->authorized_keys_file != NULL)
-			options->authorized_keys_file2 = options->authorized_keys_file;
+	if (options->authorised_keys_file2 == NULL) {
+		/* authorised_keys_file2 falls back to authorised_keys_file1 */
+		if (options->authorised_keys_file1 != NULL)
+			options->authorised_keys_file2 = options->authorised_keys_file1;
 		else
-			options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
+			options->authorised_keys_file2 = (char *)_PATH_SSH_USER_PERMITTED_KEYS2;
 	}
-	if (options->authorized_keys_file == NULL)
-		options->authorized_keys_file = _PATH_SSH_USER_PERMITTED_KEYS;
+	if (options->authorised_keys_file1 == NULL)
+		options->authorised_keys_file1 = (char *)_PATH_SSH_USER_PERMITTED_KEYS;
 	if (options->permit_tun == -1)
 		options->permit_tun = SSH_TUNMODE_NO;
@@ -261,9 +247,7 @@ typedef enum {
 	sPort, sHostKeyFile, sServerKeyBits, sLoginGraceTime, sKeyRegenerationTime,
 	sPermitRootLogin, sLogFacility, sLogLevel,
 	sRhostsRSAAuthentication, sRSAAuthentication,
-	sKerberosAuthentication, sKerberosOrLocalPasswd, sKerberosTicketCleanup,
-	sKerberosGetAFSToken,
-	sKerberosTgtPassing, sChallengeResponseAuthentication,
+	sChallengeResponseAuthentication,
 	sPasswordAuthentication, sKbdInteractiveAuthentication,
 	sListenAddress, sAddressFamily,
 	sPrintMotd, sPrintLastLog, sIgnoreRhosts,
@@ -276,11 +260,11 @@ typedef enum {
 	sMaxStartups, sMaxAuthTries, sMaxSessions,
 	sBanner, sUseDNS, sHostbasedAuthentication,
 	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval,
-	sClientAliveCountMax, sAuthorizedKeysFile, sAuthorizedKeysFile2,
-	sGssAuthentication, sGssCleanupCreds, sAcceptEnv, sPermitTunnel,
+	sClientAliveCountMax, sAuthorisedKeysFile, sAuthorisedKeysFile2,
+	sAcceptEnv, sPermitTunnel,
 	sMatch, sPermitOpen, sForceCommand, sChrootDirectory,
 	sUsePrivilegeSeparation, sAllowAgentForwarding,
@@ -311,35 +295,18 @@ static struct {
 	{ "rsaauthentication", sRSAAuthentication, SSHCFG_ALL },
 	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_ALL },
 	{ "dsaauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */
-#ifdef KRB5
-	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_ALL },
-	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },
-	{ "kerberosticketcleanup", sKerberosTicketCleanup, SSHCFG_GLOBAL },
-	{ "kerberosgetafstoken", sKerberosGetAFSToken, SSHCFG_GLOBAL },
-#else
 	{ "kerberosauthentication", sUnsupported, SSHCFG_ALL },
 	{ "kerberosorlocalpasswd", sUnsupported, SSHCFG_GLOBAL },
 	{ "kerberosticketcleanup", sUnsupported, SSHCFG_GLOBAL },
 	{ "kerberosgetafstoken", sUnsupported, SSHCFG_GLOBAL },
-#endif
 	{ "kerberostgtpassing", sUnsupported, SSHCFG_GLOBAL },
 	{ "afstokenpassing", sUnsupported, SSHCFG_GLOBAL },
-#ifdef GSSAPI
-	{ "gssapiauthentication", sGssAuthentication, SSHCFG_ALL },
-	{ "gssapicleanupcredentials", sGssCleanupCreds, SSHCFG_GLOBAL },
-#else
 	{ "gssapiauthentication", sUnsupported, SSHCFG_ALL },
 	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
-#endif
 	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_ALL },
 	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_ALL },
 	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
 	{ "skeyauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL }, /* alias */
-#ifdef JPAKE
-	{ "zeroknowledgepasswordauthentication", sZeroKnowledgePasswordAuthentication, SSHCFG_ALL },
-#else
-	{ "zeroknowledgepasswordauthentication", sUnsupported, SSHCFG_ALL },
-#endif
 	{ "checkmail", sDeprecated, SSHCFG_GLOBAL },
 	{ "listenaddress", sListenAddress, SSHCFG_GLOBAL },
 	{ "addressfamily", sAddressFamily, SSHCFG_GLOBAL },
@@ -378,8 +345,10 @@ static struct {
 	{ "reversemappingcheck", sDeprecated, SSHCFG_GLOBAL },
 	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_GLOBAL },
 	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
-	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_GLOBAL },
-	{ "authorizedkeysfile2", sAuthorizedKeysFile2, SSHCFG_GLOBAL },
+	{ "authorizedkeysfile", sDeprecated, SSHCFG_GLOBAL },
+	{ "authorizedkeysfile2", sDeprecated, SSHCFG_GLOBAL },
+	{ "authorisedkeysfile", sAuthorisedKeysFile, SSHCFG_GLOBAL },
+	{ "authorisedkeysfile2", sAuthorisedKeysFile2, SSHCFG_GLOBAL },
 	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
 	{ "acceptenv", sAcceptEnv, SSHCFG_GLOBAL },
 	{ "permittunnel", sPermitTunnel, SSHCFG_GLOBAL },
@@ -387,12 +356,13 @@ static struct {
 
 static struct {
 	int val;
-	char *text;
+	const char *text;
 } tunmode_desc[] = {
 	{ SSH_TUNMODE_NO, "no" },
 	{ SSH_TUNMODE_POINTOPOINT, "point-to-point" },
@@ -828,38 +798,10 @@ process_server_config_line(ServerOptions
 		intptr = &options->pubkey_authentication;
 		goto parse_flag;
 
-	case sKerberosAuthentication:
-		intptr = &options->kerberos_authentication;
-		goto parse_flag;
-
-	case sKerberosOrLocalPasswd:
-		intptr = &options->kerberos_or_local_passwd;
-		goto parse_flag;
-
-	case sKerberosTicketCleanup:
-		intptr = &options->kerberos_ticket_cleanup;
-		goto parse_flag;
-
-	case sKerberosGetAFSToken:
-		intptr = &options->kerberos_get_afs_token;
-		goto parse_flag;
-
-	case sGssAuthentication:
-		intptr = &options->gss_authentication;
-		goto parse_flag;
-
-	case sGssCleanupCreds:
-		intptr = &options->gss_cleanup_creds;
-		goto parse_flag;
-
 	case sPasswordAuthentication:
 		intptr = &options->password_authentication;
 		goto parse_flag;
 
-	case sZeroKnowledgePasswordAuthentication:
-		intptr = &options->zero_knowledge_password_authentication;
-		goto parse_flag;
-
 	case sKbdInteractiveAuthentication:
 		intptr = &options->kbd_interactive_authentication;
 		goto parse_flag;
@@ -1139,13 +1081,13 @@ process_server_config_line(ServerOptions
 	 * These options can contain %X options expanded at
 	 * connect time, so that you can specify paths like:
 	 *
-	 * AuthorizedKeysFile	/etc/ssh_keys/%u
+	 * AuthorisedKeysFile	/etc/ssh_keys/%u
 	 */
-	case sAuthorizedKeysFile:
-	case sAuthorizedKeysFile2:
-		charptr = (opcode == sAuthorizedKeysFile) ?
-		    &options->authorized_keys_file :
-		    &options->authorized_keys_file2;
+	case sAuthorisedKeysFile:
+	case sAuthorisedKeysFile2:
+		charptr = (opcode == sAuthorisedKeysFile) ?
+		    &options->authorised_keys_file1 :
+		    &options->authorised_keys_file2;
 		goto parse_filename;
 
 	case sClientAliveInterval:
@@ -1341,13 +1287,10 @@ void
 copy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)
 {
 	M_CP_INTOPT(password_authentication);
-	M_CP_INTOPT(gss_authentication);
 	M_CP_INTOPT(rsa_authentication);
 	M_CP_INTOPT(pubkey_authentication);
-	M_CP_INTOPT(kerberos_authentication);
 	M_CP_INTOPT(hostbased_authentication);
 	M_CP_INTOPT(kbd_interactive_authentication);
-	M_CP_INTOPT(zero_knowledge_password_authentication);
 	M_CP_INTOPT(permit_root_login);
 	M_CP_INTOPT(permit_empty_passwd);
 
@@ -1491,7 +1435,8 @@ dump_config(ServerOptions *o)
 	u_int i;
 	int ret;
 	struct addrinfo *ai;
-	char addr[NI_MAXHOST], port[NI_MAXSERV], *s = NULL;
+	char addr[NI_MAXHOST], port[NI_MAXSERV];
+	const char *s = NULL;
 
 	/* these are usually at the top of the config */
 	for (i = 0; i < o->num_ports; i++)
@@ -1575,8 +1517,8 @@ dump_config(ServerOptions *o)
 	dump_cfg_string(sCiphers, o->ciphers);
 	dump_cfg_string(sMacs, o->macs);
 	dump_cfg_string(sBanner, o->banner);
-	dump_cfg_string(sAuthorizedKeysFile, o->authorized_keys_file);
-	dump_cfg_string(sAuthorizedKeysFile2, o->authorized_keys_file2);
+	dump_cfg_string(sAuthorisedKeysFile, o->authorised_keys_file1);
+	dump_cfg_string(sAuthorisedKeysFile2, o->authorised_keys_file2);
 	dump_cfg_string(sForceCommand, o->adm_forced_command);
 
 	/* string arguments requiring a lookup */
--- src/usr.bin/ssh/servconf.h:1.1.1.8	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/servconf.h	Thu May  3 03:32:46 2018
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/servconf.h,v 1.15 2018/05/03 01:32:46 tg Exp $ */
 /* $OpenBSD: servconf.h,v 1.87 2009/01/22 10:02:34 djm Exp $ */
 
 /*
@@ -56,7 +57,7 @@ typedef struct {
 	int     key_regeneration_time;	/* Server key lifetime (seconds). */
 	int     permit_root_login;	/* PERMIT_*, see above */
 	int     ignore_rhosts;	/* Ignore .rhosts and .shosts. */
-	int     ignore_user_known_hosts;	/* Ignore ~/.ssh/known_hosts
+	int     ignore_user_known_hosts;	/* Ignore ~/.etc/ssh/known_hosts
 						 * for RhostsRsaAuth */
 	int     print_motd;	/* If true, print /etc/motd. */
 	int	print_lastlog;	/* If true, print lastlog */
@@ -67,8 +68,8 @@ typedef struct {
 	char   *xauth_location;	/* Location of xauth program */
 	int     strict_modes;	/* If true, require string home dir modes. */
 	int     tcp_keep_alive;	/* If true, set SO_KEEPALIVE. */
-	char   *ciphers;	/* Supported SSH2 ciphers. */
-	char   *macs;		/* Supported SSH2 macs. */
+	const char   *ciphers;	/* Supported SSH2 ciphers. */
+	const char   *macs;	/* Supported SSH2 macs. */
 	int	protocol;	/* Supported protocol versions. */
 	int     gateway_ports;	/* If true, allow remote connects to forwarded ports. */
 	SyslogFacility log_facility;	/* Facility for system logging. */
@@ -79,28 +80,13 @@ typedef struct {
 	int     hostbased_uses_name_from_packet_only; /* experimental */
 	int     rsa_authentication;	/* If true, permit RSA authentication. */
 	int     pubkey_authentication;	/* If true, permit ssh2 pubkey authentication. */
-	int     kerberos_authentication;	/* If true, permit Kerberos
-						 * authentication. */
-	int     kerberos_or_local_passwd;	/* If true, permit kerberos
-						 * and any other password
-						 * authentication mechanism,
-						 * such as SecurID or
-						 * /etc/passwd */
-	int     kerberos_ticket_cleanup;	/* If true, destroy ticket
-						 * file on logout. */
-	int     kerberos_get_afs_token;		/* If true, try to get AFS token if
-						 * authenticated with Kerberos. */
-	int     gss_authentication;	/* If true, permit GSSAPI authentication */
-	int     gss_cleanup_creds;	/* If true, destroy cred cache on logout */
 	int     password_authentication;	/* If true, permit password
 						 * authentication. */
 	int     kbd_interactive_authentication;	/* If true, permit */
 	int     challenge_response_authentication;
-	int     zero_knowledge_password_authentication;
-					/* If true, permit jpake auth */
 	int     permit_empty_passwd;	/* If false, do not permit empty
 					 * passwords. */
-	int     permit_user_env;	/* If true, read ~/.ssh/environment */
+	int     permit_user_env;	/* If true, read ~/.etc/ssh/environment */
 	int     use_login;	/* If true, login(1) is used */
 	int     compression;	/* If true, compression is allowed */
 	int	allow_tcp_forwarding;
@@ -139,8 +125,8 @@ typedef struct {
 					 * disconnect the session
 					 */
 
-	char   *authorized_keys_file;	/* File containing public keys */
-	char   *authorized_keys_file2;
+	char   *authorised_keys_file1;	/* File containing public keys */
+	char   *authorised_keys_file2;	/* Same; note not used for root */
 
 	char   *adm_forced_command;
 
--- src/usr.bin/ssh/serverloop.c:1.1.1.12	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/serverloop.c	Thu Jan 14 20:23:04 2016
@@ -35,11 +35,10 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/wait.h>
 #include <sys/socket.h>
 #include <sys/time.h>
-#include <sys/param.h>
 #include <sys/queue.h>
 
 #include <netinet/in.h>
@@ -74,7 +73,8 @@
 #include "auth-options.h"
 #include "serverloop.h"
 #include "misc.h"
-#include "roaming.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/serverloop.c,v 1.10 2016/01/14 19:23:04 tg Exp $");
 
 extern ServerOptions options;
 
@@ -376,11 +376,8 @@ process_input(fd_set *readset)
 
 	/* Read and buffer any input data from the client. */
 	if (FD_ISSET(connection_in, readset)) {
-		int cont = 0;
-		len = roaming_read(connection_in, buf, sizeof(buf), &cont);
+		len = read(connection_in, buf, sizeof(buf));
 		if (len == 0) {
-			if (cont)
-				return;
 			verbose("Connection closed by %.100s",
 			    get_remote_ipaddr());
 			connection_closed = 1;
Index: src/usr.bin/ssh/session.c
diff -up src/usr.bin/ssh/session.c:1.1.1.18 src/usr.bin/ssh/session.c:1.24
--- src/usr.bin/ssh/session.c:1.1.1.18	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/session.c	Fri Mar 25 19:55:35 2016
@@ -33,14 +33,14 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/wait.h>
 #include <sys/un.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
-#include <sys/param.h>
 #include <sys/queue.h>
 
+#include <ctype.h>
 #include <errno.h>
 #include <grp.h>
 #include <login_cap.h>
@@ -77,15 +77,10 @@
 #include "canohost.h"
 #include "misc.h"
 #include "session.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
 #include "sftp.h"
 
-#ifdef KRB5
-#include <kafs.h>
-#endif
+__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.24 2016/03/25 18:55:35 tg Exp $");
 
 #define IS_INTERNAL_SFTP(c) \
 	(!strncmp(c, INTERNAL_SFTP_NAME, sizeof(INTERNAL_SFTP_NAME) - 1) && \
@@ -95,7 +90,6 @@
 
 /* func */
 
-Session *session_new(void);
 void	session_set_fds(Session *, int, int, int, int);
 void	session_pty_cleanup(Session *);
 void	session_proctitle(Session *);
@@ -104,7 +98,7 @@ int	do_exec_pty(Session *, const char *)
 int	do_exec_no_pty(Session *, const char *);
 int	do_exec(Session *, const char *);
 void	do_login(Session *, const char *);
-void	do_child(Session *, const char *);
+void	do_child(Session *, const char *) __dead;
 void	do_motd(void);
 int	check_quietlogin(Session *, const char *);
 
@@ -265,6 +259,21 @@ do_authenticated(Authctxt *authctxt)
 	do_cleanup(authctxt);
 }
 
+/* Check untrusted xauth strings for metacharacters */
+static int
+xauth_valid_string(const char *s)
+{
+	size_t i;
+
+	for (i = 0; s[i] != '\0'; i++) {
+		if (!isalnum((u_char)s[i]) &&
+		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
+		    s[i] != '-' && s[i] != '_')
+		return 0;
+	}
+	return 1;
+}
+
 /*
  * Prepares for an interactive session.  This is called after the user has
  * been successfully authenticated.  During this message exchange, pseudo
@@ -338,7 +347,13 @@ do_authenticated1(Authctxt *authctxt)
 				s->screen = 0;
 			}
 			packet_check_eom();
-			success = session_setup_x11fwd(s);
+			if (xauth_valid_string(s->auth_proto) &&
+			    xauth_valid_string(s->auth_data))
+				success = session_setup_x11fwd(s);
+			else {
+				success = 0;
+				error("Invalid X11 forwarding data");
+			}
 			if (!success) {
 				xfree(s->auth_proto);
 				xfree(s->auth_data);
@@ -707,28 +722,27 @@ do_exec(Session *s, const char *command)
 	if (options.adm_forced_command) {
 		original_command = command;
 		command = options.adm_forced_command;
+#ifndef SMALL
 		if (IS_INTERNAL_SFTP(command))
 			s->is_subsystem = SUBSYSTEM_INT_SFTP;
-		else if (s->is_subsystem)
+		else
+#endif
+		if (s->is_subsystem)
 			s->is_subsystem = SUBSYSTEM_EXT;
 		debug("Forced command (config) '%.900s'", command);
 	} else if (forced_command) {
 		original_command = command;
 		command = forced_command;
+#ifndef SMALL
 		if (IS_INTERNAL_SFTP(command))
 			s->is_subsystem = SUBSYSTEM_INT_SFTP;
-		else if (s->is_subsystem)
+		else
+#endif
+		if (s->is_subsystem)
 			s->is_subsystem = SUBSYSTEM_EXT;
 		debug("Forced command (key option) '%.900s'", command);
 	}
 
-#ifdef GSSAPI
-	if (options.gss_authentication) {
-		temporarily_use_uid(s->pw);
-		ssh_gssapi_storecreds();
-		restore_uid();
-	}
-#endif
 	if (s->ttyfd != -1)
 		ret = do_exec_pty(s, command);
 	else
@@ -928,13 +942,6 @@ do_setup_env(Session *s, const char *she
 	env = xcalloc(envsize, sizeof(char *));
 	env[0] = NULL;
 
-#ifdef GSSAPI
-	/* Allow any GSSAPI methods that we've used to alter
-	 * the childs environment as they see fit
-	 */
-	ssh_gssapi_do_child(&env, &envsize);
-#endif
-
 	if (!options.use_login) {
 		/* Set basic environment. */
 		for (i = 0; i < s->num_env; i++)
@@ -997,18 +1004,13 @@ do_setup_env(Session *s, const char *she
 	if (original_command)
 		child_set_env(&env, &envsize, "SSH_ORIGINAL_COMMAND",
 		    original_command);
-#ifdef KRB5
-	if (s->authctxt->krb5_ticket_file)
-		child_set_env(&env, &envsize, "KRB5CCNAME",
-		    s->authctxt->krb5_ticket_file);
-#endif
 	if (auth_sock_name != NULL)
 		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
 		    auth_sock_name);
 
-	/* read $HOME/.ssh/environment. */
+	/* read $HOME/.etc/ssh/environment. */
 	if (options.permit_user_env && !options.use_login) {
-		snprintf(buf, sizeof buf, "%.200s/.ssh/environment",
+		snprintf(buf, sizeof buf, "%.200s/.etc/ssh/environment",
 		    pw->pw_dir);
 		read_environment_file(&env, &envsize, buf);
 	}
@@ -1022,7 +1024,7 @@ do_setup_env(Session *s, const char *she
 }
 
 /*
- * Run $HOME/.ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
+ * Run $HOME/.etc/ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
  * first in this order).
  */
 static void
@@ -1336,41 +1338,15 @@ do_child(Session *s, const char *command
 	child_close_fds();
 
 	/*
-	 * Must take new environment into use so that .ssh/rc,
+	 * Must take new environment into use so that .etc/ssh/rc,
 	 * /etc/ssh/sshrc and xauth are run in the proper environment.
 	 */
 	environ = env;
 
-#ifdef KRB5
-	/*
-	 * At this point, we check to see if AFS is active and if we have
-	 * a valid Kerberos 5 TGT. If so, it seems like a good idea to see
-	 * if we can (and need to) extend the ticket into an AFS token. If
-	 * we don't do this, we run into potential problems if the user's
-	 * home directory is in AFS and it's not world-readable.
-	 */
-
-	if (options.kerberos_get_afs_token && k_hasafs() &&
-	    (s->authctxt->krb5_ctx != NULL)) {
-		char cell[64];
-
-		debug("Getting AFS token");
-
-		k_setpag();
-
-		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
-			krb5_afslog(s->authctxt->krb5_ctx,
-			    s->authctxt->krb5_fwd_ccache, cell, NULL);
-
-		krb5_afslog_home(s->authctxt->krb5_ctx,
-		    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);
-	}
-#endif
-
 	/* Change current directory to the user's home directory. */
 	if (chdir(pw->pw_dir) < 0) {
 		/* Suppress missing homedir warning for chroot case */
 		r = login_getcapbool(lc, "requirehome", 0);
 		if (r || options.chroot_directory == NULL)
 			fprintf(stderr, "Could not chdir to home "
 			    "directory %s: %s\n", pw->pw_dir,
@@ -1387,8 +1363,8 @@ do_child(Session *s, const char *command
 	/* restore SIGPIPE for child */
 	signal(SIGPIPE, SIG_DFL);
 
+#ifndef SMALL
 	if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {
-		extern int optind, optreset;
 		int i;
 		char *p, *args;
 
@@ -1402,6 +1378,7 @@ do_child(Session *s, const char *command
 		__progname = argv[0];
 		exit(sftp_server_main(i, argv, s->pw));
 	}
+#endif
 
 	if (options.use_login) {
 		launch_login(pw, hostname);
@@ -1713,9 +1690,12 @@ session_subsystem_req(Session *s)
 		if (strcmp(subsys, options.subsystem_name[i]) == 0) {
 			prog = options.subsystem_command[i];
 			cmd = options.subsystem_args[i];
+#ifndef SMALL
 			if (!strcmp(INTERNAL_SFTP_NAME, prog)) {
 				s->is_subsystem = SUBSYSTEM_INT_SFTP;
-			} else if (stat(prog, &st) < 0) {
+			} else
+#endif
+			  if (stat(prog, &st) < 0) {
 				error("subsystem: cannot stat %s: %s", prog,
 				    strerror(errno));
 				break;
@@ -1752,7 +1732,13 @@ session_x11_req(Session *s)
 	s->screen = packet_get_int();
 	packet_check_eom();
 
-	success = session_setup_x11fwd(s);
+	if (xauth_valid_string(s->auth_proto) &&
+	    xauth_valid_string(s->auth_data))
+		success = session_setup_x11fwd(s);
+	else {
+		success = 0;
+		error("Invalid X11 forwarding data");
+	}
 	if (!success) {
 		xfree(s->auth_proto);
 		xfree(s->auth_data);
@@ -1948,7 +1934,7 @@ session_pty_cleanup(Session *s)
 	PRIVSEP(session_pty_cleanup2(s));
 }
 
-static char *
+static const char *
 sig2name(int sig)
 {
 #define SSH_SIG(x) if (sig == SIG ## x) return #x
@@ -2249,7 +2235,7 @@ session_setup_x11fwd(Session *s)
 		fatal("gethostname: %.100s", strerror(errno));
 	/*
 	 * auth_display must be used as the displayname when the
-	 * authorization entry is added with xauth(1).  This will be
+	 * authorisation entry is added with xauth(1).  This will be
 	 * different than the DISPLAY string for localhost displays.
 	 */
 	if (options.x11_use_localhost) {
@@ -2293,16 +2279,6 @@ do_cleanup(Authctxt *authctxt)
 
 	if (authctxt == NULL || !authctxt->authenticated)
 		return;
-#ifdef KRB5
-	if (options.kerberos_ticket_cleanup &&
-	    authctxt->krb5_ctx)
-		krb5_cleanup_proc(authctxt);
-#endif
-
-#ifdef GSSAPI
-	if (compat20 && options.gss_cleanup_creds)
-		ssh_gssapi_cleanup_creds();
-#endif
 
 	/* remove agent socket */
 	auth_sock_cleanup_proc(authctxt->pw);
Index: src/usr.bin/ssh/sftp-client.c
diff -up src/usr.bin/ssh/sftp-client.c:1.1.1.15 src/usr.bin/ssh/sftp-client.c:1.18
--- src/usr.bin/ssh/sftp-client.c:1.1.1.15	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sftp-client.c	Thu Oct 31 21:07:13 2013
@@ -1,5 +1,7 @@
 /* $OpenBSD: sftp-client.c,v 1.89 2009/08/18 18:36:20 djm Exp $ */
 /*
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 2001-2004 Damien Miller <djm@openbsd.org>
  *
  * Permission to use, copy, modify, and distribute this software for any
@@ -20,11 +22,10 @@
 /* XXX: remove all logging, only return status codes */
 /* XXX: copy between two remote sites */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/stat.h>
 #include <sys/time.h>
-#include <sys/param.h>
 #include <sys/statvfs.h>
 #include <sys/uio.h>
 
@@ -48,6 +49,8 @@
 #include "sftp-common.h"
 #include "sftp-client.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sftp-client.c,v 1.18 2013/10/31 20:07:13 tg Exp $");
+
 extern volatile sig_atomic_t interrupted;
 extern int showprogress;
 
@@ -72,7 +75,7 @@ struct sftp_conn {
 
 static char *
 get_handle(int fd, u_int expected_id, u_int *len, const char *errfmt, ...)
-    __attribute__((format(printf, 4, 5)));
+    __attribute__((__format__(__printf__, 4, 5)));
 
 static void
 send_msg(int fd, Buffer *m)
@@ -123,7 +126,7 @@ get_msg(int fd, Buffer *m)
 }
 
 static void
-send_string_request(int fd, u_int id, u_int code, char *s,
+send_string_request(int fd, u_int id, u_int code, const char *s,
     u_int len)
 {
 	Buffer msg;
@@ -681,7 +684,7 @@ do_fsetstat(struct sftp_conn *conn, char
 }
 
 char *
-do_realpath(struct sftp_conn *conn, char *path)
+do_realpath(struct sftp_conn *conn, const char *path)
 {
 	Buffer msg;
 	u_int type, expected_id, count, id;
Index: src/usr.bin/ssh/sftp-client.h
diff -up src/usr.bin/ssh/sftp-client.h:1.1.1.5 src/usr.bin/ssh/sftp-client.h:1.2
--- src/usr.bin/ssh/sftp-client.h:1.1.1.5	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sftp-client.h	Sun Oct  4 16:29:08 2009
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/sftp-client.h,v 1.2 2009/10/04 14:29:08 tg Exp $ */
 /* $OpenBSD: sftp-client.h,v 1.18 2009/08/18 18:36:20 djm Exp $ */
 
 /*
@@ -86,7 +87,7 @@ int do_setstat(struct sftp_conn *, char 
 int do_fsetstat(struct sftp_conn *, char *, u_int, Attrib *);
 
 /* Canonicalise 'path' - caller must free result */
-char *do_realpath(struct sftp_conn *, char *);
+char *do_realpath(struct sftp_conn *, const char *);
 
 /* Get statistics for filesystem hosting file at "path" */
 int do_statvfs(struct sftp_conn *, const char *, struct sftp_statvfs *, int);
Index: src/usr.bin/ssh/sftp-common.c
diff -up src/usr.bin/ssh/sftp-common.c:1.1.1.4 src/usr.bin/ssh/sftp-common.c:1.4
--- src/usr.bin/ssh/sftp-common.c:1.1.1.4	Wed Sep 20 21:06:49 2006
+++ src/usr.bin/ssh/sftp-common.c	Wed Sep 20 23:41:04 2006
@@ -24,9 +24,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <sys/param.h>
+#include <sys/stat.h>
 
 #include <grp.h>
 #include <pwd.h>
@@ -42,6 +41,8 @@
 #include "sftp.h"
 #include "sftp-common.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sftp-common.c,v 1.4 2006/09/20 21:41:04 tg Exp $");
+
 /* Clear contents of attributes structure */
 void
 attrib_clear(Attrib *a)
Index: src/usr.bin/ssh/sftp-glob.c
diff -up src/usr.bin/ssh/sftp-glob.c:1.1.1.4 src/usr.bin/ssh/sftp-glob.c:1.6
--- src/usr.bin/ssh/sftp-glob.c:1.1.1.4	Wed Sep 20 21:06:49 2006
+++ src/usr.bin/ssh/sftp-glob.c	Fri Oct  8 22:18:55 2010
@@ -28,6 +28,8 @@
 #include "sftp-common.h"
 #include "sftp-client.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sftp-glob.c,v 1.6 2010/10/08 20:18:55 tg Exp $");
+
 int remote_glob(struct sftp_conn *, const char *, int,
     int (*)(const char *, int), glob_t *);
 
@@ -118,5 +120,6 @@ remote_glob(struct sftp_conn *conn, cons
 	memset(&cur, 0, sizeof(cur));
 	cur.conn = conn;
 
-	return(glob(pattern, flags | GLOB_ALTDIRFUNC, errfunc, pglob));
+	return (glob(pattern, flags | GLOB_ALTDIRFUNC | GLOB_LIMIT, errfunc,
+	    pglob));
 }
Index: src/usr.bin/ssh/sftp-server.c
diff -up src/usr.bin/ssh/sftp-server.c:1.1.1.13 src/usr.bin/ssh/sftp-server.c:1.12
--- src/usr.bin/ssh/sftp-server.c:1.1.1.13	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sftp-server.c	Sun Oct  4 16:29:08 2009
@@ -15,10 +15,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/time.h>
 #include <sys/param.h>
+#include <sys/time.h>
+#include <sys/stat.h>
 #include <sys/mount.h>
 #include <sys/statvfs.h>
 
@@ -42,6 +41,10 @@
 #include "sftp.h"
 #include "sftp-common.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.12 2009/10/04 14:29:08 tg Exp $");
+
+extern const char *__progname;
+
 /* helper */
 #define get_int64()			buffer_get_int64(&iqueue);
 #define get_int()			buffer_get_int(&iqueue);
@@ -320,7 +323,7 @@ handle_close(int handle)
 }
 
 static void
-handle_log_close(int handle, char *emsg)
+handle_log_close(int handle, const char *emsg)
 {
 	if (handle_is_ok(handle, HANDLE_FILE)) {
 		logit("%s%sclose \"%s\" bytes read %llu written %llu",
@@ -1291,8 +1294,6 @@ sftp_server_cleanup_exit(int i)
 static void
 sftp_server_usage(void)
 {
-	extern char *__progname;
-
 	fprintf(stderr,
 	    "usage: %s [-he] [-l log_level] [-f log_facility] [-u umask]\n",
 	    __progname);
@@ -1310,9 +1311,6 @@ sftp_server_main(int argc, char **argv, 
 	const char *errmsg;
 	mode_t mask;
 
-	extern char *optarg;
-	extern char *__progname;
-
 	log_init(__progname, log_level, log_facility, log_stderr);
 
 	while (!skipargs && (ch = getopt(argc, argv, "f:l:u:che")) != -1) {
Index: src/usr.bin/ssh/sftp.1
diff -up src/usr.bin/ssh/sftp.1:1.1.1.6 src/usr.bin/ssh/sftp.1:1.8
--- src/usr.bin/ssh/sftp.1:1.1.1.6	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sftp.1	Sun Oct  4 16:29:09 2009
@@ -1,3 +1,4 @@
+.\" $MirOS: src/usr.bin/ssh/sftp.1,v 1.8 2009/10/04 14:29:09 tg Exp $
 .\" $OpenBSD: sftp.1,v 1.76 2009/08/19 04:56:03 jmc Exp $
 .\"
 .\" Copyright (c) 2001 Damien Miller.  All rights reserved.
@@ -186,14 +187,12 @@ For full details of the options listed b
 .It ControlMaster
 .It ControlPath
 .It GlobalKnownHostsFile
-.It GSSAPIAuthentication
-.It GSSAPIDelegateCredentials
 .It HashKnownHosts
 .It Host
 .It HostbasedAuthentication
 .It HostKeyAlgorithms
 .It HostKeyAlias
-.It HostName
+.It Hostname
 .It IdentityFile
 .It IdentitiesOnly
 .It KbdInteractiveDevices
Index: src/usr.bin/ssh/sftp.c
diff -up src/usr.bin/ssh/sftp.c:1.1.1.17 src/usr.bin/ssh/sftp.c:1.22
--- src/usr.bin/ssh/sftp.c:1.1.1.17	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sftp.c	Fri Oct  8 22:18:55 2010
@@ -15,12 +15,11 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
-#include <sys/param.h>
 #include <sys/statvfs.h>
 
 #include <ctype.h>
@@ -47,6 +46,10 @@
 #include "sftp-common.h"
 #include "sftp-client.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.22 2010/10/08 20:18:55 tg Exp $");
+
+extern const char *__progname;
+
 /* File to read commands from */
 FILE* infile;
 
@@ -167,7 +170,7 @@ static const struct CMD cmds[] = {
 int interactive_loop(int fd_in, int fd_out, char *file1, char *file2);
 
 /* ARGSUSED */
-static void
+static __dead void
 killchild(int signo)
 {
 	if (sshpid > 1) {
@@ -317,7 +320,6 @@ static int
 parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag,
     int *rflag)
 {
-	extern int opterr, optind, optopt, optreset;
 	int ch;
 
 	optind = optreset = 1;
@@ -346,7 +348,6 @@ parse_getput_flags(const char *cmd, char
 static int
 parse_ls_flags(char **argv, int argc, int *lflag)
 {
-	extern int opterr, optind, optopt, optreset;
 	int ch;
 
 	optind = optreset = 1;
@@ -396,7 +397,6 @@ parse_ls_flags(char **argv, int argc, in
 static int
 parse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)
 {
-	extern int opterr, optind, optopt, optreset;
 	int ch;
 
 	optind = optreset = 1;
@@ -547,7 +547,7 @@ process_put(struct sftp_conn *conn, char
 
 	memset(&g, 0, sizeof(g));
 	debug3("Looking up %s", src);
-	if (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {
+	if (glob(src, GLOB_NOCHECK | GLOB_MARK | GLOB_LIMIT, NULL, &g)) {
 		error("File \"%s\" not found.", src);
 		err = -1;
 		goto out;
@@ -1440,7 +1440,7 @@ parse_dispatch_command(struct sftp_conn 
 	return (0);
 }
 
-static char *
+static const char *
 prompt(EditLine *el)
 {
 	return ("sftp> ");
@@ -1457,7 +1457,6 @@ interactive_loop(int fd_in, int fd_out, 
 	EditLine *el = NULL;
 	History *hl = NULL;
 	HistEvent hev;
-	extern char *__progname;
 
 	if (!batchmode && isatty(STDIN_FILENO)) {
 		if ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)
@@ -1572,7 +1571,7 @@ interactive_loop(int fd_in, int fd_out, 
 }
 
 static void
-connect_to_server(char *path, char **args, int *in, int *out)
+connect_to_server(const char *path, char **args, int *in, int *out)
 {
 	int c_in, c_out;
 
@@ -1615,11 +1614,9 @@ connect_to_server(char *path, char **arg
 	close(c_out);
 }
 
-static void
+static __dead void
 usage(void)
 {
-	extern char *__progname;
-
 	fprintf(stderr,
 	    "usage: %s [-1246Cpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
 	    "          [-D sftp_server_path] [-F ssh_config] "
@@ -1640,12 +1637,12 @@ main(int argc, char **argv)
 	int in, out, ch, err;
 	char *host, *userhost, *cp, *file2 = NULL;
 	int debug_level = 0, sshver = 2;
-	char *file1 = NULL, *sftp_server = NULL;
-	char *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;
+	char *file1 = NULL;
+	const char *sftp_server = NULL;
+	const char *ssh_program = _PATH_SSH_PROGRAM;
+	char *sftp_direct = NULL;
 	LogLevel ll = SYSLOG_LEVEL_INFO;
 	arglist args;
-	extern int optind;
-	extern char *optarg;
 
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
Index: src/usr.bin/ssh/sftp.h
diff -up src/usr.bin/ssh/sftp.h:1.1.1.4 src/usr.bin/ssh/sftp.h:1.2
--- src/usr.bin/ssh/sftp.h:1.1.1.4	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/sftp.h	Sun Oct  4 16:29:09 2009
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/sftp.h,v 1.2 2009/10/04 14:29:09 tg Exp $ */
 /* $OpenBSD: sftp.h,v 1.9 2008/06/13 00:12:02 dtucker Exp $ */
 
 /*
@@ -97,5 +98,5 @@
 
 struct passwd;
 
-int	sftp_server_main(int, char **, struct passwd *);
-void	sftp_server_cleanup_exit(int) __attribute__((noreturn));
+__dead int sftp_server_main(int, char **, struct passwd *);
+__dead void sftp_server_cleanup_exit(int);
Index: src/usr.bin/ssh/ssh-add.1
diff -up src/usr.bin/ssh/ssh-add.1:1.1.1.5 src/usr.bin/ssh/ssh-add.1:1.6
--- src/usr.bin/ssh/ssh-add.1:1.1.1.5	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/ssh-add.1	Tue Dec 16 21:55:28 2008
@@ -1,3 +1,4 @@
+.\"	$MirOS: src/usr.bin/ssh/ssh-add.1,v 1.6 2008/12/16 20:55:28 tg Exp $
 .\"	$OpenBSD: ssh-add.1,v 1.46 2007/06/12 13:41:03 jmc Exp $
 .\"
 .\"  -*- nroff -*-
@@ -57,10 +58,10 @@
 adds RSA or DSA identities to the authentication agent,
 .Xr ssh-agent 1 .
 When run without arguments, it adds the files
-.Pa ~/.ssh/id_rsa ,
-.Pa ~/.ssh/id_dsa
+.Pa ~/.etc/ssh/id_rsa ,
+.Pa ~/.etc/ssh/id_dsa
 and
-.Pa ~/.ssh/identity .
+.Pa ~/.etc/ssh/identity .
 Alternative file names can be given on the command line.
 If any file requires a passphrase,
 .Nm
@@ -153,11 +154,11 @@ agent.
 .El
 .Sh FILES
 .Bl -tag -width Ds
-.It Pa ~/.ssh/identity
+.It Pa ~/.etc/ssh/identity
 Contains the protocol version 1 RSA authentication identity of the user.
-.It Pa ~/.ssh/id_dsa
+.It Pa ~/.etc/ssh/id_dsa
 Contains the protocol version 2 DSA authentication identity of the user.
-.It Pa ~/.ssh/id_rsa
+.It Pa ~/.etc/ssh/id_rsa
 Contains the protocol version 2 RSA authentication identity of the user.
 .El
 .Pp
Index: src/usr.bin/ssh/ssh-add.c
diff -up src/usr.bin/ssh/ssh-add.c:1.1.1.10 src/usr.bin/ssh/ssh-add.c:1.8
--- src/usr.bin/ssh/ssh-add.c:1.1.1.10	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/ssh-add.c	Sun Oct  4 16:29:09 2009
@@ -35,9 +35,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <sys/param.h>
+#include <sys/stat.h>
 
 #include <openssl/evp.h>
 
@@ -59,11 +58,13 @@
 #include "pathnames.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/ssh-add.c,v 1.8 2009/10/04 14:29:09 tg Exp $");
+
 /* argv0 */
 extern char *__progname;
 
 /* Default files to add */
-static char *default_files[] = {
+static const char *default_files[] = {
 	_PATH_SSH_CLIENT_ID_RSA,
 	_PATH_SSH_CLIENT_ID_DSA,
 	_PATH_SSH_CLIENT_IDENTITY,
@@ -322,8 +323,6 @@ usage(void)
 int
 main(int argc, char **argv)
 {
-	extern char *optarg;
-	extern int optind;
 	AuthenticationConnection *ac = NULL;
 	char *sc_reader_id = NULL;
 	int i, ch, deleting = 0, ret = 0;
Index: src/usr.bin/ssh/ssh-agent.1
diff -up src/usr.bin/ssh/ssh-agent.1:1.1.1.8 src/usr.bin/ssh/ssh-agent.1:1.9
--- src/usr.bin/ssh/ssh-agent.1:1.1.1.8	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/ssh-agent.1	Sun Oct  4 16:29:09 2009
@@ -1,3 +1,4 @@
+.\" $MirOS: src/usr.bin/ssh/ssh-agent.1,v 1.9 2009/10/04 14:29:09 tg Exp $
 .\" $OpenBSD: ssh-agent.1,v 1.47 2009/03/26 08:38:39 sobrado Exp $
 .\"
 .\" Author: Tatu Ylonen <ylo@cs.hut.fi>
@@ -111,10 +112,10 @@ Keys are added using
 When executed without arguments,
 .Xr ssh-add 1
 adds the files
-.Pa ~/.ssh/id_rsa ,
-.Pa ~/.ssh/id_dsa
+.Pa ~/.etc/ssh/id_rsa ,
+.Pa ~/.etc/ssh/id_dsa
 and
-.Pa ~/.ssh/identity .
+.Pa ~/.etc/ssh/identity .
 If the identity has a passphrase,
 .Xr ssh-add 1
 asks for the passphrase (using a small X11 application if running
@@ -142,13 +143,13 @@ The second is that the agent prints the 
 or
 .Xr csh 1
 syntax can be generated) which can be evaluated in the calling shell, eg
-.Cm eval `ssh-agent -s`
+.Cm eval $(ssh-agent -s)
 for Bourne-type shells such as
 .Xr sh 1
 or
 .Xr ksh 1
 and
-.Cm eval `ssh-agent -c`
+.Cm eval $(ssh-agent -c)
 for
 .Xr csh 1
 and derivatives.
@@ -179,11 +180,11 @@ The agent exits automatically when the c
 line terminates.
 .Sh FILES
 .Bl -tag -width Ds
-.It Pa ~/.ssh/identity
+.It Pa ~/.etc/ssh/identity
 Contains the protocol version 1 RSA authentication identity of the user.
-.It Pa ~/.ssh/id_dsa
+.It Pa ~/.etc/ssh/id_dsa
 Contains the protocol version 2 DSA authentication identity of the user.
-.It Pa ~/.ssh/id_rsa
+.It Pa ~/.etc/ssh/id_rsa
 Contains the protocol version 2 RSA authentication identity of the user.
 .It Pa /tmp/ssh-XXXXXXXXXX/agent.\*(Ltppid\*(Gt
 Unix-domain sockets used to contain the connection to the
Index: src/usr.bin/ssh/ssh-agent.c
diff -up src/usr.bin/ssh/ssh-agent.c:1.1.1.14 src/usr.bin/ssh/ssh-agent.c:1.18
--- src/usr.bin/ssh/ssh-agent.c:1.1.1.14	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/ssh-agent.c	Thu Oct 31 21:07:14 2013
@@ -1,6 +1,8 @@
 /* $OpenBSD: ssh-agent.c,v 1.162 2009/09/01 14:43:17 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  * The authentication agent program.
@@ -34,14 +36,12 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/time.h>
 #include <sys/queue.h>
 #include <sys/resource.h>
-#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
-#include <sys/param.h>
 
 #include <openssl/evp.h>
 #include <openssl/md5.h>
@@ -66,6 +66,8 @@
 #include "log.h"
 #include "misc.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.18 2013/10/31 20:07:14 tg Exp $");
+
 #ifdef SMARTCARD
 #include "scard.h"
 #endif
@@ -297,7 +299,6 @@ process_sign_request2(SocketEntry *e)
 {
 	u_char *blob, *data, *signature = NULL;
 	u_int blen, dlen, slen = 0;
-	extern int datafellows;
 	int odatafellows;
 	int ok = -1, flags;
 	Buffer msg;
@@ -981,7 +982,7 @@ cleanup_socket(void)
 		rmdir(socket_dir);
 }
 
-void
+__dead void
 cleanup_exit(int i)
 {
 	cleanup_socket();
@@ -989,8 +990,8 @@ cleanup_exit(int i)
 }
 
 /*ARGSUSED*/
-static void
-cleanup_handler(int sig)
+static __dead void
+cleanup_handler(int sig __attribute__((__unused__)))
 {
 	cleanup_socket();
 	_exit(2);
@@ -1006,7 +1007,7 @@ check_parent_exists(void)
 	}
 }
 
-static void
+static __dead void
 usage(void)
 {
 	fprintf(stderr, "usage: %s [options] [command [arg ...]]\n",
@@ -1027,12 +1028,11 @@ main(int ac, char **av)
 	int c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0;
 	int sock, fd, ch, result, saved_errno;
 	u_int nalloc;
-	char *shell, *format, *pidstr, *agentsocket = NULL;
+	char *shell, *pidstr, *agentsocket = NULL;
+	const char *format;
 	fd_set *readsetp = NULL, *writesetp = NULL;
 	struct sockaddr_un sunaddr;
 	struct rlimit rlim;
-	extern int optind;
-	extern char *optarg;
 	pid_t pid;
 	char pidstrbuf[1 + 3 * sizeof pid];
 	struct timeval *tvp = NULL;
Index: src/usr.bin/ssh/ssh-keygen.1
diff -up src/usr.bin/ssh/ssh-keygen.1:1.1.1.9 src/usr.bin/ssh/ssh-keygen.1:1.13
--- src/usr.bin/ssh/ssh-keygen.1:1.1.1.9	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/ssh-keygen.1	Sat Jan 15 22:52:41 2011
@@ -1,3 +1,4 @@
+.\"	$MirOS: src/usr.bin/ssh/ssh-keygen.1,v 1.13 2011/01/15 21:52:41 tg Exp $
 .\"	$OpenBSD: ssh-keygen.1,v 1.79 2008/07/24 23:55:30 sthen Exp $
 .\"
 .\"  -*- nroff -*-
@@ -133,10 +134,10 @@ section for details.
 Normally each user wishing to use SSH
 with RSA or DSA authentication runs this once to create the authentication
 key in
-.Pa ~/.ssh/identity ,
-.Pa ~/.ssh/id_dsa
+.Pa ~/.etc/ssh/identity ,
+.Pa ~/.etc/ssh/id_dsa
 or
-.Pa ~/.ssh/id_rsa .
+.Pa ~/.etc/ssh/id_rsa .
 Additionally, the system administrator may use this to generate host keys,
 as seen in
 .Pa /etc/rc .
@@ -388,7 +399,7 @@ It is important that this file contains 
 that both ends of a connection share common moduli.
 .Sh FILES
 .Bl -tag -width Ds
-.It Pa ~/.ssh/identity
+.It Pa ~/.etc/ssh/identity
 Contains the protocol version 1 RSA authentication identity of the user.
 This file should not be readable by anyone but the user.
 It is possible to
@@ -399,14 +410,18 @@ This file is not automatically accessed 
 but it is offered as the default file for the private key.
 .Xr ssh 1
 will read this file when a login attempt is made.
-.It Pa ~/.ssh/identity.pub
+.It Pa ~/.etc/ssh/identity.pub
 Contains the protocol version 1 RSA public key for authentication.
 The contents of this file should be added to
-.Pa ~/.ssh/authorized_keys
+.Pa ~/.etc/ssh/authorised_keys
+.Po or Pa ~/.ssh/authorized_keys Pc
 on all machines
 where the user wishes to log in using RSA authentication.
+If the user is the superuser and his home directory the root or unset,
+.Pa /etc/ssh/root:authorised_keys
+is used instead.
 There is no need to keep the contents of this file secret.
-.It Pa ~/.ssh/id_dsa
+.It Pa ~/.etc/ssh/id_dsa
 Contains the protocol version 2 DSA authentication identity of the user.
 This file should not be readable by anyone but the user.
 It is possible to
@@ -417,14 +432,18 @@ This file is not automatically accessed 
 but it is offered as the default file for the private key.
 .Xr ssh 1
 will read this file when a login attempt is made.
-.It Pa ~/.ssh/id_dsa.pub
+.It Pa ~/.etc/ssh/id_dsa.pub
 Contains the protocol version 2 DSA public key for authentication.
 The contents of this file should be added to
-.Pa ~/.ssh/authorized_keys
+.Pa ~/.etc/ssh/authorised_keys
+.Po or Pa ~/.ssh/authorized_keys Pc
 on all machines
 where the user wishes to log in using public key authentication.
+If the user is the superuser and his home directory the root or unset,
+.Pa /etc/ssh/root:authorised_keys
+is used instead.
 There is no need to keep the contents of this file secret.
-.It Pa ~/.ssh/id_rsa
+.It Pa ~/.etc/ssh/id_rsa
 Contains the protocol version 2 RSA authentication identity of the user.
 This file should not be readable by anyone but the user.
 It is possible to
@@ -435,12 +454,16 @@ This file is not automatically accessed 
 but it is offered as the default file for the private key.
 .Xr ssh 1
 will read this file when a login attempt is made.
-.It Pa ~/.ssh/id_rsa.pub
+.It Pa ~/.etc/ssh/id_rsa.pub
 Contains the protocol version 2 RSA public key for authentication.
 The contents of this file should be added to
-.Pa ~/.ssh/authorized_keys
+.Pa ~/.etc/ssh/authorised_keys
+.Po or Pa ~/.ssh/authorized_keys Pc
 on all machines
 where the user wishes to log in using public key authentication.
+If the user is the superuser and his home directory the root or unset,
+.Pa /etc/ssh/root:authorised_keys
+is used instead.
 There is no need to keep the contents of this file secret.
 .It Pa /etc/moduli
 Contains Diffie-Hellman groups used for DH-GEX.
Index: src/usr.bin/ssh/ssh-keygen.c
diff -up src/usr.bin/ssh/ssh-keygen.c:1.1.1.18 src/usr.bin/ssh/ssh-keygen.c:1.24
--- src/usr.bin/ssh/ssh-keygen.c:1.1.1.18	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/ssh-keygen.c	Thu Mar 13 00:19:37 2014
@@ -12,13 +12,13 @@
  * called by a name other than "ssh" or "Secure Shell".
  */
 
-#include <sys/types.h>
+#include <sys/param.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
-#include <sys/param.h>
 
 #include <openssl/evp.h>
 #include <openssl/pem.h>
+#include <openssl/err.h>
 
 #include <errno.h>
 #include <fcntl.h>
@@ -45,6 +45,8 @@
 #include "scard.h"
 #endif
 
+__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.24 2014/03/12 23:19:37 tg Exp $");
+
 /* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
 #define DEFAULT_BITS		2048
 #define DEFAULT_BITS_DSA	1024
@@ -96,7 +98,7 @@ int convert_from_ssh2 = 0;
 int print_public = 0;
 int print_generic = 0;
 
-char *key_type_name = NULL;
+const char *key_type_name = NULL;
 
 /* argv0 */
 extern char *__progname;
@@ -111,12 +117,12 @@ static void
 ask_filename(struct passwd *pw, const char *prompt)
 {
 	char buf[1024];
-	char *name = NULL;
+	const char *name = NULL;
 
 	if (key_type_name == NULL)
 		name = _PATH_SSH_CLIENT_ID_RSA;
 	else {
 		switch (key_type_from_name(key_type_name)) {
 		case KEY_RSA1:
 			name = _PATH_SSH_CLIENT_IDENTITY;
 			break;
@@ -493,7 +580,7 @@ do_download(struct passwd *pw, const cha
 }
 #endif /* SMARTCARD */
 
-static void
+static __dead void
 do_fingerprint(struct passwd *pw)
 {
 	FILE *f;
@@ -628,7 +715,7 @@ print_host(FILE *f, const char *name, Ke
 	}
 }
 
-static void
+static __dead void
 do_known_hosts(struct passwd *pw, const char *name)
 {
 	FILE *in, *out = stdout;
@@ -638,7 +725,12 @@ do_known_hosts(struct passwd *pw, const 
 	int c, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;
 
 	if (!have_identity) {
-		cp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);
+		cp = tilde_expand_filename(
+#ifdef _PATH_SSH_ROOT_HOSTFILE
+		    (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
+		    !pw->pw_dir[1])) ? _PATH_SSH_ROOT_HOSTFILE :
+#endif
+		    _PATH_SSH_USER_HOSTFILE, pw->pw_uid);
 		if (strlcpy(identity_file, cp, sizeof(identity_file)) >=
 		    sizeof(identity_file))
 			fatal("Specified known hosts path too long");
@@ -816,7 +908,7 @@ do_known_hosts(struct passwd *pw, const 
  * Perform changing a passphrase.  The argument is the passwd structure
  * for the current user.
  */
-static void
+static __dead void
 do_change_passphrase(struct passwd *pw)
 {
 	char *comment;
@@ -898,7 +990,8 @@ do_change_passphrase(struct passwd *pw)
  * Print the SSHFP RR.
  */
 static int
-do_print_resource_record(struct passwd *pw, char *fname, char *hname)
+do_print_resource_record(struct passwd *pw, const char *fname,
+    const char *hname)
 {
 	Key *public;
 	char *comment = NULL;
@@ -929,7 +1022,7 @@ do_print_resource_record(struct passwd *
 /*
  * Change the comment of a private key file.
  */
-static void
+static __dead void
 do_change_comment(struct passwd *pw)
 {
 	char new_comment[1024], *comment, *passphrase;
@@ -1022,7 +1115,7 @@ do_change_comment(struct passwd *pw)
 	exit(0);
 }
 
-static void
+static __dead void
 usage(void)
 {
 	fprintf(stderr, "usage: %s [options]\n", __progname);
@@ -1082,9 +1177,6 @@ main(int argc, char **argv)
 	FILE *f;
 	const char *errstr;
 
-	extern int optind;
-	extern char *optarg;
-
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -1103,7 +1195,7 @@ main(int argc, char **argv)
 	}
 
 	while ((opt = getopt(argc, argv,
-	    "degiqpclBHvxXyF:b:f:t:U:D:P:N:C:r:g:R:T:G:M:S:a:W:")) != -1) {
+	    "a:Bb:cC:dD:eF:f:G:gHilM:N:pP:qR:r:S:T:t:U:vW:Xxy")) != -1) {
 		switch (opt) {
 		case 'b':
 			bits = (u_int32_t)strtonum(optarg, 768, 32768, &errstr);
@@ -1361,7 +1463,7 @@ main(int argc, char **argv)
 	if (!have_identity)
 		ask_filename(pw, "Enter file in which to save the key");
 
-	/* Create ~/.ssh directory if it doesn't already exist. */
+	/* Create ~/.etc/ssh directory if it doesn't already exist. */
 	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, _PATH_SSH_USER_DIR);
 	if (strstr(identity_file, dotsshdir) != NULL &&
 	    stat(dotsshdir, &st) < 0) {
Index: src/usr.bin/ssh/ssh-keyscan.c
diff -up src/usr.bin/ssh/ssh-keyscan.c:1.1.1.12 src/usr.bin/ssh/ssh-keyscan.c:1.9
--- src/usr.bin/ssh/ssh-keyscan.c:1.1.1.12	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/ssh-keyscan.c	Sun Mar 22 16:01:21 2009
@@ -8,6 +8,7 @@
  */
 
 #include <sys/types.h>
+#include <sys/time.h>
 #include <sys/socket.h>
 #include <sys/queue.h>
 #include <sys/time.h>
@@ -41,6 +42,8 @@
 #include "misc.h"
 #include "hostfile.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/ssh-keyscan.c,v 1.9 2009/03/22 15:01:21 tg Exp $");
+
 /* Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
    Default value is AF_UNSPEC means both IPv4 and IPv6. */
 int IPv4or6 = AF_UNSPEC;
@@ -315,7 +318,7 @@ keygrab_ssh1(con *c)
 	return (rsa);
 }
 
-static int
+static __dead int
 hostjump(Key *hostkey)
 {
 	kexjmp_key = hostkey;
@@ -695,7 +698,7 @@ fatal(const char *fmt,...)
 		exit(255);
 }
 
-static void
+static __dead void
 usage(void)
 {
 	fprintf(stderr,
@@ -712,9 +715,6 @@ main(int argc, char **argv)
 	int opt, fopt_count = 0;
 	char *tname;
 
-	extern int optind;
-	extern char *optarg;
-
 	TAILQ_INIT(&tq);
 
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
Index: src/usr.bin/ssh/ssh-keysign.c
diff -up src/usr.bin/ssh/ssh-keysign.c:1.1.1.5 src/usr.bin/ssh/ssh-keysign.c:1.7
--- src/usr.bin/ssh/ssh-keysign.c:1.1.1.5	Wed Sep 20 21:06:50 2006
+++ src/usr.bin/ssh/ssh-keysign.c	Thu Mar 13 05:46:47 2014
@@ -50,6 +50,8 @@
 #include "readconf.h"
 #include "uidswap.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/ssh-keysign.c,v 1.7 2014/03/13 04:46:47 tg Exp $");
+
 /* XXX readconf.c needs these */
 uid_t original_real_uid;
 
@@ -141,7 +143,7 @@ valid_request(struct passwd *pw, char *h
 }
 
 int
-main(int argc, char **argv)
+main(void)
 {
 	Buffer b;
 	Options options;
@@ -151,7 +153,6 @@ main(int argc, char **argv)
 	u_char *signature, *data;
 	char *host;
 	u_int slen, dlen;
-	u_int32_t rnd[256];
 
 	/* Ensure that stdin and stdout are connected */
 	if ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)
@@ -177,7 +178,7 @@ main(int argc, char **argv)
 	/* verify that ssh-keysign is enabled by the admin */
 	initialize_options(&options);
 	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options, 0);
-	fill_default_options(&options);
+	fill_default_options(&options, pw);
 	if (options.enable_ssh_keysign != 1)
 		fatal("ssh-keysign not enabled in %s",
 		    _PATH_HOST_CONFIG_FILE);
@@ -186,9 +187,7 @@ main(int argc, char **argv)
 		fatal("could not open any host key");
 
 	SSLeay_add_all_algorithms();
-	for (i = 0; i < 256; i++)
-		rnd[i] = arc4random();
-	RAND_seed(rnd, sizeof(rnd));
+	(void)arc4random();
 
 	found = 0;
 	for (i = 0; i < 2; i++) {
Index: src/usr.bin/ssh/ssh.1
diff -up src/usr.bin/ssh/ssh.1:1.1.1.17 src/usr.bin/ssh/ssh.1:1.29
--- src/usr.bin/ssh/ssh.1:1.1.1.17	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/ssh.1	Sat Jan 15 22:52:42 2011
@@ -34,8 +34,9 @@
 .\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 .\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 .\"
+.\" $MirOS: src/usr.bin/ssh/ssh.1,v 1.29 2011/01/15 21:52:42 tg Exp $
 .\" $OpenBSD: ssh.1,v 1.283 2009/03/19 15:15:09 jmc Exp $
-.Dd $Mdocdate: March 22 2009 $
+.Dd $Mdocdate: January 15 2011 $
 .Dt SSH 1
 .Os
 .Sh NAME
@@ -43,7 +44,7 @@
 .Nd OpenSSH SSH client (remote login program)
 .Sh SYNOPSIS
 .Nm ssh
-.Op Fl 1246AaCfgKkMNnqsTtVvXxYy
+.Op Fl 1246AaCfgMNnqsTtVvXxYy
 .Op Fl b Ar bind_address
 .Op Fl c Ar cipher_spec
 .Oo Fl D\ \&
@@ -185,15 +186,14 @@ that do not support the
 cipher.
 Its use is strongly discouraged due to cryptographic weaknesses.
 The default is
-.Dq 3des .
+.Dq blowfish .
 .Pp
 For protocol version 2,
 .Ar cipher_spec
 is a comma-separated list of ciphers
 listed in order of preference.
-See the
-.Cm Ciphers
-keyword for more information.
+The supported ciphers and default are documented in
+.Xr ssh_config 5 .
 .It Fl D Xo
 .Sm off
 .Oo Ar bind_address : Oc
@@ -259,7 +259,10 @@ the system-wide configuration file
 .Pq Pa /etc/ssh/ssh_config
 will be ignored.
 The default for the per-user configuration file is
-.Pa ~/.ssh/config .
+.Pa ~/.etc/ssh/config .
+If the user is the superuser and his home directory the root or unset,
+.Pa /etc/ssh/root:config
+is used instead.
 .It Fl f
 Requests
 .Nm
@@ -295,11 +298,11 @@ is compiled in (default is no support).
 Selects a file from which the identity (private key) for
 RSA or DSA authentication is read.
 The default is
-.Pa ~/.ssh/identity
+.Pa ~/.etc/ssh/identity
 for protocol version 1, and
-.Pa ~/.ssh/id_rsa
+.Pa ~/.etc/ssh/id_rsa
 and
-.Pa ~/.ssh/id_dsa
+.Pa ~/.etc/ssh/id_dsa
 for protocol version 2.
 Identity files may also be specified on
 a per-host basis in the configuration file.
@@ -307,11 +310,6 @@ It is possible to have multiple
 .Fl i
 options (and multiple identities specified in
 configuration files).
-.It Fl K
-Enables GSSAPI-based authentication and forwarding (delegation) of GSSAPI
-credentials to the server.
-.It Fl k
-Disables forwarding (delegation) of GSSAPI credentials to the server.
 .It Fl L Xo
 .Sm off
 .Oo Ar bind_address : Oc
@@ -450,14 +448,12 @@ For full details of the options listed b
 .It ForwardX11Trusted
 .It GatewayPorts
 .It GlobalKnownHostsFile
-.It GSSAPIAuthentication
-.It GSSAPIDelegateCredentials
 .It HashKnownHosts
 .It Host
 .It HostbasedAuthentication
 .It HostKeyAlgorithms
 .It HostKeyAlias
-.It HostName
+.It Hostname
 .It IdentityFile
 .It IdentitiesOnly
 .It KbdInteractiveDevices
@@ -628,7 +624,7 @@ This can also be specified on a per-host
 .Pp
 X11 forwarding should be enabled with caution.
 Users with the ability to bypass file permissions on the remote host
-(for the user's X authorization database)
+(for the user's X authorisation database)
 can access the local X11 display through the forwarded connection.
 An attacker may then be able to perform activities such as keystroke monitoring.
 .Pp
@@ -682,12 +678,11 @@ Both protocols support similar authentic
 but protocol 2 is preferred since
 it provides additional mechanisms for confidentiality
 (the traffic is encrypted using AES, 3DES, Blowfish, CAST128, or Arcfour)
-and integrity (hmac-md5, hmac-sha1, umac-64, hmac-ripemd160).
+and integrity (umac-64, hmac-ripemd160, hmac-sha1, hmac-md5).
 Protocol 1 lacks a strong mechanism for ensuring the
 integrity of the connection.
 .Pp
 The methods available for authentication are:
-GSSAPI-based authentication,
 host-based authentication,
 public key authentication,
 challenge-response authentication,
@@ -716,7 +711,7 @@ be able to verify the client's
 host key (see the description of
 .Pa /etc/ssh/ssh_known_hosts
 and
-.Pa ~/.ssh/known_hosts ,
+.Pa ~/.etc/ssh/known_hosts ,
 below)
 for login to be permitted.
 This authentication method closes security holes due to IP
@@ -747,7 +742,11 @@ section of
 contains a brief discussion of the two algorithms.
 .Pp
 The file
-.Pa ~/.ssh/authorized_keys
+.Pa ~/.etc/ssh/authorised_keys
+or, if the user is the superuser and his home directory the root or unset,
+.Pa /etc/ssh/root:authorised_keys
+(or, portably,
+.Pa ~/.ssh/authorized_keys )
 lists the public keys that are permitted for logging in.
 When the user logs in, the
 .Nm
@@ -755,33 +754,38 @@ program tells the server which key pair 
 authentication.
 The client proves that it has access to the private key
 and the server checks that the corresponding public key
-is authorized to accept the account.
+is authorised to accept the account.
 .Pp
 The user creates his/her key pair by running
 .Xr ssh-keygen 1 .
 This stores the private key in
-.Pa ~/.ssh/identity
+.Pa ~/.etc/ssh/identity
 (protocol 1),
-.Pa ~/.ssh/id_dsa
+.Pa ~/.etc/ssh/id_dsa
 (protocol 2 DSA),
 or
-.Pa ~/.ssh/id_rsa
+.Pa ~/.etc/ssh/id_rsa
 (protocol 2 RSA)
 and stores the public key in
-.Pa ~/.ssh/identity.pub
+.Pa ~/.etc/ssh/identity.pub
 (protocol 1),
-.Pa ~/.ssh/id_dsa.pub
+.Pa ~/.etc/ssh/id_dsa.pub
 (protocol 2 DSA),
 or
-.Pa ~/.ssh/id_rsa.pub
+.Pa ~/.etc/ssh/id_rsa.pub
 (protocol 2 RSA)
 in the user's home directory.
 The user should then copy the public key
 to
-.Pa ~/.ssh/authorized_keys
+.Pa ~/.etc/ssh/authorised_keys
+(or, portably,
+.Pa ~/.ssh/authorized_keys )
 in his/her home directory on the remote machine.
+If the user is the superuser and his home directory the root or unset,
+/etc/ssh/root:authorised_keys
+is used instead.
 The
-.Pa authorized_keys
+.Pa authorised_keys
 file corresponds to the conventional
 .Pa ~/.rhosts
 file, and has one key
@@ -816,8 +820,10 @@ the password cannot be seen by someone l
 automatically maintains and checks a database containing
 identification for all hosts it has ever been used with.
 Host keys are stored in
-.Pa ~/.ssh/known_hosts
-in the user's home directory.
+.Pa ~/.etc/ssh/known_hosts
+in the user's home directory and
+.Pa /etc/ssh/root:known_hosts
+if the user is the superuser and his home directory the root or unset.
 Additionally, the file
 .Pa /etc/ssh/ssh_known_hosts
 is automatically checked for known hosts.
@@ -1004,7 +1010,7 @@ connections over the encrypted channel.
 .Pp
 .Nm
 will also automatically set up Xauthority data on the server machine.
-For this purpose, it will generate a random authorization cookie,
+For this purpose, it will generate a random authorisation cookie,
 store it in Xauthority on the server, and verify that any forwarded
 connections carry this cookie and replace it by the real cookie when
 the connection is opened.
@@ -1056,7 +1062,7 @@ host key is the same, not guaranteed pro
 To get a listing of the fingerprints along with their random art for
 all known hosts, the following command line can be used:
 .Pp
-.Dl $ ssh-keygen -lv -f ~/.ssh/known_hosts
+.Dl $ ssh-keygen -lv -f ~/.etc/ssh/known_hosts
 .Pp
 If the fingerprint is unknown,
 an alternative method of verification is available:
@@ -1100,6 +1106,9 @@ using the
 .Xr tun 4
 network pseudo-device,
 allowing two networks to be joined securely.
+Use of this option is however, due to the reasons outlined at
+.Pa http://sites.inka.de/sites/bigred/devel/tcp-tcp.html ,
+discouraged in favour of OpenVPN, until datagram transport is added.
 The
 .Xr sshd_config 5
 configuration option
@@ -1127,7 +1136,7 @@ On the server:
 .Ed
 .Pp
 Client access may be more finely tuned via the
-.Pa /root/.ssh/authorized_keys
+.Pa /.etc/ssh/authorised_keys
 file (see below) and the
 .Cm PermitRootLogin
 server option.
@@ -1177,7 +1186,7 @@ The user should normally not set
 .Ev DISPLAY
 explicitly, as that
 will render the X11 connection insecure (and will require the user to
-manually copy any required authorization cookies).
+manually copy any required authorisation cookies).
 .It Ev HOME
 Set to the path of the user's home directory.
 .It Ev LOGNAME
@@ -1243,7 +1252,7 @@ Set to the name of the user logging in.
 Additionally,
 .Nm
 reads
-.Pa ~/.ssh/environment ,
+.Pa ~/.etc/ssh/environment ,
 and adds lines of the format
 .Dq VARNAME=value
 to the environment if the file exists and users are allowed to
@@ -1273,14 +1282,14 @@ This file is used in exactly the same wa
 but allows host-based authentication without permitting login with
 rlogin/rsh.
 .Pp
-.It ~/.ssh/
+.It ~/.etc/ssh/
 This directory is the default location for all user-specific configuration
 and authentication information.
 There is no general requirement to keep the entire contents of this directory
 secret, but the recommended permissions are read/write/execute for the user,
 and not accessible by others.
 .Pp
-.It ~/.ssh/authorized_keys
+.It ~/.etc/ssh/authorised_keys
 Lists the public keys (RSA/DSA) that can be used for logging in as this user.
 The format of this file is described in the
 .Xr sshd 8
@@ -1288,21 +1297,30 @@ manual page.
 This file is not highly sensitive, but the recommended
 permissions are read/write for the user, and not accessible by others.
 .Pp
-.It ~/.ssh/config
+.It /etc/ssh/root:authorised_keys
+The same, for the superuser, if his home is the root directory or unset.
+.Pp
+.It ~/.ssh/authorized_keys
+Portable name for the above file.
+.Pp
+.It ~/.etc/ssh/config
 This is the per-user configuration file.
 The file format and configuration options are described in
 .Xr ssh_config 5 .
 Because of the potential for abuse, this file must have strict permissions:
 read/write for the user, and not accessible by others.
 .Pp
-.It ~/.ssh/environment
+.It /etc/ssh/root:config
+The same, for the superuser, if his home is the root directory or unset.
+.Pp
+.It ~/.etc/ssh/environment
 Contains additional definitions for environment variables; see
 .Sx ENVIRONMENT ,
 above.
 .Pp
-.It ~/.ssh/identity
-.It ~/.ssh/id_dsa
-.It ~/.ssh/id_rsa
+.It ~/.etc/ssh/identity
+.It ~/.etc/ssh/id_dsa
+.It ~/.etc/ssh/id_rsa
 Contains the private key for authentication.
 These files
 contain sensitive data and should be readable by the user but not
@@ -1313,21 +1331,24 @@ It is possible to specify a passphrase w
 generating the key which will be used to encrypt the
 sensitive part of this file using 3DES.
 .Pp
-.It ~/.ssh/identity.pub
-.It ~/.ssh/id_dsa.pub
-.It ~/.ssh/id_rsa.pub
+.It ~/.etc/ssh/identity.pub
+.It ~/.etc/ssh/id_dsa.pub
+.It ~/.etc/ssh/id_rsa.pub
 Contains the public key for authentication.
 These files are not
 sensitive and can (but need not) be readable by anyone.
 .Pp
-.It ~/.ssh/known_hosts
+.It ~/.etc/ssh/known_hosts
 Contains a list of host keys for all hosts the user has logged into
 that are not already in the systemwide list of known host keys.
 See
 .Xr sshd 8
 for further details of the format of this file.
 .Pp
-.It ~/.ssh/rc
+.It /etc/ssh/root:known_hosts
+The same, for the superuser, if his home is the root directory or unset.
+.Pp
+.It ~/.etc/ssh/rc
 Commands in this file are executed by
 .Nm
 when the user logs in, just before the user's shell (or command) is
@@ -1392,15 +1413,15 @@ manual page for more information.
 .Sh SEE ALSO
 .Xr scp 1 ,
 .Xr sftp 1 ,
-.Xr ssh-add 1 ,
-.Xr ssh-agent 1 ,
-.Xr ssh-keygen 1 ,
-.Xr ssh-keyscan 1 ,
+.Xr ssh\-add 1 ,
+.Xr ssh\-agent 1 ,
+.Xr ssh\-keygen 1 ,
+.Xr ssh\-keyscan 1 ,
 .Xr tun 4 ,
 .Xr hosts.equiv 5 ,
 .Xr ssh_config 5 ,
-.Xr ssh-keysign 8 ,
-.Xr sshd 8
+.Xr sshd 8 ,
+.Xr telnet 1
 .Rs
 .%R RFC 4250
 .%T "The Secure Shell (SSH) Protocol Assigned Numbers"
Index: src/usr.bin/ssh/ssh.c
diff -up src/usr.bin/ssh/ssh.c:1.1.1.20 src/usr.bin/ssh/ssh.c:1.30
--- src/usr.bin/ssh/ssh.c:1.1.1.20	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/ssh.c	Thu Oct 31 21:07:14 2013
@@ -1,6 +1,8 @@
 /* $OpenBSD: ssh.c,v 1.326 2009/07/02 02:11:47 dtucker Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  * Ssh client program.  This program can be used to log into a remote machine.
@@ -41,14 +43,13 @@
  */
 
 #include <sys/types.h>
+#include <sys/time.h>
 #include <sys/ioctl.h>
 #include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/resource.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/time.h>
 
 #include <ctype.h>
 #include <errno.h>
@@ -97,6 +98,8 @@
 #include "scard.h"
 #endif
 
+__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.30 2013/10/31 20:07:14 tg Exp $");
+
 extern char *__progname;
 
 /* Flag indicating whether debug mode is on.  May be set on the command line. */
@@ -134,7 +137,7 @@ char *config = NULL;
 
 /*
  * Name of the host we are connecting to.  This is the name given on the
- * command line, or the HostName specified for the user-supplied name in a
+ * command line, or the Hostname specified for the user-supplied name in a
  * configuration file.
  */
 char *host;
@@ -168,11 +171,11 @@ extern u_int muxclient_command;
 
 /* Prints a help message to the user.  This function never returns. */
 
-static void
+static __dead void
 usage(void)
 {
 	fprintf(stderr,
-"usage: ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
+"usage: ssh [-1246AaCfgMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
 "           [-D [bind_address:]port] [-e escape_char] [-F configfile]\n"
 "           [-i identity_file] [-L [bind_address:]port:host:hostport]\n"
 "           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
@@ -186,10 +189,6 @@ static int ssh_session(void);
 static int ssh_session2(void);
 static void load_public_identity_files(void);
 
-/* from muxclient.c */
-void muxclient(const char *);
-void muxserver_listen(void);
-
 /*
  * Main program for the ssh client.
  */
@@ -201,8 +200,6 @@ main(int ac, char **av)
 	struct stat st;
 	struct passwd *pw;
 	int dummy, timeout_ms;
-	extern int optind, optreset;
-	extern char *optarg;
 	struct servent *sp;
 	Forward fwd;
 
@@ -261,7 +258,7 @@ main(int ac, char **av)
 	argv0 = av[0];
 
  again:
-	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
+	while ((opt = getopt(ac, av, "1246ab:c:e:fghi:kl:m:no:p:qstvx"
 	    "ACD:F:I:KL:MNO:PR:S:TVw:XYy")) != -1) {
 		switch (opt) {
 		case '1':
@@ -317,11 +314,7 @@ main(int ac, char **av)
 			options.forward_agent = 1;
 			break;
 		case 'k':
-			options.gss_deleg_creds = 0;
-			break;
 		case 'K':
-			options.gss_authentication = 1;
-			options.gss_deleg_creds = 1;
 			break;
 		case 'i':
 			if (stat(optarg, &st) < 0) {
@@ -412,7 +405,7 @@ main(int ac, char **av)
 				else if (options.cipher == SSH_CIPHER_BLOWFISH)
 					options.ciphers = "blowfish-cbc";
 				else
-					options.ciphers = (char *)-1;
+					options.ciphers = (const char *)-1;
 			}
 			break;
 		case 'm':
@@ -602,8 +597,13 @@ main(int ac, char **av)
 			fatal("Can't open user config file %.100s: "
 			    "%.100s", config, strerror(errno));
 	} else {
-		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
-		    _PATH_SSH_USER_CONFFILE);
+		if (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
+		    !pw->pw_dir[1]))
+			r = snprintf(buf, sizeof(buf), "%s",
+			    _PATH_SSH_ROOT_CONFFILE);
+		else
+			r = snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir,
+			    _PATH_SSH_USER_CONFFILE);
 		if (r > 0 && (size_t)r < sizeof(buf))
 			(void)read_config_file(buf, host, &options, 1);
 
@@ -613,7 +613,7 @@ main(int ac, char **av)
 	}
 
 	/* Fill configuration defaults. */
-	fill_default_options(&options);
+	fill_default_options(&options, pw);
 
 	channel_set_af(options.address_family);
 
@@ -747,8 +747,9 @@ main(int ac, char **av)
 	}
 
 	/*
-	 * Now that we are back to our own permissions, create ~/.ssh
+	 * Now that we are back to our own permissions, create ~/.etc/ssh
 	 * directory if it doesn't already exist.
+	 * XXX create ~/.etc first?
 	 */
 	r = snprintf(buf, sizeof buf, "%s%s%s", pw->pw_dir,
 	    strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
@@ -817,7 +818,8 @@ main(int ac, char **av)
 
 /* Callback for remote forward global requests */
 static void
-ssh_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
+ssh_confirm_remote_forward(int type, u_int32_t seq __attribute__((__unused__)),
+    void *ctxt)
 {
 	Forward *rfwd = (Forward *)ctxt;
 
@@ -931,7 +933,7 @@ ssh_session(void)
 	int interactive = 0;
 	int have_tty = 0;
 	struct winsize ws;
-	char *cp;
+	const char *cp;
 	const char *display;
 
 	/* Enable compression if requested. */
@@ -1087,7 +1089,7 @@ ssh_session(void)
 
 /* request pty/x11/agent/tcpfwd/shell for channel */
 static void
-ssh_session2_setup(int id, void *arg)
+ssh_session2_setup(int id, void *arg __attribute__((__unused__)))
 {
 	extern char **environ;
 	const char *display;
Index: src/usr.bin/ssh/ssh.h
diff -up src/usr.bin/ssh/ssh.h:1.1.1.3 src/usr.bin/ssh/ssh.h:1.4
--- src/usr.bin/ssh/ssh.h:1.1.1.3	Wed Sep 20 21:06:50 2006
+++ src/usr.bin/ssh/ssh.h	Tue Dec 16 21:55:30 2008
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/ssh.h,v 1.4 2008/12/16 20:55:30 tg Exp $ */
 /* $OpenBSD: ssh.h,v 1.78 2006/08/03 03:34:42 deraadt Exp $ */
 
 /*
@@ -28,7 +29,7 @@
 #define SSH_MAX_IDENTITY_FILES		100
 
 /*
- * Maximum length of lines in authorized_keys file.
+ * Maximum length of lines in authorised_keys file.
  * Current value permits 16kbit RSA and RSA1 keys and 8kbit DSA keys, with
  * some room for options and comments.
  */
Index: src/usr.bin/ssh/ssh1.h
diff -up src/usr.bin/ssh/ssh1.h:1.1.1.2 src/usr.bin/ssh/ssh1.h:1.3
--- src/usr.bin/ssh/ssh1.h:1.1.1.2	Wed Apr 19 12:15:05 2006
+++ src/usr.bin/ssh/ssh1.h	Wed Apr 19 12:40:55 2006
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/ssh1.h,v 1.3 2006/04/19 10:40:55 tg Exp $ */
 /* $OpenBSD: ssh1.h,v 1.6 2006/03/25 22:22:43 djm Exp $ */
 
 /*
@@ -64,10 +65,6 @@
 #define SSH_CMSG_AUTH_TIS			39	/* we use this for s/key */
 #define SSH_SMSG_AUTH_TIS_CHALLENGE		40	/* challenge (string) */
 #define SSH_CMSG_AUTH_TIS_RESPONSE		41	/* response (string) */
-#define SSH_CMSG_AUTH_KERBEROS			42	/* (KTEXT) */
-#define SSH_SMSG_AUTH_KERBEROS_RESPONSE		43	/* (KTEXT) */
-#define SSH_CMSG_HAVE_KERBEROS_TGT		44	/* credentials (s) */
-#define SSH_CMSG_HAVE_AFS_TOKEN			65	/* token (s) */
 
 /* protocol version 1.5 overloads some version 1.3 message types */
 #define SSH_MSG_CHANNEL_INPUT_EOF	SSH_MSG_CHANNEL_CLOSE
@@ -82,10 +79,7 @@
 #define SSH_AUTH_PASSWORD	3
 #define SSH_AUTH_RHOSTS_RSA	4
 #define SSH_AUTH_TIS		5
-#define SSH_AUTH_KERBEROS	6
-#define SSH_PASS_KERBEROS_TGT	7
 				/* 8 to 15 are reserved */
-#define SSH_PASS_AFS_TOKEN	21
 
 /* Protocol flags.  These are bit masks. */
 #define SSH_PROTOFLAG_SCREEN_NUMBER	1	/* X11 forwarding includes screen */
Index: src/usr.bin/ssh/ssh2.h
diff -up src/usr.bin/ssh/ssh2.h:1.1.1.3 src/usr.bin/ssh/ssh2.h:1.2
--- src/usr.bin/ssh/ssh2.h:1.1.1.3	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/ssh2.h	Fri Mar 28 23:31:58 2014
@@ -111,12 +111,6 @@
 #define SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ		60
 #define SSH2_MSG_USERAUTH_INFO_REQUEST			60
 #define SSH2_MSG_USERAUTH_INFO_RESPONSE			61
-#define SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP1		60
-#define SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP1		61
-#define SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2		62
-#define SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2		63
-#define SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM		64
-#define SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM		65
 
 /* connection protocol: generic */
 
Index: src/usr.bin/ssh/ssh_config
diff -up src/usr.bin/ssh/ssh_config:1.1.1.7 src/usr.bin/ssh/ssh_config:1.20
--- src/usr.bin/ssh/ssh_config:1.1.1.7	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/ssh_config	Tue Nov 24 22:22:18 2009
@@ -1,4 +1,6 @@
-#	$OpenBSD: ssh_config,v 1.25 2009/02/17 01:28:32 djm Exp $
+# $MirSecuCron$
+# $MirOS: src/usr.bin/ssh/ssh_config,v 1.20 2009/11/24 21:22:18 tg Exp $
+# $OpenBSD: ssh_config,v 1.25 2009/02/17 01:28:32 djm Exp $
 
 # This is the ssh client system-wide configuration file.  See
 # ssh_config(5) for more information.  This file provides defaults for
@@ -13,34 +15,78 @@
 # Thus, host-specific definitions should be at the beginning of the
 # configuration file, and defaults at the end.
 
-# Site-wide defaults for some commonly used options.  For a comprehensive
-# list of available options, their meanings and defaults, please see the
-# ssh_config(5) man page.
+# Site-wide defaults for some ssh_config(5) options.
+
+Host *
+#	AddressFamily any
+#	BatchMode no
+#	BindAddress ...
+#	ChallengeResponseAuthentication yes
+#	CheckHostIP yes
+#	Cipher blowfish
+#	Ciphers aes256-ctr,arcfour256,aes256-cbc,cast128-cbc,aes128-cbc,blowfish-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,arcfour128,arcfour,aes192-cbc,aes192-ctr,3des-cbc
+#	ClearAllForwardings no
+#	Compression no
+#	CompressionLevel 6
+#	ConnectionAttempts 1
+#	ConnectTimeout 0
+#	ControlMaster no
+#	ControlPath none
+#	DynamicForward ...
+#	EnableSSHKeysign no
+#	EscapeChar ~
+#	ExitOnForwardFailure no
+#	ForwardAgent no
+#	ForwardX11 no
+#	ForwardX11Trusted no
+#	GatewayPorts no
+#	GlobalKnownHostsFile /etc/ssh/ssh_known_hosts
+#	HashKnownHosts no
+#	HostKeyAlgorithms ssh-rsa,ssh-dss
+#	HostKeyAlias ...
+#	HostbasedAuthentication no
+#	Hostname ...
+#	IdentitiesOnly no
+#	IdentityFile ~/.etc/ssh/id_dsa
+#	IdentityFile ~/.etc/ssh/id_rsa
+#	IdentityFile ~/.etc/ssh/identity
+#	KbdInteractiveAuthentication yes
+#	KbdInteractiveDevices ...
+#	LocalCommand ...
+#	LocalForward ...
+#	LogLevel INFO
+#	MACs umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96
+#	NoHostAuthenticationForLocalhost no
+#	NumberOfPasswordPrompts 3
+#	PasswordAuthentication yes
+#	PermitLocalCommand no
+#	Port 22
+#	PreferredAuthentications hostbased,publickey,keyboard-interactive,password
+#	Protocol 2,1
+#	ProxyCommand none
+#	PubkeyAuthentication yes
+#	RekeyLimit ...
+#	RemoteForward ...
+#	RhostsRSAAuthentication no
+#	RSAAuthentication yes
+#	SendEnv ...
+#	ServerAliveCountMax 3
+	ServerAliveInterval 200
+#	SmartcardDevice ...
+#	StrictHostKeyChecking ask
+#	TCPKeepAlive yes
+#	Tunnel no
+#	TunnelDevice any:any
+#	UsePrivilegedPort no
+#	User ...
+#	UserKnownHostsFile ~/.etc/ssh/known_hosts
+#	VerifyHostKeyDNS no
+#	VisualHostKey no
+#	XAuthLocation /usr/X11R6/bin/xauth
+
+
+# Add this for session multiplexing (replace 1000 with
+# your UID) at the bottom of the ~/.etc/ssh/config file:
 
 # Host *
-#   ForwardAgent no
-#   ForwardX11 no
-#   RhostsRSAAuthentication no
-#   RSAAuthentication yes
-#   PasswordAuthentication yes
-#   HostbasedAuthentication no
-#   GSSAPIAuthentication no
-#   GSSAPIDelegateCredentials no
-#   BatchMode no
-#   CheckHostIP yes
-#   AddressFamily any
-#   ConnectTimeout 0
-#   StrictHostKeyChecking ask
-#   IdentityFile ~/.ssh/identity
-#   IdentityFile ~/.ssh/id_rsa
-#   IdentityFile ~/.ssh/id_dsa
-#   Port 22
-#   Protocol 2,1
-#   Cipher 3des
-#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
-#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160
-#   EscapeChar ~
-#   Tunnel no
-#   TunnelDevice any:any
-#   PermitLocalCommand no
-#   VisualHostKey no
+#	ControlPath /var/run/ssh-agent/1000/ctl.%r@%h:%p
Index: src/usr.bin/ssh/ssh_config.5
diff -up src/usr.bin/ssh/ssh_config.5:1.1.1.18 src/usr.bin/ssh/ssh_config.5:1.26
--- src/usr.bin/ssh/ssh_config.5:1.1.1.18	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/ssh_config.5	Sat Jan 15 22:52:44 2011
@@ -34,16 +34,18 @@
 .\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 .\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 .\"
+.\" $MirOS: src/usr.bin/ssh/ssh_config.5,v 1.26 2011/01/15 21:52:44 tg Exp $
 .\" $OpenBSD: ssh_config.5,v 1.119 2009/02/22 23:50:57 djm Exp $
-.Dd $Mdocdate: March 22 2009 $
+.Dd $Mdocdate: January 15 2011 $
 .Dt SSH_CONFIG 5
 .Os
 .Sh NAME
 .Nm ssh_config
 .Nd OpenSSH SSH client configuration files
 .Sh SYNOPSIS
-.Nm ~/.ssh/config
+.Nm ~/.etc/ssh/config
 .Nm /etc/ssh/ssh_config
+.Nm /etc/ssh/root:config
 .Sh DESCRIPTION
 .Xr ssh 1
 obtains configuration data from the following sources in
@@ -54,7 +56,9 @@ the following order:
 command-line options
 .It
 user's configuration file
-.Pq Pa ~/.ssh/config
+.Pq Pa ~/.etc/ssh/config
+or, if the user is the superuser and his home directory the root or unset,
+.Pa /etc/ssh/root:config
 .It
 system-wide configuration file
 .Pq Pa /etc/ssh/ssh_config
@@ -183,7 +187,7 @@ that do not support the
 cipher.
 Its use is strongly discouraged due to cryptographic weaknesses.
 The default is
-.Dq 3des .
+.Dq blowfish .
 .It Cm Ciphers
 Specifies the ciphers allowed for protocol version 2
 in order of preference.
@@ -204,9 +208,9 @@ and
 .Dq cast128-cbc .
 The default is:
 .Bd -literal -offset 3n
-aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,
-aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,
-aes256-cbc,arcfour
+aes256-ctr,arcfour256,aes256-cbc,cast128-cbc,aes128-cbc,
+blowfish-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,
+arcfour128,arcfour,aes192-cbc,aes192-ctr,3des-cbc
 .Ed
 .It Cm ClearAllForwardings
 Specifies that all local, remote, and dynamic port forwardings
@@ -426,7 +430,7 @@ The default is
 .Pp
 X11 forwarding should be enabled with caution.
 Users with the ability to bypass file permissions on the remote host
-(for the user's X11 authorization database)
+(for the user's X11 authorisation database)
 can access the local X11 display through the forwarded connection.
 An attacker may then be able to perform activities such as keystroke monitoring
 if the
@@ -473,21 +477,11 @@ The default is
 Specifies a file to use for the global
 host key database instead of
 .Pa /etc/ssh/ssh_known_hosts .
-.It Cm GSSAPIAuthentication
-Specifies whether user authentication based on GSSAPI is allowed.
-The default is
-.Dq no .
-Note that this option applies to protocol version 2 only.
-.It Cm GSSAPIDelegateCredentials
-Forward (delegate) credentials to the server.
-The default is
-.Dq no .
-Note that this option applies to protocol version 2 only.
 .It Cm HashKnownHosts
 Indicates that
 .Xr ssh 1
 should hash host names and addresses when they are added to
-.Pa ~/.ssh/known_hosts .
+.Pa ~/.etc/ssh/known_hosts .
 These hashed names may be used normally by
 .Xr ssh 1
 and
@@ -523,12 +517,12 @@ real host name when looking up or saving
 in the host key database files.
 This option is useful for tunneling SSH connections
 or for multiple servers running on a single host.
-.It Cm HostName
+.It Cm Hostname
 Specifies the real host name to log into.
 This can be used to specify nicknames or abbreviations for hosts.
 The default is the name given on the command line.
 Numeric IP addresses are also permitted (both on the command line and in
-.Cm HostName
+.Cm Hostname
 specifications).
 .It Cm IdentitiesOnly
 Specifies that
@@ -551,11 +545,11 @@ The default is
 Specifies a file from which the user's RSA or DSA authentication identity
 is read.
 The default is
-.Pa ~/.ssh/identity
+.Pa ~/.etc/ssh/identity
 for protocol version 1, and
-.Pa ~/.ssh/id_rsa
+.Pa ~/.etc/ssh/id_rsa
 and
-.Pa ~/.ssh/id_dsa
+.Pa ~/.etc/ssh/id_dsa
 for protocol version 2.
 Additionally, any identities represented by the authentication agent
 will be used for authentication.
@@ -666,8 +660,8 @@ for data integrity protection.
 Multiple algorithms must be comma-separated.
 The default is:
 .Bd -literal -offset indent
-hmac-md5,hmac-sha1,umac-64@openssh.com,
-hmac-ripemd160,hmac-sha1-96,hmac-md5-96
+umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,
+hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96
 .Ed
 .It Cm NoHostAuthenticationForLocalhost
 This option can be used if the home directory is shared across machines.
@@ -715,12 +709,7 @@ This allows a client to prefer one metho
 over another method (e.g.\&
 .Cm password )
 The default for this option is:
-.Do gssapi-with-mic ,
-hostbased,
-publickey,
-keyboard-interactive,
-password
-.Dc .
+.Dq hostbased,publickey,keyboard-interactive,password .
 .It Cm Protocol
 Specifies the protocol versions
 .Xr ssh 1
@@ -754,7 +743,7 @@ server running on some machine, or execu
 .Ic sshd -i
 somewhere.
 Host key management will be done using the
-HostName of the host being connected (defaulting to the name typed by
+Hostname of the host being connected (defaulting to the name typed by
 the user).
 Setting the command to
 .Dq none
@@ -788,7 +777,7 @@ The argument is the number of bytes, wit
 .Sq M ,
 or
 .Sq G
-to indicate Kilobytes, Megabytes, or Gigabytes, respectively.
+to indicate Kibibytes, Mebibytes, or Gibibytes, respectively.
 The default is between
 .Sq 1G
 and
@@ -930,7 +919,7 @@ If this flag is set to
 .Dq yes ,
 .Xr ssh 1
 will never automatically add host keys to the
-.Pa ~/.ssh/known_hosts
+.Pa ~/.etc/ssh/known_hosts
 file, and refuses to connect to hosts whose host key has changed.
 This provides maximum protection against trojan horse attacks,
 though it can be annoying when the
@@ -1039,7 +1028,7 @@ having to remember to give the user name
 .It Cm UserKnownHostsFile
 Specifies a file to use for the user
 host key database instead of
-.Pa ~/.ssh/known_hosts .
+.Pa ~/.etc/ssh/known_hosts .
 .It Cm VerifyHostKeyDNS
 Specifies whether to verify the remote key using DNS and SSHFP resource
 records.
@@ -1119,17 +1108,19 @@ to allow a key to be used from anywhere 
 except from the
 .Dq dialup
 pool,
-the following entry (in authorized_keys) could be used:
+the following entry (in authorised_keys) could be used:
 .Pp
 .Dl from=\&"!*.dialup.example.com,*.example.com\&"
 .Sh FILES
 .Bl -tag -width Ds
-.It Pa ~/.ssh/config
+.It Pa ~/.etc/ssh/config
 This is the per-user configuration file.
 The format of this file is described above.
 This file is used by the SSH client.
 Because of the potential for abuse, this file must have strict permissions:
 read/write for the user, and not accessible by others.
+.It Pa /etc/ssh/root:config
+The same, for the superuser, if his home is the root directory or unset.
 .It Pa /etc/ssh/ssh_config
 Systemwide configuration file.
 This file provides defaults for those
Index: src/usr.bin/ssh/sshconnect.c
diff -up src/usr.bin/ssh/sshconnect.c:1.1.1.17 src/usr.bin/ssh/sshconnect.c:1.18
--- src/usr.bin/ssh/sshconnect.c:1.1.1.17	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sshconnect.c	Thu Jan 14 20:23:04 2016
@@ -47,9 +47,10 @@
 #include "atomicio.h"
 #include "misc.h"
 #include "dns.h"
-#include "roaming.h"
 #include "version.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.18 2016/01/14 19:23:04 tg Exp $");
+
 char *client_version_string = NULL;
 char *server_version_string = NULL;
 
@@ -444,7 +445,7 @@ ssh_exchange_identification(int timeout_
 				}
 			}
 
-			len = roaming_atomicio(read, connection_in, &buf[i], 1);
+			len = atomicio(read, connection_in, &buf[i], 1);
 
 			if (len != 1 && errno == EPIPE)
 				fatal("ssh_exchange_identification: "
@@ -525,12 +526,12 @@ ssh_exchange_identification(int timeout_
 		    (options.protocol & SSH_PROTO_2) ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
 		    remote_major);
 	/* Send our own protocol version identification. */
-	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s",
+	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s %u%s",
 	    compat20 ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
 	    compat20 ? PROTOCOL_MINOR_2 : minor1,
-	    SSH_VERSION, compat20 ? "\r\n" : "\n");
-	if (roaming_atomicio(vwrite, connection_out, buf, strlen(buf))
-	    != strlen(buf))
+	    SSH_VERSION, (unsigned)(arc4random() & 0xFFFF),
+	    compat20 ? "\r\n" : "\n");
+	if (atomicio(vwrite, connection_out, buf, strlen(buf)) != strlen(buf))
 		fatal("write: %.100s", strerror(errno));
 	client_version_string = xstrdup(buf);
 	chop(client_version_string);
@@ -586,6 +587,7 @@ check_host_key(char *hostname, struct so
 	char msg[1024];
 	int len, host_line, ip_line, cancelled_forwarding = 0;
 	const char *host_file = NULL, *ip_file = NULL;
+	struct sockaddr_storage ss;
 
 	/*
 	 * Force accepting of the host key for loopback/localhost. The
@@ -598,12 +600,14 @@ check_host_key(char *hostname, struct so
 	/**  hostaddr == 0! */
 	switch (hostaddr->sa_family) {
 	case AF_INET:
-		local = (ntohl(((struct sockaddr_in *)hostaddr)->
+		memcpy(&ss, hostaddr, sizeof(struct sockaddr_in));
+		local = (ntohl(((struct sockaddr_in *)&ss)->
 		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
 		break;
 	case AF_INET6:
+		memcpy(&ss, hostaddr, sizeof(struct sockaddr_in6));
 		local = IN6_IS_ADDR_LOOPBACK(
-		    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
+		    &(((struct sockaddr_in6 *)&ss)->sin6_addr));
 		break;
 	default:
 		local = 0;
@@ -820,7 +824,7 @@ check_host_key(char *hostname, struct so
 		if (readonly == ROQUIET)
 			goto fail;
 		if (options.check_host_ip && host_ip_differ) {
-			char *key_msg;
+			const char *key_msg;
 			if (ip_status == HOST_NEW)
 				key_msg = "is unknown";
 			else if (ip_status == HOST_OK)
@@ -1140,7 +1144,7 @@ warn_changed_key(Key *host_key)
 int
 ssh_local_cmd(const char *args)
 {
-	char *shell;
+	const char *shell;
 	pid_t pid;
 	int status;
 
Index: src/usr.bin/ssh/sshconnect1.c
diff -up src/usr.bin/ssh/sshconnect1.c:1.1.1.7 src/usr.bin/ssh/sshconnect1.c:1.11
--- src/usr.bin/ssh/sshconnect1.c:1.1.1.7	Thu Nov  9 03:38:02 2006
+++ src/usr.bin/ssh/sshconnect1.c	Thu Mar 13 00:35:12 2014
@@ -17,7 +17,7 @@
 #include <sys/socket.h>
 
 #include <openssl/bn.h>
-#include <openssl/md5.h>
+#include <md5.h>
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -45,6 +45,8 @@
 #include "hostfile.h"
 #include "auth.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sshconnect1.c,v 1.11 2014/03/12 23:35:12 tg Exp $");
+
 /* Session id for the current session. */
 u_char session_id[16];
 u_int supported_authentications = 0;
@@ -176,10 +178,10 @@ respond_to_rsa_challenge(BIGNUM * challe
 
 	memset(buf, 0, sizeof(buf));
 	BN_bn2bin(challenge, buf + sizeof(buf) - len);
-	MD5_Init(&md);
-	MD5_Update(&md, buf, 32);
-	MD5_Update(&md, session_id, 16);
-	MD5_Final(response, &md);
+	MD5Init(&md);
+	MD5Update(&md, buf, 32);
+	MD5Update(&md, session_id, 16);
+	MD5Final(response, &md);
 
 	debug("Sending response to host key RSA challenge.");
 
@@ -480,12 +482,11 @@ ssh_kex(char *host, struct sockaddr *hos
 	BIGNUM *key;
 	Key *host_key, *server_key;
 	int bits, rbits;
-	int ssh_cipher_default = SSH_CIPHER_3DES;
+	int ssh_cipher_default = SSH_CIPHER_BLOWFISH;
 	u_char session_key[SSH_SESSION_KEY_LENGTH];
 	u_char cookie[8];
 	u_int supported_ciphers;
 	u_int server_flags, client_flags;
-	u_int32_t rnd = 0;
 
 	debug("Waiting for server public key.");
 
@@ -540,19 +541,13 @@ ssh_kex(char *host, struct sockaddr *hos
 	derive_ssh1_session_id(host_key->rsa->n, server_key->rsa->n, cookie, session_id);
 
 	/* Generate a session key. */
-	arc4random_stir();
 
 	/*
 	 * Generate an encryption key for the session.   The key is a 256 bit
 	 * random number, interpreted as a 32-byte key, with the least
 	 * significant 8 bits being the first byte of the key.
 	 */
-	for (i = 0; i < 32; i++) {
-		if (i % 4 == 0)
-			rnd = arc4random();
-		session_key[i] = rnd & 0xff;
-		rnd >>= 8;
-	}
+	arc4random_buf(session_key, sizeof(session_key));
 
 	/*
 	 * According to the protocol spec, the first byte of the session key
Index: src/usr.bin/ssh/sshconnect2.c
diff -up src/usr.bin/ssh/sshconnect2.c:1.1.1.13 src/usr.bin/ssh/sshconnect2.c:1.18
--- src/usr.bin/ssh/sshconnect2.c:1.1.1.13	Sun Mar 22 13:03:00 2009
+++ src/usr.bin/ssh/sshconnect2.c	Tue May 15 22:49:59 2018
@@ -62,12 +62,12 @@
 #include "msg.h"
 #include "pathnames.h"
 #include "uidswap.h"
-#include "schnorr.h"
-#include "jpake.h"
 
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
+__RCSID("$MirOS: src/usr.bin/ssh/sshconnect2.c,v 1.18 2018/05/15 20:49:59 tg Exp $");
+
+/* for now */
+extern const EVP_MD *evp_ssh_sha256(void);
+#define EVP_sha256 evp_ssh_sha256
 
 /* import */
 extern char *client_version_string;
@@ -196,7 +196,7 @@ struct Authctxt {
 	void *methoddata;
 };
 struct Authmethod {
-	char	*name;		/* string to compare against server's list */
+	const char *name;	/* string to compare against server's list */
 	int	(*userauth)(Authctxt *authctxt);
 	void	(*cleanup)(Authctxt *authctxt);
 	int	*enabled;	/* flag in option struct that enables method */
@@ -206,31 +206,16 @@ struct Authmethod {
 void	input_userauth_success(int, u_int32_t, void *);
 void	input_userauth_failure(int, u_int32_t, void *);
 void	input_userauth_banner(int, u_int32_t, void *);
-void	input_userauth_error(int, u_int32_t, void *);
+void	input_userauth_error(int, u_int32_t, void *) __dead;
 void	input_userauth_info_req(int, u_int32_t, void *);
 void	input_userauth_pk_ok(int, u_int32_t, void *);
 void	input_userauth_passwd_changereq(int, u_int32_t, void *);
-void	input_userauth_jpake_server_step1(int, u_int32_t, void *);
-void	input_userauth_jpake_server_step2(int, u_int32_t, void *);
-void	input_userauth_jpake_server_confirm(int, u_int32_t, void *);
 
 int	userauth_none(Authctxt *);
 int	userauth_pubkey(Authctxt *);
 int	userauth_passwd(Authctxt *);
 int	userauth_kbdint(Authctxt *);
 int	userauth_hostbased(Authctxt *);
-int	userauth_jpake(Authctxt *);
-
-void	userauth_jpake_cleanup(Authctxt *);
-
-#ifdef GSSAPI
-int	userauth_gssapi(Authctxt *authctxt);
-void	input_gssapi_response(int type, u_int32_t, void *);
-void	input_gssapi_token(int type, u_int32_t, void *);
-void	input_gssapi_hash(int type, u_int32_t, void *);
-void	input_gssapi_error(int, u_int32_t, void *);
-void	input_gssapi_errtok(int, u_int32_t, void *);
-#endif
 
 void	userauth(Authctxt *, char *);
 
@@ -244,13 +229,6 @@ static Authmethod *authmethod_lookup(con
 static char *authmethods_get(void);
 
 Authmethod authmethods[] = {
-#ifdef GSSAPI
-	{"gssapi-with-mic",
-		userauth_gssapi,
-		NULL,
-		&options.gss_authentication,
-		NULL},
-#endif
 	{"hostbased",
 		userauth_hostbased,
 		NULL,
@@ -408,7 +379,7 @@ input_userauth_banner(int type, u_int32_
 		if (len > 65536)
 			len = 65536;
 		msg = xmalloc(len * 4 + 1); /* max expansion from strnvis() */
-		strnvis(msg, raw, len * 4 + 1, VIS_SAFE|VIS_OCTAL);
+		strnvis(msg, raw, len * 4 + 1, VIS_SAFE|VIS_OCTAL|VIS_NOSLASH|VIS_UTF8);
 		fprintf(stderr, "%s", msg);
 		xfree(msg);
 	}
@@ -527,237 +498,6 @@ done:
 		userauth(authctxt, NULL);
 }
 
-#ifdef GSSAPI
-	//…
-#endif /* GSSAPI */
-
 int
 userauth_none(Authctxt *authctxt)
 {
Index: src/usr.bin/ssh/sshd.8
diff -up src/usr.bin/ssh/sshd.8:1.1.1.14 src/usr.bin/ssh/sshd.8:1.20
--- src/usr.bin/ssh/sshd.8:1.1.1.14	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sshd.8	Sat Jan 15 22:52:44 2011
@@ -34,8 +34,9 @@
 .\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 .\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 .\"
+.\" $MirOS: src/usr.bin/ssh/sshd.8,v 1.20 2011/01/15 21:52:44 tg Exp $
 .\" $OpenBSD: sshd.8,v 1.248 2009/03/26 08:38:39 sobrado Exp $
-.Dd $Mdocdate: October 4 2009 $
+.Dd $Mdocdate: January 15 2011 $
 .Dt SSHD 8
 .Os
 .Sh NAME
@@ -166,6 +167,7 @@ and
 for protocol version 2.
 It is possible to have multiple host key files for
 the different protocol versions and host key algorithms.
+.br
 .It Fl i
 Specifies that
 .Nm
@@ -271,6 +273,12 @@ For both protocols,
 each host has a host-specific key,
 normally 2048 bits,
 used to identify the host.
+Much longer RSA keys should be used, but this makes
+logins very slow if less powerful machines are involved.
+DSA keys cannot be longer than 2048 bits due to misdesign, though.
+On
+.Mx ,
+only protocol 2 RSA is enabled by default to improve security.
 .Pp
 Forward security for protocol 1 is provided through
 an additional server key,
@@ -290,7 +298,7 @@ Both sides then use this
 random number as a session key which is used to encrypt all further
 communications in the session.
 The rest of the session is encrypted
-using a conventional cipher, currently Blowfish or 3DES, with 3DES
+using a conventional cipher, currently Blowfish or 3DES, with Blowfish
 being used by default.
 The client selects the encryption algorithm
 to use from those offered by the server.
@@ -304,7 +312,7 @@ The client selects the encryption algori
 to use from those offered by the server.
 Additionally, session integrity is provided
 through a cryptographic message authentication code
-(hmac-md5, hmac-sha1, umac-64 or hmac-ripemd160).
+(umac-64, hmac-ripemd160, hmac-sha1 or hmac-md5).
 .Pp
 Finally, the server and the client enter an authentication dialog.
 The client tries to authenticate itself using
@@ -356,7 +364,7 @@ Changes to run with normal user privileg
 Sets up basic environment.
 .It
 Reads the file
-.Pa ~/.ssh/environment ,
+.Pa ~/.etc/ssh/environment ,
 if it exists, and users are allowed to change their environment.
 See the
 .Cm PermitUserEnvironment
@@ -366,7 +374,7 @@ option in
 Changes to user's home directory.
 .It
 If
-.Pa ~/.ssh/rc
+.Pa ~/.etc/ssh/rc
 exists, runs it; else if
 .Pa /etc/ssh/sshrc
 exists, runs
@@ -383,7 +391,7 @@ Runs user's shell or command.
 .El
 .Sh SSHRC
 If the file
-.Pa ~/.ssh/rc
+.Pa ~/.etc/ssh/rc
 exists,
 .Xr sh 1
 runs it after reading the
@@ -423,12 +431,15 @@ If this file does not exist,
 .Pa /etc/ssh/sshrc
 is run, and if that
 does not exist either, xauth is used to add the cookie.
-.Sh AUTHORIZED_KEYS FILE FORMAT
-.Cm AuthorizedKeysFile
+.Sh AUTHORISED_KEYS FILE FORMAT
+.Cm AuthorisedKeysFile
 specifies the file containing public keys for
 public key authentication;
 if none is specified, the default is
-.Pa ~/.ssh/authorized_keys .
+.Pa ~/.etc/ssh/authorised_keys .
+If the user is the superuser and his home directory the root or unset,
+/etc/ssh/root:authorised_keys
+is used instead.
 Each line of the file contains one
 key (empty lines and lines starting with a
 .Ql #
@@ -538,13 +549,13 @@ option.
 Prevents tty allocation (a request to allocate a pty will fail).
 .It Cm no-user-rc
 Disables execution of
-.Pa ~/.ssh/rc .
+.Pa ~/.etc/ssh/rc .
 .It Cm no-X11-forwarding
 Forbids X11 forwarding when this key is used for authentication.
 Any X11 forward requests by the client will return an error.
 .It Cm permitopen="host:port"
 Limit local
-.Li ``ssh -L''
+.Li "ssh -L"
 port forwarding such that it may only connect to the specified host and
 port.
 IPv6 addresses can be specified with an alternative syntax:
@@ -562,7 +573,7 @@ Without this option, the next available 
 the client requests a tunnel.
 .El
 .Pp
-An example authorized_keys file:
+An example authorised_keys file:
 .Bd -literal -offset 3n
 # Comments allowed at start of line
 ssh-rsa AAAAB3Nza...LiPk== user@example.net
@@ -579,7 +590,10 @@ jane@example.net
 The
 .Pa /etc/ssh/ssh_known_hosts
 and
-.Pa ~/.ssh/known_hosts
+.Pa ~/.etc/ssh/known_hosts
+and
+.Pa /etc/ssh/root:known_hosts ,
+if the user is the superuser and his home directory the root or unset,
 files contain host public keys for all known hosts.
 The global file should
 be prepared by the administrator (optional), and the per-user file is
@@ -690,23 +704,22 @@ This file is used in exactly the same wa
 but allows host-based authentication without permitting login with
 rlogin/rsh.
 .Pp
-.It ~/.ssh/
+.It ~/.etc/ssh/
 This directory is the default location for all user-specific configuration
 and authentication information.
 There is no general requirement to keep the entire contents of this directory
 secret, but the recommended permissions are read/write/execute for the user,
 and not accessible by others.
 .Pp
-.It ~/.ssh/authorized_keys
+.It ~/.etc/ssh/authorised_keys
 Lists the public keys (RSA/DSA) that can be used for logging in as this user.
 The format of this file is described above.
 The content of the file is not highly sensitive, but the recommended
 permissions are read/write for the user, and not accessible by others.
-.Pp
 If this file, the
-.Pa ~/.ssh
+.Pa ~/.etc/ssh
 directory, or the user's home directory are writable
-by other users, then the file could be modified or replaced by unauthorized
+by other users, then the file could be modified or replaced by unauthorised
 users.
 In this case,
 .Nm
@@ -715,7 +728,13 @@ will not allow it to be used unless the
 option has been set to
 .Dq no .
 .Pp
-.It ~/.ssh/environment
+.It /etc/ssh/root:authorised_keys
+The same, for the superuser, if his home is the root directory or unset.
+.Pp
+.It ~/.ssh/authorized_keys
+Portable name for the above file.
+.Pp
+.It ~/.etc/ssh/environment
 This file is read into the environment at login (if it exists).
 It can only contain empty lines, comment lines (that start with
 .Ql # ) ,
@@ -727,14 +746,17 @@ controlled via the
 .Cm PermitUserEnvironment
 option.
 .Pp
-.It ~/.ssh/known_hosts
+.It ~/.etc/ssh/known_hosts
 Contains a list of host keys for all hosts the user has logged into
 that are not already in the systemwide list of known host keys.
 The format of this file is described above.
 This file should be writable only by root/the owner and
 can, but need not be, world-readable.
 .Pp
-.It ~/.ssh/rc
+.It /etc/ssh/root:known_hosts
+The same, for the superuser, if his home is the root directory or unset.
+.Pp
+.It ~/.etc/ssh/rc
 Contains initialization routines to be run before
 the user's home directory becomes accessible.
 This file should be writable only by the user, and need not be
@@ -815,7 +837,7 @@ The file format and configuration option
 .Pp
 .It /etc/ssh/sshrc
 Similar to
-.Pa ~/.ssh/rc ,
+.Pa ~/.etc/ssh/rc ,
 it can be used to specify
 machine-specific login-time initializations globally.
 This file should be writable only by root, and should be world-readable.
Index: src/usr.bin/ssh/sshd.c
diff -up src/usr.bin/ssh/sshd.c:1.1.1.16 src/usr.bin/ssh/sshd.c:1.24
--- src/usr.bin/ssh/sshd.c:1.1.1.16	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sshd.c	Thu May  3 03:32:46 2018
@@ -64,7 +64,7 @@
 
 #include <openssl/dh.h>
 #include <openssl/bn.h>
-#include <openssl/md5.h>
+#include <md5.h>
 #include <openssl/rand.h>
 
 #include "xmalloc.h"
@@ -97,19 +97,10 @@
 #include "session.h"
 #include "monitor_mm.h"
 #include "monitor.h"
-#ifdef GSSAPI
-#include "ssh-gss.h"
-#endif
 #include "monitor_wrap.h"
-#include "roaming.h"
 #include "version.h"
 
-#ifdef LIBWRAP
-#include <tcpd.h>
-#include <syslog.h>
-int allow_severity = LOG_INFO;
-int deny_severity = LOG_WARNING;
-#endif /* LIBWRAP */
+__RCSID("$MirOS: src/usr.bin/ssh/sshd.c,v 1.24 2018/05/03 01:32:46 tg Exp $");
 
 #ifndef O_NOCTTY
 #define O_NOCTTY	0
@@ -127,7 +118,7 @@ extern char *__progname;
 ServerOptions options;
 
 /* Name of the server configuration file. */
-char *config_file_name = _PATH_SERVER_CONFIG_FILE;
+const char *config_file_name = _PATH_SERVER_CONFIG_FILE;
 
 /*
  * Debug mode flag.  This can be set on the command line.  If debug
@@ -329,7 +320,7 @@ main_sigchld_handler(int sig)
  * Signal handler for the alarm after the login grace period has expired.
  */
 /*ARGSUSED*/
-static void
+static __dead void
 grace_alarm_handler(int sig)
 {
 	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
@@ -358,7 +349,6 @@ generate_ephemeral_server_key(void)
 	verbose("RSA key generation complete.");
 
 	arc4random_buf(sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
-	arc4random_stir();
 }
 
 /*ARGSUSED*/
@@ -379,7 +369,7 @@ sshd_exchange_identification(int sock_in
 	int mismatch;
 	int remote_major, remote_minor;
 	int major, minor;
-	char *s, *newline = "\n";
+	const char *s, *newline = "\n";
 	char buf[256];			/* Must not be larger than remote_version. */
 	char remote_version[256];	/* Must be at least as big as buf. */
 
@@ -395,12 +385,12 @@ sshd_exchange_identification(int sock_in
 		major = PROTOCOL_MAJOR_1;
 		minor = PROTOCOL_MINOR_1;
 	}
-	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s", major, minor,
-	    SSH_VERSION, newline);
+	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s %u%s", major, minor,
+	    SSH_VERSION, (unsigned)(arc4random() & 0xFFFF), newline);
 	server_version_string = xstrdup(buf);
 
 	/* Send our protocol version identification. */
-	if (roaming_atomicio(vwrite, sock_out, server_version_string,
+	if (atomicio(vwrite, sock_out, server_version_string,
 	    strlen(server_version_string))
 	    != strlen(server_version_string)) {
 		logit("Could not write ident string to %s", get_remote_ipaddr());
@@ -410,7 +400,7 @@ sshd_exchange_identification(int sock_in
 	/* Read other sides version identification. */
 	memset(buf, 0, sizeof(buf));
 	for (i = 0; i < sizeof(buf) - 1; i++) {
-		if (roaming_atomicio(read, sock_in, &buf[i], 1) != 1) {
+		if (atomicio(read, sock_in, &buf[i], 1) != 1) {
 			logit("Did not receive identification string from %s",
 			    get_remote_ipaddr());
 			cleanup_exit(255);
@@ -438,7 +428,7 @@ sshd_exchange_identification(int sock_in
 	if (sscanf(client_version_string, "SSH-%d.%d-%[^\n]\n",
 	    &remote_major, &remote_minor, remote_version) != 3) {
 		s = "Protocol mismatch.\n";
-		(void) atomicio(vwrite, sock_out, s, strlen(s));
+		(void) atomicio(vwrite, sock_out, (char *)s, strlen(s));
 		close(sock_in);
 		close(sock_out);
 		logit("Bad protocol version identification '%.100s' from %s",
@@ -499,7 +489,7 @@ sshd_exchange_identification(int sock_in
 
 	if (mismatch) {
 		s = "Protocol major versions differ.\n";
-		(void) atomicio(vwrite, sock_out, s, strlen(s));
+		(void) atomicio(vwrite, sock_out, (char *)s, strlen(s));
 		close(sock_in);
 		close(sock_out);
 		logit("Protocol major versions differ for %s: %.200s vs. %.200s",
@@ -558,16 +548,13 @@ demote_sensitive_data(void)
 static void
 privsep_preauth_child(void)
 {
-	u_int32_t rnd[256];
 	gid_t gidset[1];
 	struct passwd *pw;
 
 	/* Enable challenge-response authentication for privilege separation */
 	privsep_challenge_enable();
 
-	arc4random_stir();
-	arc4random_buf(rnd, sizeof(rnd));
-	RAND_seed(rnd, sizeof(rnd));
+	(void)arc4random();
 
 	/* Demote the private keys to public keys. */
 	demote_sensitive_data();
@@ -645,8 +632,6 @@ privsep_preauth(Authctxt *authctxt)
 static void
 privsep_postauth(Authctxt *authctxt)
 {
-	u_int32_t rnd[256];
-
 	if (authctxt->pw->pw_uid == 0 || options.use_login) {
 		/* File descriptor passing is broken or root login */
 		use_privsep = 0;
@@ -674,9 +659,7 @@ privsep_postauth(Authctxt *authctxt)
 	/* Demote the private keys to public keys. */
 	demote_sensitive_data();
 
-	arc4random_stir();
-	arc4random_buf(rnd, sizeof(rnd));
-	RAND_seed(rnd, sizeof(rnd));
+	(void)arc4random();
 
 	/* Drop privileges */
 	do_setusercontext(authctxt->pw);
@@ -1129,6 +1112,11 @@ server_accept_loop(int *sock_in, int *so
 			 */
 			if ((pid = fork()) == 0) {
 				/*
+				 * Ensure that our random state differs
+				 * from that of the parent.
+				 */
+				(void)arc4random();
+				/*
 				 * Child.  Close the listening and
 				 * max_startup sockets.  Start using
 				 * the accepted socket. Reinitialize
@@ -1180,9 +1168,9 @@ server_accept_loop(int *sock_in, int *so
 
 			/*
 			 * Ensure that our random state differs
-			 * from that of the child
+			 * from that of the child.
 			 */
-			arc4random_stir();
+			(void)arc4random();
 		}
 
 		/* child process check (or debug mode) */
@@ -1198,8 +1186,6 @@ server_accept_loop(int *sock_in, int *so
 int
 main(int ac, char **av)
 {
-	extern char *optarg;
-	extern int optind;
 	int opt, i, on = 1;
 	int sock_in = -1, sock_out = -1, newsock = -1;
 	const char *remote_ip;
@@ -1539,11 +1527,12 @@ main(int ac, char **av)
 			close(fd);
 		}
 	}
-	/* Reinitialize the log (because of the fork above). */
-	log_init(__progname, options.log_level, options.log_facility, log_stderr);
 
 	/* Initialize the random number generator. */
-	arc4random_stir();
+	(void)arc4random();
+
+	/* Reinitialize the log (because of the fork above). */
+	log_init(__progname, options.log_level, options.log_facility, log_stderr);
 
 	/* Chdir to the root directory so that the current disk can be
 	   unmounted if desired. */
@@ -1679,23 +1668,6 @@ main(int ac, char **av)
 	 */
 	remote_ip = get_remote_ipaddr();
 
-#ifdef LIBWRAP
-	/* Check whether logins are denied from this host. */
-	if (packet_connection_is_on_socket()) {
-		struct request_info req;
-
-		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, 0);
-		fromhost(&req);
-
-		if (!hosts_access(&req)) {
-			debug("Connection refused by tcp wrapper");
-			refuse(&req);
-			/* NOTREACHED */
-			fatal("libwrap refuse returns");
-		}
-	}
-#endif /* LIBWRAP */
-
 	/* Log the connection. */
 	verbose("Connection from %.500s port %d", remote_ip, remote_port);
 
@@ -1978,15 +1950,15 @@ do_ssh1_kex(void)
 
 		logit("do_connection: generating a fake encryption key");
 		BN_bn2bin(session_key_int, buf);
-		MD5_Init(&md);
-		MD5_Update(&md, buf, bytes);
-		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
-		MD5_Final(session_key, &md);
-		MD5_Init(&md);
-		MD5_Update(&md, session_key, 16);
-		MD5_Update(&md, buf, bytes);
-		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
-		MD5_Final(session_key + 16, &md);
+		MD5Init(&md);
+		MD5Update(&md, buf, bytes);
+		MD5Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
+		MD5Final(session_key, &md);
+		MD5Init(&md);
+		MD5Update(&md, session_key, 16);
+		MD5Update(&md, buf, bytes);
+		MD5Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
+		MD5Final(session_key + 16, &md);
 		memset(buf, 0, bytes);
 		xfree(buf);
 		for (i = 0; i < 16; i++)
Index: src/usr.bin/ssh/sshd_config
diff -up src/usr.bin/ssh/sshd_config:1.1.1.9 src/usr.bin/ssh/sshd_config:1.24
--- src/usr.bin/ssh/sshd_config:1.1.1.9	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/sshd_config	Thu May  3 03:32:47 2018
@@ -1,4 +1,6 @@
-#	$OpenBSD: sshd_config,v 1.80 2008/07/02 02:24:18 djm Exp $
+# $MirSecuCron$
+# $MirOS: src/usr.bin/ssh/sshd_config,v 1.24 2018/05/03 01:32:47 tg Exp $
+# $OpenBSD: sshd_config,v 1.80 2008/07/02 02:24:18 djm Exp $
 
 # This is the sshd server system-wide configuration file.  See
 # sshd_config(5) for more information.
@@ -12,6 +14,9 @@
 #AddressFamily any
 #ListenAddress 0.0.0.0
 #ListenAddress ::
+#Cipher blowfish
+#Ciphers aes256-ctr,arcfour256,aes256-cbc,cast128-cbc,aes128-cbc,blowfish-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,arcfour128,arcfour,aes192-cbc,aes192-ctr,3des-cbc
+#MACs umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96
 
 # Disable legacy (protocol version 1) support in the server for new
 # installations. In future the default will change to require explicit
@@ -21,7 +26,7 @@ Protocol 2
 # HostKey for protocol version 1
 #HostKey /etc/ssh/ssh_host_key
 # HostKeys for protocol version 2
-#HostKey /etc/ssh/ssh_host_rsa_key
+HostKey /etc/ssh/ssh_host_rsa_key
 #HostKey /etc/ssh/ssh_host_dsa_key
 
 # Lifetime and size of ephemeral version 1 server key
@@ -36,20 +41,20 @@ Protocol 2
 # Authentication:
 
 #LoginGraceTime 2m
-#PermitRootLogin yes
+#PermitRootLogin no
 #StrictModes yes
 #MaxAuthTries 6
 #MaxSessions 10
 
 #RSAAuthentication yes
 #PubkeyAuthentication yes
-#AuthorizedKeysFile	.ssh/authorized_keys
+#AuthorisedKeysFile	.etc/ssh/authorised_keys
 
 # For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
 #RhostsRSAAuthentication no
 # similar for protocol version 2
 #HostbasedAuthentication no
-# Change to yes if you don't trust ~/.ssh/known_hosts for
+# Change to yes if you don't trust ~/.etc/ssh/known_hosts for
 # RhostsRSAAuthentication and HostbasedAuthentication
 #IgnoreUserKnownHosts no
 # Don't read the user's ~/.rhosts and ~/.shosts files
@@ -62,18 +67,8 @@ Protocol 2
 # Change to no to disable s/key passwords
 #ChallengeResponseAuthentication yes
 
-# Kerberos options
-#KerberosAuthentication no
-#KerberosOrLocalPasswd yes
-#KerberosTicketCleanup yes
-#KerberosGetAFSToken no
-
-# GSSAPI options
-#GSSAPIAuthentication no
-#GSSAPICleanupCredentials yes
-
 #AllowAgentForwarding yes
-#AllowTcpForwarding yes
+AllowTcpForwarding no
 #GatewayPorts no
 #X11Forwarding no
 #X11DisplayOffset 10
@@ -85,22 +80,25 @@ Protocol 2
 #UsePrivilegeSeparation yes
 #PermitUserEnvironment no
 #Compression delayed
-#ClientAliveInterval 0
+ClientAliveInterval 200
 #ClientAliveCountMax 3
 #UseDNS yes
 #PidFile /var/run/sshd.pid
-#MaxStartups 10
+MaxStartups 10:30:100
 #PermitTunnel no
 #ChrootDirectory none
 
 # no default banner path
 #Banner none
 
-# override default of no subsystems
+# override default of no subsystems to enable use of SFTP:
 Subsystem	sftp	/usr/libexec/sftp-server
 
Index: src/usr.bin/ssh/sshd_config.5
diff -up src/usr.bin/ssh/sshd_config.5:1.1.1.18 src/usr.bin/ssh/sshd_config.5:1.29
--- src/usr.bin/ssh/sshd_config.5:1.1.1.18	Sun Oct  4 15:25:45 2009
+++ src/usr.bin/ssh/sshd_config.5	Thu May  3 03:32:47 2018
@@ -34,8 +34,9 @@
 .\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 .\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 .\"
+.\" $MirOS: src/usr.bin/ssh/sshd_config.5,v 1.29 2018/05/03 01:32:47 tg Exp $
 .\" $OpenBSD: sshd_config.5,v 1.107 2009/08/16 23:29:26 dtucker Exp $
-.Dd $Mdocdate: October 4 2009 $
+.Dd $Mdocdate: May 3 2018 $
 .Dt SSHD_CONFIG 5
 .Os
 .Sh NAME
@@ -152,21 +153,31 @@ See
 in
 .Xr ssh_config 5
 for more information on patterns.
-.It Cm AuthorizedKeysFile
+.It Cm AuthorisedKeysFile
 Specifies the file that contains the public keys that can be used
 for user authentication.
-.Cm AuthorizedKeysFile
+.Cm AuthorisedKeysFile
 may contain tokens of the form %T which are substituted during connection
 setup.
 The following tokens are defined: %% is replaced by a literal '%',
 %h is replaced by the home directory of the user being authenticated, and
 %u is replaced by the username of that user.
 After expansion,
-.Cm AuthorizedKeysFile
+.Cm AuthorisedKeysFile
 is taken to be an absolute path or one relative to the user's home
 directory.
 The default is
-.Dq .ssh/authorized_keys .
+.Dq .etc/ssh/authorised_keys .
+.It Cm AuthorisedKeysFile2
+Only used for backward compatibility with stock
+.Ox
+OpenSSH.
+This option is deprecated.
+The default is
+.Dq .ssh/authorized_keys
+if
+.Cm AuthorisedKeysFile
+if unset, its value otherwise.
 .It Cm Banner
 The contents of the specified file are sent to the remote user before
 authentication is allowed.
@@ -246,9 +257,9 @@ and
 .Dq cast128-cbc .
 The default is:
 .Bd -literal -offset 3n
-aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,
-aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,
-aes256-cbc,arcfour
+aes256-ctr,arcfour256,aes256-cbc,cast128-cbc,aes128-cbc,
+blowfish-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,
+arcfour128,arcfour,aes192-cbc,aes192-ctr,3des-cbc
 .Ed
 .It Cm ClientAliveCountMax
 Sets the number of client alive messages (see below) which may be
@@ -340,7 +351,7 @@ for more information on patterns.
 Forces the execution of the command specified by
 .Cm ForceCommand ,
 ignoring any command supplied by the client and
-.Pa ~/.ssh/rc
+.Pa ~/.etc/ssh/rc
 if present.
 The command is invoked by using the user's login shell with the -c option.
 This applies to shell, command, or subsystem execution.
@@ -375,17 +386,6 @@ to force remote port forwardings to bind
 to allow the client to select the address to which the forwarding is bound.
 The default is
 .Dq no .
-.It Cm GSSAPIAuthentication
-Specifies whether user authentication based on GSSAPI is allowed.
-The default is
-.Dq no .
-Note that this option applies to protocol version 2 only.
-.It Cm GSSAPICleanupCredentials
-Specifies whether to automatically destroy the user's credentials cache
-on logout.
-The default is
-.Dq yes .
-Note that this option applies to protocol version 2 only.
 .It Cm HostbasedAuthentication
 Specifies whether rhosts or /etc/hosts.equiv authentication together
 with successful public key client host authentication is allowed
@@ -415,13 +415,16 @@ The default is
 .It Cm HostKey
 Specifies a file containing a private host key
 used by SSH.
-The default is
+The default (if they are all commented out) is
 .Pa /etc/ssh/ssh_host_key
 for protocol version 1, and
 .Pa /etc/ssh/ssh_host_rsa_key
 and
 .Pa /etc/ssh/ssh_host_dsa_key
 for protocol version 2.
+Starting with
+.Mx 8 ,
+the shipped version only checks for the RSAv2 key.
 Note that
 .Xr sshd 8
 will refuse to use a file if it is group/world-accessible.
@@ -452,38 +455,13 @@ The default is
 Specifies whether
 .Xr sshd 8
 should ignore the user's
-.Pa ~/.ssh/known_hosts
+.Pa ~/.etc/ssh/known_hosts
 during
 .Cm RhostsRSAAuthentication
 or
 .Cm HostbasedAuthentication .
 The default is
 .Dq no .
-.It Cm KerberosAuthentication
-Specifies whether the password provided by the user for
-.Cm PasswordAuthentication
-will be validated through the Kerberos KDC.
-To use this option, the server needs a
-Kerberos servtab which allows the verification of the KDC's identity.
-The default is
-.Dq no .
-.It Cm KerberosGetAFSToken
-If AFS is active and the user has a Kerberos 5 TGT, attempt to acquire
-an AFS token before accessing the user's home directory.
-The default is
-.Dq no .
-.It Cm KerberosOrLocalPasswd
-If password authentication through Kerberos fails then
-the password will be validated via any additional local mechanism
-such as
-.Pa /etc/passwd .
-The default is
-.Dq yes .
-.It Cm KerberosTicketCleanup
-Specifies whether to automatically destroy the user's ticket cache
-file on logout.
-The default is
-.Dq yes .
 .It Cm KeyRegenerationInterval
 In protocol version 1, the ephemeral server key is automatically regenerated
 after this many seconds (if it has been used).
@@ -552,9 +530,17 @@ for data integrity protection.
 Multiple algorithms must be comma-separated.
 The default is:
 .Bd -literal -offset indent
-hmac-md5,hmac-sha1,umac-64@openssh.com,
-hmac-ripemd160,hmac-sha1-96,hmac-md5-96
+umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,
+hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96
 .Ed
@@ -701,7 +688,7 @@ The argument must be
 or
 .Dq no .
 The default is
-.Dq yes .
+.Dq no .
 .Pp
 If this option is set to
 .Dq without-password ,
@@ -739,13 +726,15 @@ and
 .Dq ethernet .
 The default is
 .Dq no .
+Use of this option is discouraged in favour of OpenVPN until
+datagram transport is added.
 .It Cm PermitUserEnvironment
 Specifies whether
-.Pa ~/.ssh/environment
+.Pa ~/.etc/ssh/environment
 and
 .Cm environment=
 options in
-.Pa ~/.ssh/authorized_keys
+.Pa ~/.etc/ssh/authorised_keys
 are processed by
 .Xr sshd 8 .
 The default is
@@ -851,6 +840,7 @@ This may simplify configurations using
 to force a different filesystem root on clients.
 .Pp
 By default no subsystems are defined.
+The default configuration file enables the SFTP daemon.
 Note that this option applies to protocol version 2 only.
 .It Cm SyslogFacility
 Gives the facility code that is used when logging messages from
Index: src/usr.bin/ssh/sshlogin.c
diff -up src/usr.bin/ssh/sshlogin.c:1.1.1.4 src/usr.bin/ssh/sshlogin.c:1.7
--- src/usr.bin/ssh/sshlogin.c:1.1.1.4	Thu Sep 13 15:39:10 2007
+++ src/usr.bin/ssh/sshlogin.c	Thu Oct 31 21:07:15 2013
@@ -1,6 +1,8 @@
 /* $OpenBSD: sshlogin.c,v 1.26 2007/09/11 15:47:17 gilles Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  * This file performs some of the things login(1) normally does.  We cannot
@@ -39,7 +41,6 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 
@@ -58,20 +59,28 @@
 #include "buffer.h"
 #include "servconf.h"
 
+__RCSID("$MirOS: src/usr.bin/ssh/sshlogin.c,v 1.7 2013/10/31 20:07:15 tg Exp $");
+
 extern Buffer loginmsg;
 extern ServerOptions options;
 
+#ifdef SMALL
+#define usmall	__attribute__((__unused__))
+#else
+#define usmall	/* nothing */
+static time_t get_last_login_time(uid_t, const char *, char *, size_t);
+
 /*
  * Returns the time when the user last logged in.  Returns 0 if the
  * information is not available.  This must be called before record_login.
  * The host the user logged in from will be returned in buf.
  */
-time_t
-get_last_login_time(uid_t uid, const char *logname,
+static time_t
+get_last_login_time(uid_t uid, const char *logname __attribute__((__unused__)),
     char *buf, size_t bufsize)
 {
 	struct lastlog ll;
-	char *lastlog;
+	const char *lastlog;
 	int fd;
 	off_t pos, r;
 
@@ -132,18 +141,22 @@ store_lastlog_message(const char *user, 
 		buffer_append(&loginmsg, buf, strlen(buf));
 	}
 }
+#endif
 
 /*
  * Records that the user has logged in.  I wish these parts of operating
  * systems were more standardized.
  */
 void
-record_login(pid_t pid, const char *tty, const char *user, uid_t uid,
-    const char *host, struct sockaddr *addr, socklen_t addrlen)
+record_login(pid_t pid __attribute__((__unused__)), const char *tty usmall,
+    const char *user usmall, uid_t uid usmall, const char *host usmall,
+    struct sockaddr *addr __attribute__((__unused__)),
+    socklen_t addrlen __attribute__((__unused__)))
 {
+#ifndef SMALL
 	int fd;
 	struct lastlog ll;
-	char *lastlog;
+	const char *lastlog;
 	struct utmp u;
 
 	/* save previous login details before writing new */
@@ -179,13 +192,16 @@ record_login(pid_t pid, const char *tty,
 			close(fd);
 		}
 	}
+#endif
 }
 
 /* Records that the user has logged out. */
 void
-record_logout(pid_t pid, const char *tty)
+record_logout(pid_t pid __attribute__((__unused__)), const char *tty usmall)
 {
+#ifndef SMALL
 	const char *line = tty + 5;	/* /dev/ttyq8 -> ttyq8 */
 	if (logout(line))
 		logwtmp(line, "", "");
+#endif
 }
Index: src/usr.bin/ssh/sshlogin.h
diff -up src/usr.bin/ssh/sshlogin.h:1.1.1.3 src/usr.bin/ssh/sshlogin.h:1.3
--- src/usr.bin/ssh/sshlogin.h:1.1.1.3	Wed Sep 20 21:06:50 2006
+++ src/usr.bin/ssh/sshlogin.h	Tue Dec 16 21:55:33 2008
@@ -1,3 +1,4 @@
+/* $MirOS: src/usr.bin/ssh/sshlogin.h,v 1.3 2008/12/16 20:55:33 tg Exp $ */
 /* $OpenBSD: sshlogin.h,v 1.8 2006/08/03 03:34:42 deraadt Exp $ */
 
 /*
@@ -16,4 +17,3 @@ void
 record_login(pid_t, const char *, const char *, uid_t,
     const char *, struct sockaddr *, socklen_t);
 void	 record_logout(pid_t, const char *);
-time_t	 get_last_login_time(uid_t, const char *, char *, size_t);
Index: src/usr.bin/ssh/sshpty.c
diff -up src/usr.bin/ssh/sshpty.c:1.1.1.5 src/usr.bin/ssh/sshpty.c:1.6
--- src/usr.bin/ssh/sshpty.c:1.1.1.5	Thu Sep 13 15:39:10 2007
+++ src/usr.bin/ssh/sshpty.c	Sun Apr 16 01:06:48 2017
@@ -143,10 +143,10 @@ pty_setowner(struct passwd *pw, const ch
 	grp = getgrnam("tty");
 	if (grp) {
 		gid = grp->gr_gid;
-		mode = S_IRUSR | S_IWUSR | S_IWGRP;
+		mode = 0620;
 	} else {
 		gid = pw->pw_gid;
-		mode = S_IRUSR | S_IWUSR | S_IWGRP | S_IWOTH;
+		mode = 0600;
 	}
 
 	/*
Index: src/usr.bin/ssh/umac.c
diff -up src/usr.bin/ssh/umac.c:1.1.1.3 src/usr.bin/ssh/umac.c:1.7
--- src/usr.bin/ssh/umac.c:1.1.1.3	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/umac.c	Sat Apr  8 19:05:44 2017
@@ -1,4 +1,4 @@
-/* $OpenBSD: umac.c,v 1.3 2008/05/12 20:52:20 pvalchev Exp $ */
+/* $OpenBSD: umac.c,v 1.9*-1.5 2014/04/20 02:30:25 djm Exp $ */
 /* -----------------------------------------------------------------------
  * 
  * umac.c -- C Implementation UMAC Message Authentication
@@ -64,14 +64,19 @@
 /* ---------------------------------------------------------------------- */
 
 #include <sys/types.h>
+#include <sys/time.h>
 #include <sys/endian.h>
-
-#include "xmalloc.h"
-#include "umac.h"
 #include <string.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 
+#include "xmalloc.h"
+#include "umac.h"
+#include "misc.h"
+
+__RCSID("$MirOS: src/usr.bin/ssh/umac.c,v 1.7 2017/04/08 17:05:44 tg Exp $");
+
 /* ---------------------------------------------------------------------- */
 /* --- Primitive Data Types ---                                           */
 /* ---------------------------------------------------------------------- */
@@ -123,38 +128,21 @@ typedef unsigned int	UWORD;  /* Register
 /* --- Endian Conversion --- Forcing assembly on some platforms           */
 /* ---------------------------------------------------------------------- */
 
-#if 0
-static UINT32 LOAD_UINT32_REVERSED(void *ptr)
-{
-    UINT32 temp = *(UINT32 *)ptr;
-    temp = (temp >> 24) | ((temp & 0x00FF0000) >> 8 )
-         | ((temp & 0x0000FF00) << 8 ) | (temp << 24);
-    return (UINT32)temp;
-}
-
-static void STORE_UINT32_REVERSED(void *ptr, UINT32 x)
-{
-    UINT32 i = (UINT32)x;
-    *(UINT32 *)ptr = (i >> 24) | ((i & 0x00FF0000) >> 8 )
-                   | ((i & 0x0000FF00) << 8 ) | (i << 24);
-}
-#endif
-
 /* The following definitions use the above reversal-primitives to do the right
  * thing on endian specific load and stores.
  */
 
-#define LOAD_UINT32_REVERSED(p)		(swap32(*(UINT32 *)(p)))
-#define STORE_UINT32_REVERSED(p,v) 	(*(UINT32 *)(p) = swap32(v))
-
-#if (__LITTLE_ENDIAN__)
-#define LOAD_UINT32_LITTLE(ptr)     (*(UINT32 *)(ptr))
-#define STORE_UINT32_BIG(ptr,x)     STORE_UINT32_REVERSED(ptr,x)
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define LOAD_UINT32_REVERSED(p)		get_u32(p)
+#define STORE_UINT32_REVERSED(p,v) 	put_u32(p,v)
 #else
-#define LOAD_UINT32_LITTLE(ptr)     LOAD_UINT32_REVERSED(ptr)
-#define STORE_UINT32_BIG(ptr,x)     (*(UINT32 *)(ptr) = (UINT32)(x))
+#define LOAD_UINT32_REVERSED(p)		get_u32_le(p)
+#define STORE_UINT32_REVERSED(p,v) 	put_u32_le(p,v)
 #endif
 
+#define LOAD_UINT32_LITTLE(p)           (get_u32_le(p))
+#define STORE_UINT32_BIG(p,v)           put_u32(p, v)
+
 
 
 /* ---------------------------------------------------------------------- */
@@ -172,7 +160,7 @@ typedef AES_KEY aes_int_key[1];
 #define aes_encryption(in,out,int_key)                  \
   AES_encrypt((u_char *)(in),(u_char *)(out),(AES_KEY *)int_key)
 #define aes_key_setup(key,int_key)                      \
-  AES_set_encrypt_key((u_char *)(key),UMAC_KEY_LEN*8,int_key)
+  AES_set_encrypt_key((const u_char *)(key),UMAC_KEY_LEN*8,int_key)
 
 /* The user-supplied UMAC key is stretched using AES in a counter
  * mode to supply all random bits needed by UMAC. The kdf function takes
@@ -211,14 +199,17 @@ static void kdf(void *buffer_ptr, aes_in
  */
 
 typedef struct {
-    UINT8 cache[AES_BLOCK_LEN];  /* Previous AES output is saved      */
-    UINT8 nonce[AES_BLOCK_LEN];  /* The AES input making above cache  */
-    aes_int_key prf_key;         /* Expanded AES key for PDF          */
+	/* Previous AES output is saved */
+	UINT8 cache[AES_BLOCK_LEN] __attribute__((__aligned__(8)));
+	/* The AES input making above cache */
+	UINT8 nonce[AES_BLOCK_LEN] __attribute__((__aligned__(8)));
+	/* Expanded AES key for PDF */
+	aes_int_key prf_key;
 } pdf_ctx;
 
 static void pdf_init(pdf_ctx *pc, aes_int_key prf_key)
 {
-    UINT8 buf[UMAC_KEY_LEN];
+    UINT8 buf[UMAC_KEY_LEN] __attribute__((__aligned__(8)));
     
     kdf(buf, prf_key, 0, UMAC_KEY_LEN);
     aes_key_setup(buf, pc->prf_key);
@@ -228,7 +219,7 @@ static void pdf_init(pdf_ctx *pc, aes_in
     aes_encryption(pc->nonce, pc->cache, pc->prf_key);
 }
 
-static void pdf_gen_xor(pdf_ctx *pc, UINT8 nonce[8], UINT8 buf[8])
+static void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])
 {
     /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes
      * of the AES output. If last time around we returned the ndx-1st
@@ -242,19 +233,21 @@ static void pdf_gen_xor(pdf_ctx *pc, UIN
 #elif (UMAC_OUTPUT_LEN > 8)
 #define LOW_BIT_MASK 0
 #endif
-
-    UINT8 tmp_nonce_lo[4];
+    union {
+        UINT8 tmp_nonce_lo[4];
+        UINT32 align;
+    } t;
 #if LOW_BIT_MASK != 0
     int ndx = nonce[7] & LOW_BIT_MASK;
 #endif
-    *(UINT32 *)tmp_nonce_lo = ((UINT32 *)nonce)[1];
-    tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */
+    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];
+    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */
     
-    if ( (((UINT32 *)tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||
-         (((UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )
+    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||
+         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )
     {
-        ((UINT32 *)pc->nonce)[0] = ((UINT32 *)nonce)[0];
-        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)tmp_nonce_lo)[0];
+        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];
+        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];
         aes_encryption(pc->nonce, pc->cache, pc->prf_key);
     }
     
@@ -311,17 +304,23 @@ static void pdf_gen_xor(pdf_ctx *pc, UIN
 #define HASH_BUF_BYTES       64     /* nh_aux_hb buffer multiple          */
 
 typedef struct {
-    UINT8  nh_key [L1_KEY_LEN + L1_KEY_SHIFT * (STREAMS - 1)]; /* NH Key */
-    UINT8  data   [HASH_BUF_BYTES];    /* Incomming data buffer           */
-    int next_data_empty;    /* Bookeeping variable for data buffer.       */
-    int bytes_hashed;        /* Bytes (out of L1_KEY_LEN) incorperated.   */
-    UINT64 state[STREAMS];               /* on-line state     */
+	/* NH Key */
+	UINT8 nh_key[L1_KEY_LEN + L1_KEY_SHIFT * (STREAMS - 1)]
+	    __attribute__((__aligned__(8)));
+	/* Incoming data buffer */
+	UINT8 data[HASH_BUF_BYTES] __attribute__((__aligned__(8)));
+	/* Bookkeeping variable for data buffer */
+	int next_data_empty;
+	/* Bytes (out of L1_KEY_LEN) incorperated */
+	int bytes_hashed;
+	/* on-line state */
+	UINT64 state[STREAMS];
 } nh_ctx;
 
 
 #if (UMAC_OUTPUT_LEN == 4)
 
-static void nh_aux(void *kp, void *dp, void *hp, UINT32 dlen)
+static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)
 /* NH hashing primitive. Previous (partial) hash result is loaded and     
 * then stored via hp pointer. The length of the data pointed at by "dp",
 * "dlen", is guaranteed to be divisible by L1_PAD_BOUNDARY (32).  Key
@@ -331,7 +330,7 @@ static void nh_aux(void *kp, void *dp, v
     UINT64 h;
     UWORD c = dlen / 32;
     UINT32 *k = (UINT32 *)kp;
-    UINT32 *d = (UINT32 *)dp;
+    const UINT32 *d = (const UINT32 *)dp;
     UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
     UINT32 k0,k1,k2,k3,k4,k5,k6,k7;
     
@@ -356,7 +355,7 @@ static void nh_aux(void *kp, void *dp, v
 
 #elif (UMAC_OUTPUT_LEN == 8)
 
-static void nh_aux(void *kp, void *dp, void *hp, UINT32 dlen)
+static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)
 /* Same as previous nh_aux, but two streams are handled in one pass,
  * reading and writing 16 bytes of hash-state per call.
  */
@@ -364,7 +363,7 @@ static void nh_aux(void *kp, void *dp, v
   UINT64 h1,h2;
   UWORD c = dlen / 32;
   UINT32 *k = (UINT32 *)kp;
-  UINT32 *d = (UINT32 *)dp;
+  const UINT32 *d = (const UINT32 *)dp;
   UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
   UINT32 k0,k1,k2,k3,k4,k5,k6,k7,
         k8,k9,k10,k11;
@@ -403,7 +402,7 @@ static void nh_aux(void *kp, void *dp, v
 
 #elif (UMAC_OUTPUT_LEN == 12)
 
-static void nh_aux(void *kp, void *dp, void *hp, UINT32 dlen)
+static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)
 /* Same as previous nh_aux, but two streams are handled in one pass,
  * reading and writing 24 bytes of hash-state per call.
 */
@@ -411,7 +410,7 @@ static void nh_aux(void *kp, void *dp, v
     UINT64 h1,h2,h3;
     UWORD c = dlen / 32;
     UINT32 *k = (UINT32 *)kp;
-    UINT32 *d = (UINT32 *)dp;
+    const UINT32 *d = (const UINT32 *)dp;
     UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
     UINT32 k0,k1,k2,k3,k4,k5,k6,k7,
         k8,k9,k10,k11,k12,k13,k14,k15;
@@ -458,7 +457,7 @@ static void nh_aux(void *kp, void *dp, v
 
 #elif (UMAC_OUTPUT_LEN == 16)
 
-static void nh_aux(void *kp, void *dp, void *hp, UINT32 dlen)
+static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)
 /* Same as previous nh_aux, but two streams are handled in one pass,
  * reading and writing 24 bytes of hash-state per call.
 */
@@ -466,7 +465,7 @@ static void nh_aux(void *kp, void *dp, v
     UINT64 h1,h2,h3,h4;
     UWORD c = dlen / 32;
     UINT32 *k = (UINT32 *)kp;
-    UINT32 *d = (UINT32 *)dp;
+    const UINT32 *d = (const UINT32 *)dp;
     UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
     UINT32 k0,k1,k2,k3,k4,k5,k6,k7,
         k8,k9,k10,k11,k12,k13,k14,k15,
@@ -527,14 +526,14 @@ static void nh_aux(void *kp, void *dp, v
 
 /* ---------------------------------------------------------------------- */
 
-static void nh_transform(nh_ctx *hc, UINT8 *buf, UINT32 nbytes)
+static void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)
 /* This function is a wrapper for the primitive NH hash functions. It takes
  * as argument "hc" the current hash context and a buffer which must be a
  * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset
  * appropriately according to how much message has been hashed already.
  */
 {
-    UINT8 *key;
+    UINT8 *key __attribute__((__aligned__(4)));;
   
     key = hc->nh_key + hc->bytes_hashed;
     nh_aux(key, buf, hc->state, nbytes);
@@ -542,6 +541,7 @@ static void nh_transform(nh_ctx *hc, UIN
 
 /* ---------------------------------------------------------------------- */
 
+#if (__LITTLE_ENDIAN__)
 static void endian_convert(void *buf, UWORD bpw, UINT32 num_bytes)
 /* We endian convert the keys on little-endian computers to               */
 /* compensate for the lack of big-endian memory reads during hashing.     */
@@ -564,7 +564,6 @@ static void endian_convert(void *buf, UW
         } while (--iters);
     }
 }
-#if (__LITTLE_ENDIAN__)
 #define endian_convert_if_le(x,y,z) endian_convert((x),(y),(z))
 #else
 #define endian_convert_if_le(x,y,z) do{}while(0)  /* Do nothing */
@@ -602,7 +601,7 @@ static void nh_init(nh_ctx *hc, aes_int_
 
 /* ---------------------------------------------------------------------- */
 
-static void nh_update(nh_ctx *hc, UINT8 *buf, UINT32 nbytes)
+static void nh_update(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)
 /* Incorporate nbytes of data into a nh_ctx, buffer whatever is not an    */
 /* even multiple of HASH_BUF_BYTES.                                       */
 {
@@ -697,7 +696,7 @@ static void nh_final(nh_ctx *hc, UINT8 *
 
 /* ---------------------------------------------------------------------- */
 
-static void nh(nh_ctx *hc, UINT8 *buf, UINT32 padded_len,
+static void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,
                UINT32 unpadded_len, UINT8 *result)
 /* All-in-one nh_update() and nh_final() equivalent.
  * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is
@@ -845,7 +844,7 @@ static void poly_hash(uhash_ctx_t hc, UI
 
 
 /* The final step in UHASH is an inner-product hash. The poly hash
- * produces a result not neccesarily WORD_LEN bytes long. The inner-
+ * produces a result not necessarily WORD_LEN bytes long. The inner-
  * product hash breaks the polyhash output into 16-bit chunks and
  * multiplies each with a 36 bit key.
  */
@@ -1035,7 +1034,7 @@ static int uhash_free(uhash_ctx_t ctx)
 #endif
 /* ---------------------------------------------------------------------- */
 
-static int uhash_update(uhash_ctx_t ctx, u_char *input, long len)
+static int uhash_update(uhash_ctx_t ctx, const u_char *input, long len)
 /* Given len bytes of data, we parse it into L1_KEY_LEN chunks and
  * hash each one with NH, calling the polyhash on each NH output.
  */
@@ -1045,7 +1044,7 @@ static int uhash_update(uhash_ctx_t ctx,
     UINT8 *nh_result = (UINT8 *)&result_buf;
     
     if (ctx->msg_len + len <= L1_KEY_LEN) {
-        nh_update(&ctx->hash, (UINT8 *)input, len);
+        nh_update(&ctx->hash, (const UINT8 *)input, len);
         ctx->msg_len += len;
     } else {
     
@@ -1060,7 +1059,7 @@ static int uhash_update(uhash_ctx_t ctx,
              /* bytes to complete the current nh_block.                  */
              if (bytes_hashed) {
                  bytes_remaining = (L1_KEY_LEN - bytes_hashed);
-                 nh_update(&ctx->hash, (UINT8 *)input, bytes_remaining);
+                 nh_update(&ctx->hash, (const UINT8 *)input, bytes_remaining);
                  nh_final(&ctx->hash, nh_result);
                  ctx->msg_len += bytes_remaining;
                  poly_hash(ctx,(UINT32 *)nh_result);
@@ -1070,7 +1069,7 @@ static int uhash_update(uhash_ctx_t ctx,
 
              /* Hash directly from input stream if enough bytes */
              while (len >= L1_KEY_LEN) {
-                 nh(&ctx->hash, (UINT8 *)input, L1_KEY_LEN,
+                 nh(&ctx->hash, (const UINT8 *)input, L1_KEY_LEN,
                                    L1_KEY_LEN, nh_result);
                  ctx->msg_len += L1_KEY_LEN;
                  len -= L1_KEY_LEN;
@@ -1081,7 +1080,7 @@ static int uhash_update(uhash_ctx_t ctx,
 
          /* pass remaining < L1_KEY_LEN bytes of input data to NH */
          if (len) {
-             nh_update(&ctx->hash, (UINT8 *)input, len);
+             nh_update(&ctx->hash, (const UINT8 *)input, len);
              ctx->msg_len += len;
          }
      }
@@ -1118,7 +1117,7 @@ static int uhash(uhash_ctx_t ahc, u_char
 /* assumes that msg is in a writable buffer of length divisible by */
 /* L1_PAD_BOUNDARY. Bytes beyond msg[len] may be zeroed.           */
 {
-    UINT8 nh_result[STREAMS*sizeof(UINT64)];
+    UINT8 nh_result[STREAMS*sizeof(UINT64)] __attribute__((__aligned__(8)));
     UINT32 nh_len;
     int extra_zeroes_needed;
         
@@ -1204,7 +1203,7 @@ int umac_delete(struct umac_ctx *ctx)
 
 /* ---------------------------------------------------------------------- */
 
-struct umac_ctx *umac_new(u_char key[])
+struct umac_ctx *umac_new(const u_char key[])
 /* Dynamically allocate a umac_ctx struct, initialize variables, 
  * generate subkeys from key. Align to 16-byte boundary.
  */
@@ -1213,7 +1212,7 @@ struct umac_ctx *umac_new(u_char key[])
     size_t bytes_to_add;
     aes_int_key prf_key;
     
-    octx = ctx = xmalloc(sizeof(*ctx) + ALLOC_BOUNDARY);
+    octx = ctx = xcalloc(1, sizeof(*ctx) + ALLOC_BOUNDARY);
     if (ctx) {
         if (ALLOC_BOUNDARY) {
             bytes_to_add = ALLOC_BOUNDARY -
@@ -1221,7 +1220,7 @@ struct umac_ctx *umac_new(u_char key[])
             ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);
         }
         ctx->free_ptr = octx;
-        aes_key_setup(key,prf_key);
+        aes_key_setup(key, prf_key);
         pdf_init(&ctx->pdf, prf_key);
         uhash_init(&ctx->hash, prf_key);
     }
@@ -1231,24 +1230,41 @@ struct umac_ctx *umac_new(u_char key[])
 
 /* ---------------------------------------------------------------------- */
 
-int umac_final(struct umac_ctx *ctx, u_char tag[], u_char nonce[8])
+int umac_final(struct umac_ctx *ctx, u_char tag[], const u_char nonce[8])
 /* Incorporate any pending data, pad, and generate tag */
 {
     uhash_final(&ctx->hash, (u_char *)tag);
-    pdf_gen_xor(&ctx->pdf, (UINT8 *)nonce, (UINT8 *)tag);
+    pdf_gen_xor(&ctx->pdf, (const UINT8 *)nonce, (UINT8 *)tag);
     
     return (1);
 }
 
 /* ---------------------------------------------------------------------- */
 
-int umac_update(struct umac_ctx *ctx, u_char *input, long len)
+int umac_update(struct umac_ctx *ctx, const u_char *input, long len)
 /* Given len bytes of data, we parse it into L1_KEY_LEN chunks and   */
 /* hash each one, calling the PDF on the hashed output whenever the hash- */
 /* output buffer is full.                                                 */
 {
-    uhash_update(&ctx->hash, input, len);
-    return (1);
+	union {
+		const u_char *ptr;
+		uintptr_t number;
+	} input_ptr;
+	u_char *cp;
+
+	input_ptr.ptr = input;
+	if (!(input_ptr.number & 3)) {
+		/* input is 32-bit aligned alright */
+		uhash_update(&ctx->hash, input, len);
+		return (1);
+	}
+
+	/* input is not 32-bit aligned, xmemdup it */
+	cp = xmalloc(len);
+	memcpy(cp, input, len);
+	uhash_update(&ctx->hash, cp, len);
+	xfree(cp);
+	return (1);
 }
 
 /* ---------------------------------------------------------------------- */
Index: src/usr.bin/ssh/umac.h
diff -up src/usr.bin/ssh/umac.h:1.1.1.1 src/usr.bin/ssh/umac.h:1.1.1.2
--- src/usr.bin/ssh/umac.h:1.1.1.1	Sat Jun 16 17:11:14 2007
+++ src/usr.bin/ssh/umac.h	Sat Apr  8 18:22:26 2017
@@ -1,4 +1,4 @@
-/* $OpenBSD: umac.h,v 1.1 2007/06/07 19:37:34 pvalchev Exp $ */
+/* $OpenBSD: umac.h,v 1.3 2013/07/22 12:20:02 djm Exp $ */
 /* -----------------------------------------------------------------------
  * 
  * umac.h -- C Implementation UMAC Message Authentication
@@ -52,7 +52,7 @@
     extern "C" {
 #endif
 
-struct umac_ctx *umac_new(u_char key[]);
+struct umac_ctx *umac_new(const u_char key[]);
 /* Dynamically allocate a umac_ctx struct, initialize variables, 
  * generate subkeys from key.
  */
@@ -62,10 +62,10 @@ int umac_reset(struct umac_ctx *ctx);
 /* Reset a umac_ctx to begin authenicating a new message */
 #endif
 
-int umac_update(struct umac_ctx *ctx, u_char *input, long len);
+int umac_update(struct umac_ctx *ctx, const u_char *input, long len);
 /* Incorporate len bytes pointed to by input into context ctx */
 
-int umac_final(struct umac_ctx *ctx, u_char tag[], u_char nonce[8]);
+int umac_final(struct umac_ctx *ctx, u_char tag[], const u_char nonce[8]);
 /* Incorporate any pending data and the ctr value, and return tag. 
  * This function returns error code if ctr < 0. 
  */
@@ -116,6 +116,12 @@ int uhash(uhash_ctx_t ctx,
 
 #endif
 
+/* matching umac-128 API, we reuse umac_ctx, since it's opaque */
+struct umac_ctx *umac128_new(const u_char key[]);
+int umac128_update(struct umac_ctx *ctx, const u_char *input, long len);
+int umac128_final(struct umac_ctx *ctx, u_char tag[], const u_char nonce[8]);
+int umac128_delete(struct umac_ctx *ctx);
+
 #ifdef __cplusplus
     }
 #endif
--- src/usr.bin/ssh/xmalloc.h:1.1.1.3	Wed Sep 20 21:06:50 2006
+++ src/usr.bin/ssh/xmalloc.h	Thu Oct 31 21:07:15 2013
@@ -1,7 +1,10 @@
+/* $MirOS: src/usr.bin/ssh/xmalloc.h,v 1.2 2013/10/31 20:07:15 tg Exp $ */
 /* $OpenBSD: xmalloc.h,v 1.13 2006/08/03 03:34:42 deraadt Exp $ */
 
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright © 2013
+ *	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
  *                    All rights reserved
  * Created: Mon Mar 20 22:09:17 1995 ylo
@@ -22,5 +25,5 @@ void	*xrealloc(void *, size_t, size_t);
 void     xfree(void *);
 char	*xstrdup(const char *);
 int	 xasprintf(char **, const char *, ...)
-                __attribute__((__format__ (printf, 2, 3)))
-                __attribute__((__nonnull__ (2)));
+                __attribute__((__format__(__printf__, 2, 3)))
+                __attribute__((__nonnull__(2)));
Index: src/usr.bin/ssh/lib/Makefile
diff -up src/usr.bin/ssh/lib/Makefile:1.1.1.6 src/usr.bin/ssh/lib/Makefile:1.12
--- src/usr.bin/ssh/lib/Makefile:1.1.1.6	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/lib/Makefile	Fri Mar 28 23:31:59 2014
@@ -1,9 +1,9 @@
-#	$OpenBSD: Makefile,v 1.58 2008/11/04 08:22:13 djm Exp $
+# $MirOS: src/usr.bin/ssh/lib/Makefile,v 1.12 2014/03/28 22:31:59 tg Exp $
+# $OpenBSD: Makefile,v 1.58 2008/11/04 08:22:13 djm Exp $
 
 .PATH:		${.CURDIR}/..
 
 LIB=	ssh
-WANTLINT=
 SRCS=	authfd.c authfile.c bufaux.c bufbn.c buffer.c canohost.c channels.c \
 	cipher.c cipher-3des1.c cipher-bf1.c cipher-ctr.c \
 	cleanup.c compat.c compress.c crc32.c deattack.c fatal.c \
@@ -12,22 +12,14 @@ SRCS=	authfd.c authfile.c bufaux.c bufbn
 	key.c dispatch.c kex.c mac.c uidswap.c uuencode.c misc.c \
 	ssh-dss.c ssh-rsa.c dh.c kexdh.c kexgex.c \
 	kexdhc.c kexgexc.c scard.c msg.c progressmeter.c dns.c \
-	monitor_fdpass.c umac.c addrmatch.c schnorr.c jpake.c
+	monitor_fdpass.c umac.c addrmatch.c
+SRCS+=	md-sha256.c
 
-DEBUGLIBS= no
-NOPROFILE= yes
-NOPIC=	yes
+NOPIC=		yes
 
-install:
-	@echo -n
-
-.include <bsd.own.mk>
+CFLAGS_channels.o+=	-Wno-unused
+CFLAGS_umac.o+=		-Wno-cast-align		#XXX dangerous!
 
-.if (${KERBEROS5:L} == "yes")
-CFLAGS+= -DKRB5 -I${DESTDIR}/usr/include/kerberosV
-
-SRCS+= gss-genr.c
-CFLAGS+= -DGSSAPI
-.endif # KERBEROS5
+install:
 
 .include <bsd.lib.mk>
Index: src/usr.bin/ssh/sftp/Makefile
diff -up src/usr.bin/ssh/sftp/Makefile:1.1.1.3 src/usr.bin/ssh/sftp/Makefile:1.5
--- src/usr.bin/ssh/sftp/Makefile:1.1.1.3	Tue Dec 16 21:15:34 2008
+++ src/usr.bin/ssh/sftp/Makefile	Sun Oct  4 16:29:14 2009
@@ -1,4 +1,5 @@
-#	$OpenBSD: Makefile,v 1.11 2008/04/18 12:32:11 djm Exp $
+# $MirOS: src/usr.bin/ssh/sftp/Makefile,v 1.5 2009/10/04 14:29:14 tg Exp $
+# $OpenBSD: Makefile,v 1.11 2008/04/18 12:32:11 djm Exp $
 
 .PATH:		${.CURDIR}/..
 
@@ -12,6 +13,9 @@ MAN=	sftp.1
 
 SRCS=	sftp.c sftp-client.c sftp-common.c sftp-glob.c
 
+CFLAGS_sftp.o+=		-Wno-unused
+
 .include <bsd.prog.mk>
 
 LDADD+=	-ledit -ltermcap -lutil
+DPADD+=	${LIBEDIT} ${LIBTERMCAP} ${LIBUTIL}
Index: src/usr.bin/ssh/ssh/Makefile
diff -up src/usr.bin/ssh/ssh/Makefile:1.1.1.3 src/usr.bin/ssh/ssh/Makefile:1.6
--- src/usr.bin/ssh/ssh/Makefile:1.1.1.3	Sun Oct  4 15:25:46 2009
+++ src/usr.bin/ssh/ssh/Makefile	Thu Jan 14 20:23:06 2016
@@ -1,33 +1,23 @@
-#	$OpenBSD: Makefile,v 1.53 2009/05/28 16:50:16 andreas Exp $
+# $MirOS: src/usr.bin/ssh/ssh/Makefile,v 1.6 2016/01/14 19:23:06 tg Exp $
+# $OpenBSD: Makefile,v 1.53 2009/05/28 16:50:16 andreas Exp $
 
 .PATH:		${.CURDIR}/..
 
 PROG=	ssh
 BINOWN=	root
 
-#BINMODE?=4555
-
 BINDIR=	/usr/bin
 MAN=	ssh.1 ssh_config.5
 LINKS=	${BINDIR}/ssh ${BINDIR}/slogin
 MLINKS=	ssh.1 slogin.1
 
 SRCS=	ssh.c readconf.c clientloop.c sshtty.c \
-	sshconnect.c sshconnect1.c sshconnect2.c mux.c \
-	roaming_common.c
-
-.include <bsd.own.mk> # for AFS
+	sshconnect.c sshconnect1.c sshconnect2.c mux.c
 
-.if (${KERBEROS5:L} == "yes")
-CFLAGS+= -DKRB5 -I${DESTDIR}/usr/include/kerberosV -DGSSAPI
-.endif # KERBEROS5
+CFLAGS_clientloop.o+=	-Wno-unused
+CFLAGS_sshconnect2.o+=	-Wno-unused
 
 .include <bsd.prog.mk>
 
-.if (${KERBEROS5:L} == "yes")
-DPADD+=  ${LIBGSSAPI} ${LIBKRB5}
-LDADD+=  -lgssapi -lkrb5
-.endif # KERBEROS5
-
 DPADD+=	${LIBCRYPTO} ${LIBZ} ${LIBDES}
 LDADD+=	-lcrypto -lz -ldes
Index: src/usr.bin/ssh/ssh-keygen/Makefile
diff -up src/usr.bin/ssh/ssh-keygen/Makefile:1.1.1.1 src/usr.bin/ssh/ssh-keygen/Makefile:1.2
--- src/usr.bin/ssh/ssh-keygen/Makefile:1.1.1.1	Sat Feb  5 18:29:55 2005
+++ src/usr.bin/ssh/ssh-keygen/Makefile	Sun Oct  4 22:48:35 2009
@@ -1,4 +1,5 @@
-#	$OpenBSD: Makefile,v 1.22 2003/07/28 09:49:56 djm Exp $
+# $MirOS: src/usr.bin/ssh/ssh-keygen/Makefile,v 1.2 2009/10/04 20:48:35 tg Exp $
+# $OpenBSD: Makefile,v 1.22 2003/07/28 09:49:56 djm Exp $
 
 .PATH:		${.CURDIR}/..
 
Index: src/usr.bin/ssh/ssh-keyscan/Makefile
diff -up src/usr.bin/ssh/ssh-keyscan/Makefile:1.1.1.2 src/usr.bin/ssh/ssh-keyscan/Makefile:1.3
--- src/usr.bin/ssh/ssh-keyscan/Makefile:1.1.1.2	Sun Oct  4 15:25:46 2009
+++ src/usr.bin/ssh/ssh-keyscan/Makefile	Thu Jan 14 20:23:06 2016
@@ -1,4 +1,5 @@
-#	$OpenBSD: Makefile,v 1.5 2009/05/28 16:50:16 andreas Exp $
+# $MirOS: src/usr.bin/ssh/ssh-keyscan/Makefile,v 1.3 2016/01/14 19:23:06 tg Exp $
+# $OpenBSD: Makefile,v 1.5 2009/05/28 16:50:16 andreas Exp $
 
 .PATH:		${.CURDIR}/..
 
@@ -10,7 +11,7 @@ BINMODE?=555
 BINDIR=	/usr/bin
 MAN=	ssh-keyscan.1
 
-SRCS=	ssh-keyscan.c roaming_dummy.c
+SRCS=	ssh-keyscan.c
 
 .include <bsd.prog.mk>
 
Index: src/usr.bin/ssh/ssh-keysign/Makefile
diff -up src/usr.bin/ssh/ssh-keysign/Makefile:1.1.1.2 src/usr.bin/ssh/ssh-keysign/Makefile:1.3
--- src/usr.bin/ssh/ssh-keysign/Makefile:1.1.1.2	Sun Oct  4 15:25:46 2009
+++ src/usr.bin/ssh/ssh-keysign/Makefile	Thu Jan 14 20:23:07 2016
@@ -10,7 +10,7 @@ BINMODE?=4555
 BINDIR=	/usr/libexec
 MAN=	ssh-keysign.8
 
-SRCS=	ssh-keysign.c readconf.c roaming_dummy.c
+SRCS=	ssh-keysign.c readconf.c
 
 .include <bsd.prog.mk>
 
Index: src/usr.bin/ssh/sshd/Makefile
diff -up src/usr.bin/ssh/sshd/Makefile:1.1.1.5 src/usr.bin/ssh/sshd/Makefile:1.10
--- src/usr.bin/ssh/sshd/Makefile:1.1.1.5	Sun Oct  4 15:25:46 2009
+++ src/usr.bin/ssh/sshd/Makefile	Thu Jan 14 20:23:07 2016
@@ -1,4 +1,5 @@
-#	$OpenBSD: Makefile,v 1.69 2009/05/28 16:50:16 andreas Exp $
+# $MirOS: src/usr.bin/ssh/sshd/Makefile,v 1.10 2016/01/14 19:23:07 tg Exp $
+# $OpenBSD: Makefile,v 1.69 2009/05/28 16:50:16 andreas Exp $
 
 .PATH:		${.CURDIR}/..
 
@@ -7,6 +8,7 @@ BINOWN=	root
 BINMODE=555
 BINDIR=	/usr/sbin
 MAN=	sshd.8 sshd_config.5
+CPPFLAGS+= -DBSD_AUTH
 
 SRCS=	sshd.c auth-rhosts.c auth-passwd.c auth-rsa.c auth-rh-rsa.c \
 	sshpty.c sshlogin.c servconf.c serverloop.c \
@@ -15,28 +17,18 @@ SRCS=	sshd.c auth-rhosts.c auth-passwd.c
 	auth-bsdauth.c auth2-hostbased.c auth2-kbdint.c \
 	auth2-none.c auth2-passwd.c auth2-pubkey.c \
 	monitor_mm.c monitor.c monitor_wrap.c \
-	kexdhs.c kexgexs.c sftp-server.c sftp-common.c auth2-jpake.c \
-	roaming_common.c
-
-.include <bsd.own.mk> # for KERBEROS and AFS
-
-.if (${KERBEROS5:L} == "yes")
-CFLAGS+=-DKRB5 -I${DESTDIR}/usr/include/kerberosV -DGSSAPI
-SRCS+=  auth-krb5.c auth2-gss.c gss-serv.c gss-serv-krb5.c
-.endif
-
-.include <bsd.prog.mk>
-
-.if (${KERBEROS5:L} == "yes")
-LDADD+= -lgssapi -lkrb5 -lkafs
-DPADD+= ${LIBGSSAPI} ${LIBKRB5}
-.endif
+	kexdhs.c kexgexs.c sftp-server.c sftp-common.c
 
 DPADD+=	${LIBCRYPTO} ${LIBUTIL} ${LIBZ} ${LIBDES}
 LDADD+=	-lcrypto -lutil -lz -ldes
 
-.if (${TCP_WRAPPERS:L} == "yes")
-CFLAGS+= -DLIBWRAP
-DPADD+= ${LIBWRAP}
-LDADD+= -lwrap
-.endif
+CFLAGS_auth1.o+=	-Wno-unused
+CFLAGS_auth2.o+=	-Wno-unused
+CFLAGS_auth2-chall.o+=	-Wno-unused
+CFLAGS_monitor.o+=	-Wno-unused
+CFLAGS_monitor_wrap.o+=	-Wno-unused
+CFLAGS_session.o+=	-Wno-unused
+CFLAGS_sshd.o+=		-Wno-unused
+CFLAGS_serverloop.o+=	-Wno-unused
+
+.include <bsd.prog.mk>
